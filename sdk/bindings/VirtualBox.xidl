<?xml version="1.0" encoding="utf-8"?>

<!--

    Copyright (C) 2006-2012 Oracle Corporation

    This file is part of VirtualBox Open Source Edition (OSE), as
    available from http://www.virtualbox.org. This file is free software;
    you can redistribute it and/or modify it under the terms of the GNU
    General Public License (GPL) as published by the Free Software
    Foundation, in version 2 as it comes in the "COPYING" file of the
    VirtualBox OSE distribution. VirtualBox OSE is distributed in the
    hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
-->

<!--
   This is the master declaration for VirtualBox's Main API,
   represented by COM/XPCOM and web service interfaces.

   From this document, the build system generates several files
   via XSLT that are then used during the build process.

   Below is the list of XSL templates that operate on this file and
   output files they generate. These XSL templates must be updated
   whenever the schema of this file changes:

   1. src/VBox/Main/idl/midl.xsl =>
      out/<platform>/bin/sdk/idl/VirtualBox.idl
      (MS COM interface definition file for Main API)

   2. src/VBox/Main/idl/xpidl.xsl =>
      out/<platform>/bin/sdk/idl/VirtualBox_XPCOM.idl
      (XPCOM interface definition file for Main API)

   3. src/VBox/Main/idl/doxygen.xsl =>
      out/<platform>/obj/src/VBox/Main/VirtualBox.idl
      (pseudo-IDL for Doxygen to generate the official Main API
       documentation)

   4. src/VBox/Main/webservice/*.xsl =>
      a bunch of WSDL and C++ files
      (VirtualBox web service sources and SOAP mappers;
       see src/VBox/Main/webservice/Makefile.kmk for details)

   5. src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl =>
      out/<platform>/obj/src/VBox/Frontends/VirtualBox/VirtualBox/include/COMWrappers.h
      (smart Qt-based C++ wrapper classes for COM interfaces
       of the Main API)

   6. src/VBox/Installer/win32/VirtualBox_TypeLib.xsl =>
      out/<platform>/obj/src/VBox/Installer/win32/VirtualBox_TypeLib.wxi
      (Main API TypeLib block for the WiX installer)

   7. src/VBox/Runtime/common/err/errmsgvboxcom.xsl =>
      out/<platform>/obj/Runtime/errmsgvboxcomdata.h
      (<result> extraction for the %Rhrc format specifier)
-->

<idl>

<desc>
  Welcome to the <b>VirtualBox Main API documentation</b>. This documentation
  describes the so-called <i>VirtualBox Main API</i> which comprises all public
  COM interfaces and components provided by the VirtualBox server and by the
  VirtualBox client library.

  VirtualBox employs a client-server design, meaning that whenever any part of
  VirtualBox is running -- be it the Qt GUI, the VBoxManage command-line
  interface or any virtual machine --, a dedicated server process named
  VBoxSVC runs in the background. This allows multiple processes working with
  VirtualBox to cooperate without conflicts. These processes communicate to each
  other using inter-process communication facilities provided by the COM
  implementation of the host computer.

  On Windows platforms, the VirtualBox Main API uses Microsoft COM, a native COM
  implementation. On all other platforms, Mozilla XPCOM, an open-source COM
  implementation, is used.

  All the parts that a typical VirtualBox user interacts with (the Qt GUI
  and the VBoxManage command-line interface) are technically
  front-ends to the Main API and only use the interfaces that are documented
  in this Main API documentation. This ensures that, with any given release
  version of VirtualBox, all capabilities of the product that could be useful
  to an external client program are always exposed by way of this API.

  The VirtualBox Main API (also called the <i>VirtualBox COM library</i>)
  contains two public component classes:
  <tt>%VirtualBox.VirtualBox</tt> and <tt>%VirtualBox.Session</tt>, which
  implement IVirtualBox and ISession interfaces respectively. These two classes
  are of supreme importance and will be needed in order for any front-end
  program to do anything useful. It is recommended to read the documentation of
  the mentioned interfaces first.

  The <tt>%VirtualBox.VirtualBox</tt> class is a singleton. This means that
  there can be only one object of this class on the local machine at any given
  time. This object is a parent of many other objects in the VirtualBox COM
  library and lives in the VBoxSVC process. In fact, when you create an instance
  of the <tt>VirtualBox.VirtualBox</tt>, the COM subsystem checks if the VBoxSVC
  process is already running, starts it if not, and returns you a reference to
  the <tt>VirtualBox</tt> object created in this process. When the last reference
  to this object is released, the VBoxSVC process ends (with a 5 second delay to
  protect from too frequent restarts).

  The <tt>%VirtualBox.Session</tt> class is a regular component. You can create
  as many <tt>Session</tt> objects as you need but all of them will live in a
  process which issues the object instantiation call. <tt>Session</tt> objects
  represent virtual machine sessions which are used to configure virtual
  machines and control their execution.

  The naming of methods and attributes is very clearly defined: they all start
  with a lowercase letter (except if they start with an acronym), and are using
  CamelCase style otherwise. This naming only applies to the IDL description,
  and is modified by the various language bindings (some convert the first
  character to upper case, some not). See the SDK reference for more details
  about how to call a method or attribute from a specific programming language.
</desc>

<if target="midl">
  <cpp line="enum {"/>
  <cpp line="    kTypeLibraryMajorVersion = 1,"/>
  <cpp line="    kTypeLibraryMinorVersion = 0"/>
  <cpp line="};"/>
</if>

<if target="xpidl">
  <!-- NS_IMPL_THREADSAFE_ISUPPORTSxx_CI macros are placed here, for convenience -->
  <cpp>
/* currently, nsISupportsImpl.h lacks the below-like macros */

#define NS_IMPL_THREADSAFE_QUERY_INTERFACE1_CI  NS_IMPL_QUERY_INTERFACE1_CI
#define NS_IMPL_THREADSAFE_QUERY_INTERFACE2_CI  NS_IMPL_QUERY_INTERFACE2_CI
#define NS_IMPL_THREADSAFE_QUERY_INTERFACE3_CI  NS_IMPL_QUERY_INTERFACE3_CI
#define NS_IMPL_THREADSAFE_QUERY_INTERFACE4_CI  NS_IMPL_QUERY_INTERFACE4_CI


#ifndef NS_IMPL_THREADSAFE_ISUPPORTS1_CI
# define NS_IMPL_THREADSAFE_ISUPPORTS1_CI(_class, _interface)                 \
  NS_IMPL_THREADSAFE_ADDREF(_class)                                           \
  NS_IMPL_THREADSAFE_RELEASE(_class)                                          \
  NS_IMPL_THREADSAFE_QUERY_INTERFACE1_CI(_class, _interface)                  \
  NS_IMPL_CI_INTERFACE_GETTER1(_class, _interface)
#endif

#ifndef NS_IMPL_THREADSAFE_ISUPPORTS2_CI
# define NS_IMPL_THREADSAFE_ISUPPORTS2_CI(_class, _i1, _i2)                   \
  NS_IMPL_THREADSAFE_ADDREF(_class)                                           \
  NS_IMPL_THREADSAFE_RELEASE(_class)                                          \
  NS_IMPL_THREADSAFE_QUERY_INTERFACE2_CI(_class, _i1, _i2)                    \
  NS_IMPL_CI_INTERFACE_GETTER2(_class, _i1, _i2)
#endif

#ifndef NS_IMPL_THREADSAFE_ISUPPORTS3_CI
# define NS_IMPL_THREADSAFE_ISUPPORTS3_CI(_class, _i1, _i2, _i3)              \
  NS_IMPL_THREADSAFE_ADDREF(_class)                                           \
  NS_IMPL_THREADSAFE_RELEASE(_class)                                          \
  NS_IMPL_THREADSAFE_QUERY_INTERFACE3_CI(_class, _i1, _i2, _i3)               \
  NS_IMPL_CI_INTERFACE_GETTER3(_class, _i1, _i2, _i3)
#endif

#ifndef NS_IMPL_THREADSAFE_ISUPPORTS4_CI
# define NS_IMPL_THREADSAFE_ISUPPORTS4_CI(_class, _i1, _i2, _i3, _i4)         \
  NS_IMPL_THREADSAFE_ADDREF(_class)                                           \
  NS_IMPL_THREADSAFE_RELEASE(_class)                                          \
  NS_IMPL_THREADSAFE_QUERY_INTERFACE4_CI(_class, _i1, _i2, _i3, _i4)          \
  NS_IMPL_CI_INTERFACE_GETTER4(_class, _i1, _i2, _i3, _i4)
#endif

#ifndef NS_IMPL_QUERY_INTERFACE1_AMBIGUOUS_CI
# define NS_IMPL_QUERY_INTERFACE1_AMBIGUOUS_CI(_class, _i1, _ic1)             \
  NS_INTERFACE_MAP_BEGIN(_class)                                              \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(_i1, _ic1)                               \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, _ic1)                       \
    NS_IMPL_QUERY_CLASSINFO(_class)                                           \
  NS_INTERFACE_MAP_END
#endif

#ifndef NS_IMPL_QUERY_INTERFACE2_AMBIGUOUS_CI
# define NS_IMPL_QUERY_INTERFACE2_AMBIGUOUS_CI(_class, _i1, _ic1,             \
                                               _i2, _ic2)                     \
  NS_INTERFACE_MAP_BEGIN(_class)                                              \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(_i1, _ic1)                               \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(_i2, _ic2)                               \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, _ic1)                       \
    NS_IMPL_QUERY_CLASSINFO(_class)                                           \
  NS_INTERFACE_MAP_END
#endif

#ifndef NS_IMPL_QUERY_INTERFACE3_AMBIGUOUS_CI
# define NS_IMPL_QUERY_INTERFACE3_AMBIGUOUS_CI(_class, _i1, _ic1,             \
                                               _i2, _ic2, _i3, _ic3)          \
  NS_INTERFACE_MAP_BEGIN(_class)                                              \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(_i1, _ic1)                               \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(_i2, _ic2)                               \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(_i3, _ic3)                               \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, _ic1)                       \
    NS_IMPL_QUERY_CLASSINFO(_class)                                           \
  NS_INTERFACE_MAP_END
#endif

#define NS_IMPL_THREADSAFE_QUERY_INTERFACE1_AMBIGUOUS_CI NS_IMPL_QUERY_INTERFACE1_AMBIGUOUS_CI
#define NS_IMPL_THREADSAFE_QUERY_INTERFACE2_AMBIGUOUS_CI NS_IMPL_QUERY_INTERFACE2_AMBIGUOUS_CI
#define NS_IMPL_THREADSAFE_QUERY_INTERFACE3_AMBIGUOUS_CI NS_IMPL_QUERY_INTERFACE3_AMBIGUOUS_CI

#ifndef NS_IMPL_THREADSAFE_ISUPPORTS1_AMBIGUOUS_CI
# define NS_IMPL_THREADSAFE_ISUPPORTS1_AMBIGUOUS_CI(_class, _i1, _ic1)        \
  NS_IMPL_THREADSAFE_ADDREF(_class)                                           \
  NS_IMPL_THREADSAFE_RELEASE(_class)                                          \
  NS_IMPL_THREADSAFE_QUERY_INTERFACE1_AMBIGUOUS_CI(_class, _i1, _ic1)         \
  NS_IMPL_CI_INTERFACE_GETTER1(_class, _i1)
#endif

#ifndef NS_IMPL_THREADSAFE_ISUPPORTS2_AMBIGUOUS_CI
# define NS_IMPL_THREADSAFE_ISUPPORTS2_AMBIGUOUS_CI(_class, _i1, _ic1,        \
                                                     _i2, _ic2)               \
  NS_IMPL_THREADSAFE_ADDREF(_class)                                           \
  NS_IMPL_THREADSAFE_RELEASE(_class)                                          \
  NS_IMPL_THREADSAFE_QUERY_INTERFACE2_AMBIGUOUS_CI(_class, _i1, _ic1,         \
                                                   _i2, _ic2)                 \
  NS_IMPL_CI_INTERFACE_GETTER2(_class, _i1, _i2)
#endif

#ifndef NS_IMPL_THREADSAFE_ISUPPORTS3_AMBIGUOUS_CI
# define NS_IMPL_THREADSAFE_ISUPPORTS3_AMBIGUOUS_CI(_class, _i1, _ic1,        \
                                                     _i2, _ic2, _i3, _ic3)    \
  NS_IMPL_THREADSAFE_ADDREF(_class)                                           \
  NS_IMPL_THREADSAFE_RELEASE(_class)                                          \
  NS_IMPL_THREADSAFE_QUERY_INTERFACE3_AMBIGUOUS_CI(_class, _i1, _ic1,         \
                                                   _i2, _ic2, _i3, _ic3)      \
  NS_IMPL_CI_INTERFACE_GETTER3(_class, _i1, _i2, _i3)
#endif

  </cpp>
</if>

<library
  name="VirtualBox"
  uuid="46137EEC-703B-4fe5-AFD4-7C9BBBBA0259"
  version="1.3"
  desc="VirtualBox Type Library"
  appUuid="819B4D85-9CEE-493C-B6FC-64FFE759B3C9"
  supportsErrorInfo="yes"
>


  <!--
  // COM result codes for VirtualBox
  /////////////////////////////////////////////////////////////////////////
  -->

  <descGroup id="VirtualBox_COM_result_codes" title="VirtualBox COM result codes">
    <desc>
      This section describes all VirtualBox-specific COM result codes that may
      be returned by methods of VirtualBox COM interfaces in addition to
      standard COM result codes.

      Note that along with the result code, every VirtualBox method returns
      extended error information through the IVirtualBoxErrorInfo interface on
      failure. This interface is a preferred way to present the error to the end
      user because it contains a human readable description of the error. Raw
      result codes, both standard and described in this section, are intended to
      be used by programs to analyze the reason of a failure and select an
      appropriate course of action without involving the end user (for example,
      retry the operation later or make a different call).

      The standard COM result codes that may originate from our methods include:

      <table>
      <tr><td>E_INVALIDARG</td>
      <td>
        Returned when the value of the method's argument is not within the range
        of valid values. This should not be confused with situations when the
        value is within the range but simply doesn't suit the current object
        state and there is a possibility that it will be accepted later (in such
        cases VirtualBox-specific codes are returned, for example,
        <link to="VBOX_E_OBJECT_NOT_FOUND"/>).
      </td>
      </tr>
      <tr><td>E_POINTER</td>
      <td>
        Returned if a memory pointer for the output argument is invalid (for
        example, @c null). When pointers representing input arguments (such
        as strings) are invalid, E_INVALIDARG is returned.
      </td>
      </tr>
      <tr><td>E_ACCESSDENIED</td>
      <td>
        Returned when the called object is not ready. Since the lifetime of a
        public COM object cannot be fully controlled by the implementation,
        VirtualBox maintains the readiness state for all objects it creates and
        returns this code in response to any method call on the object that was
        deactivated by VirtualBox and is not functioning any more.
      </td>
      </tr>
      <tr><td>E_OUTOFMEMORY</td>
      <td>
        Returned when a memory allocation operation fails.
      </td>
      </tr>
      </table>
    </desc>
  </descGroup>

  <!--
    Note that src/VBox/Runtime/common/err/errmsgvboxcom.xsl will ignore
    everything in <result>/<desc> after (and including) the first dot, so express
    the matter of the error code in the first sentence and keep it short.
  -->

  <result name="VBOX_E_OBJECT_NOT_FOUND" value="0x80BB0001">
    <desc>
      Object corresponding to the supplied arguments does not exist.
    </desc>
  </result>

  <result name="VBOX_E_INVALID_VM_STATE" value="0x80BB0002">
    <desc>
      Current virtual machine state prevents the operation.
    </desc>
  </result>

  <result name="VBOX_E_VM_ERROR" value="0x80BB0003">
    <desc>
      Virtual machine error occurred attempting the operation.
    </desc>
  </result>

  <result name="VBOX_E_FILE_ERROR" value="0x80BB0004">
    <desc>
      File not accessible or erroneous file contents.
    </desc>
  </result>

  <result name="VBOX_E_IPRT_ERROR" value="0x80BB0005">
    <desc>
      Runtime subsystem error.
    </desc>
  </result>

  <result name="VBOX_E_PDM_ERROR" value="0x80BB0006">
    <desc>
      Pluggable Device Manager error.
    </desc>
  </result>

  <result name="VBOX_E_INVALID_OBJECT_STATE" value="0x80BB0007">
    <desc>
      Current object state prohibits operation.
    </desc>
  </result>

  <result name="VBOX_E_HOST_ERROR" value="0x80BB0008">
    <desc>
      Host operating system related error.
    </desc>
  </result>

  <result name="VBOX_E_NOT_SUPPORTED" value="0x80BB0009">
    <desc>
      Requested operation is not supported.
    </desc>
  </result>

  <result name="VBOX_E_XML_ERROR" value="0x80BB000A">
    <desc>
      Invalid XML found.
    </desc>
  </result>

  <result name="VBOX_E_INVALID_SESSION_STATE" value="0x80BB000B">
    <desc>
      Current session state prohibits operation.
    </desc>
  </result>

  <result name="VBOX_E_OBJECT_IN_USE" value="0x80BB000C">
    <desc>
      Object being in use prohibits operation.
    </desc>
  </result>

  <!--
    Note that src/VBox/Runtime/common/err/errmsgvboxcom.xsl will ignore
    everything in <result>/<desc> after (and including) the first dot, so express
    the matter of the error code in the first sentence and keep it short.
  -->

  <descGroup/>

  <!--
  // all common enums
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="SettingsVersion"
    uuid="52bd6f5f-1adb-4493-975d-581a9c4b803f"
    >
    <desc>
      Settings version of VirtualBox settings files. This is written to
      the "version" attribute of the root "VirtualBox" element in the settings
      file XML and indicates which VirtualBox version wrote the file.
    </desc>

    <const name="Null"    value="0">
      <desc>Null value, indicates invalid version.</desc>
    </const>
    <const name="v1_0"     value="1">
      <desc>Legacy settings version, not currently supported.</desc>
    </const>
    <const name="v1_1"     value="2">
      <desc>Legacy settings version, not currently supported.</desc>
    </const>
    <const name="v1_2"     value="3">
      <desc>Legacy settings version, not currently supported.</desc>
    </const>
    <const name="v1_3pre"  value="4">
      <desc>Legacy settings version, not currently supported.</desc>
    </const>
    <const name="v1_3"     value="5">
      <desc>Settings version "1.3", written by VirtualBox 2.0.12.</desc>
      <!--
          Machine XML: Capitalization of Uart, Lpt elements and many attributes changed.
      -->
    </const>
    <const name="v1_4"     value="6">
      <desc>Intermediate settings version, understood by VirtualBox 2.1.x.</desc>
      <!--
          VirtualBox.xml: big DiskRegistry -> MediaRegistry revamp, various HardDisk types merged
          (was VirtualDiskImage, VMDKImage, VHDImage, ISCSIHardDisk, CustomHardDisk, DiffHardDisk)
      -->
    </const>
    <const name="v1_5"     value="7">
      <desc>Intermediate settings version, understood by VirtualBox 2.1.x.</desc>
      <!--
          2008-09-04: 2.0.0 released
          2008-11-20: settings version 1.5 introduced
          2008-12-17: 2.1.0 released
          Machine changes:
            guest OS identifiers changed;
            Machine/Hardware/Display/MonitorCount renamed to monitorCount;
            Machine/Hardware/Display/Accelerate3D renamed to accelerate3D;
            Machine/Hardware/CPU/CPUCount/@count changed to CPU/@count
      -->
    </const>
    <const name="v1_6"     value="8">
      <desc>Settings version "1.6", written by VirtualBox 2.1.4 (at least).</desc>
      <!--
          2008-12-17: 2.1.0 released
          2008-12-19: settings version 1.6 introduced (is in 2.1 branch)
          2009-04-08: 2.2.0 released
          Machine changes: remove all Machine/Hardware/Network/Adapter/HostInterface[@TAPSetup or @TAPTerminate]/ attributes (done)
      -->
    </const>
    <const name="v1_7"     value="9">
      <desc>Settings version "1.7", written by VirtualBox 2.2.x and 3.0.x.</desc>
      <!--
          2008-12-17: 2.1.0 released
          2009-03-11: settings version 1.7 introduced (is in 2.2 branch)
          2009-04-08: 2.2.0 released
          VirtualBox.xml additions: NetserviceRegistry with DHCPServers (done)
          Machine changes: HardDiskAttachments is now StorageControllers (done)
      -->
    </const>
    <const name="v1_8"     value="10">
      <desc>Intermediate settings version "1.8", understood by VirtualBox 3.1.x.</desc>
      <!--
          Machine additions: Display/@accelerate2DVideo (done)
      -->
    </const>
    <const name="v1_9"     value="11">
      <desc>Settings version "1.9", written by VirtualBox 3.1.x.</desc>
      <!--
          The big storage controller / DVD / Floppy rework (done)
      -->
    </const>
    <const name="v1_10"     value="12">
      <desc>Settings version "1.10", written by VirtualBox 3.2.x.</desc>
      <!--
          Machine changes: RTC localOrUTC (done)
          CPU hot-plug support
      -->
    </const>
    <const name="v1_11"     value="13">
      <desc>Settings version "1.11", written by VirtualBox 4.0.x.</desc>
      <!--
          Machine changes: HD Audio controller, per-machine disk registries,
          /@format attribute for DVD and floppy images.
      -->
    </const>
    <const name="v1_12"     value="14">
      <desc>Settings version "1.12", written by VirtualBox 4.1.x.</desc>
      <!--
          Machine changes: raw PCI device attachment;
          NetworkAdapter changes: bandwidth group.
      -->
    </const>
    <const name="v1_13"     value="15">
      <desc>Settings version "1.13", written by VirtualBox 4.2.x.</desc>
      <!--
          Machine changes: tracing config, groups, autostart;
          NetworkAdapter changes: unit for bandwidth group limits.
      -->
    </const>

    <const name="Future"     value="99999">
      <desc>Settings version greater than "1.13", written by a future VirtualBox version.</desc>
    </const>
  </enum>

  <enum
    name="AccessMode"
    uuid="1da0007c-ddf7-4be8-bcac-d84a1558785f"
    >
    <desc>
      Access mode for opening files.
    </desc>

    <const name="ReadOnly"   value="1"/>
    <const name="ReadWrite"  value="2"/>
  </enum>

  <enum
    name="MachineState"
    uuid="ec6c6a9e-113d-4ff4-b44f-0b69f21c97fe"
    >
    <desc>
      Virtual machine execution state.

      This enumeration represents possible values of the <link
      to="IMachine::state"/> attribute.

      Below is the basic virtual machine state diagram. It shows how the state
      changes during virtual machine execution. The text in square braces shows
      a method of the IConsole interface that performs the given state
      transition.

      <pre>
            +---------[powerDown()] &lt;- Stuck &lt;--[failure]-+
            V                                             |
    +-&gt; PoweredOff --+--&gt;[powerUp()]--&gt; Starting --+      | +-----[resume()]-----+
    |                |                             |      | V                    |
    |   Aborted -----+                             +--&gt; Running --[pause()]--&gt; Paused
    |                                              |      ^ |                   ^ |
    |   Saved -----------[powerUp()]--&gt; Restoring -+      | |                   | |
    |     ^                                               | |                   | |
    |     |     +-----------------------------------------+-|-------------------+ +
    |     |     |                                           |                     |
    |     |     +-- Saving &lt;--------[takeSnapshot()]&lt;-------+---------------------+
    |     |                                                 |                     |
    |     +-------- Saving &lt;--------[saveState()]&lt;----------+---------------------+
    |                                                       |                     |
    +-------------- Stopping -------[powerDown()]&lt;----------+---------------------+
      </pre>

      Note that states to the right from PoweredOff, Aborted and Saved in the
      above diagram are called <i>online VM states</i>. These states
      represent the virtual machine which is being executed in a dedicated
      process (usually with a GUI window attached to it where you can see the
      activity of the virtual machine and interact with it). There are two
      special pseudo-states, FirstOnline and LastOnline, that can be used in
      relational expressions to detect if the given machine state is online or
      not:

      <pre>
        if (machine.GetState() &gt;= MachineState_FirstOnline &amp;&amp;
            machine.GetState() &lt;= MachineState_LastOnline)
        {
            ...the machine is being executed...
        }
      </pre>

      When the virtual machine is in one of the online VM states (that is, being
      executed), only a few machine settings can be modified. Methods working
      with such settings contain an explicit note about that. An attempt to
      change any other setting or perform a modifying operation during this time
      will result in the @c VBOX_E_INVALID_VM_STATE error.

      All online states except Running, Paused and Stuck are transitional: they
      represent temporary conditions of the virtual machine that will last as
      long as the operation that initiated such a condition.

      The Stuck state is a special case. It means that execution of the machine
      has reached the "Guru Meditation" condition. This condition indicates an
      internal VMM (virtual machine manager) failure which may happen as a
      result of either an unhandled low-level virtual hardware exception or one
      of the recompiler exceptions (such as the <i>too-many-traps</i>
      condition).

      Note also that any online VM state may transit to the Aborted state. This
      happens if the process that is executing the virtual machine terminates
      unexpectedly (for example, crashes). Other than that, the Aborted state is
      equivalent to PoweredOff.

      There are also a few additional state diagrams that do not deal with
      virtual machine execution and therefore are shown separately. The states
      shown on these diagrams are called <i>offline VM states</i> (this includes
      PoweredOff, Aborted and Saved too).

      The first diagram shows what happens when a lengthy setup operation is
      being executed (such as <link to="IMachine::attachDevice"/>).

      <pre>
    +----------------------------------(same state as before the call)------+
    |                                                                       |
    +-&gt; PoweredOff --+                                                      |
    |                |                                                      |
    |-&gt; Aborted -----+--&gt;[lengthy VM configuration call] --&gt; SettingUp -----+
    |                |
    +-&gt; Saved -------+
      </pre>

      The next two diagrams demonstrate the process of taking a snapshot of a
      powered off virtual machine, restoring the state to that as of a snapshot
      or deleting a snapshot, respectively.

      <pre>
    +----------------------------------(same state as before the call)------+
    |                                                                       |
    +-&gt; PoweredOff --+                                                      |
    |                +--&gt;[takeSnapshot()] -------------------&gt; Saving ------+
    +-&gt; Aborted -----+

    +-&gt; PoweredOff --+
    |                |
    |   Aborted -----+--&gt;[restoreSnapshot()    ]-------&gt; RestoringSnapshot -+
    |                |   [deleteSnapshot()     ]-------&gt; DeletingSnapshot --+
    +-&gt; Saved -------+                                                      |
    |                                                                       |
    +---(Saved if restored from an online snapshot, PoweredOff otherwise)---+
      </pre>

      Note that the Saving state is present in both the offline state group and
      online state group. Currently, the only way to determine what group is
      assumed in a particular case is to remember the previous machine state: if
      it was Running or Paused, then Saving is an online state, otherwise it is
      an offline state. This inconsistency may be removed in one of the future
      versions of VirtualBox by adding a new state.

      <note internal="yes">
        For whoever decides to touch this enum: In order to keep the
        comparisons involving FirstOnline and LastOnline pseudo-states valid,
        the numeric values of these states must be correspondingly updated if
        needed: for any online VM state, the condition
        <tt>FirstOnline &lt;= state &lt;= LastOnline</tt> must be
        @c true. The same relates to transient states for which
        the condition <tt>FirstOnline &lt;= state &lt;= LastOnline</tt> must be
        @c true.
      </note>
    </desc>

    <const name="Null"                  value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="PoweredOff"            value="1">
      <desc>
        The machine is not running and has no saved execution state; it has
        either never been started or been shut down successfully.
      </desc>
    </const>
    <const name="Saved"                 value="2">
      <desc>
        The machine is not currently running, but the execution state of the machine
        has been saved to an external file when it was running, from where
        it can be resumed.
      </desc>
    </const>
    <const name="Teleported"            value="3">
      <desc>
        The machine was teleported to a different host (or process) and then
        powered off.  Take care when powering it on again may corrupt resources
        it shares with the teleportation target (e.g. disk and network).
      </desc>
    </const>
    <const name="Aborted"               value="4">
      <desc>
        The process running the machine has terminated abnormally. This may
        indicate a crash of the VM process in host execution context, or
        the VM process has been terminated externally.
      </desc>
    </const>
    <const name="Running"               value="5">
      <desc>
        The machine is currently being executed.
        <note internal="yes">
          For whoever decides to touch this enum: In order to keep the
          comparisons in the old source code valid, this state must immediately
          precede the Paused state.
          TODO: Lift this spectacularly wonderful restriction.
        </note>
      </desc>
    </const>
    <const name="Paused"                value="6">
      <desc>
        Execution of the machine has been paused.
        <note internal="yes">
          For whoever decides to touch this enum: In order to keep the
          comparisons in the old source code valid, this state must immediately
          follow the Running state.
          TODO: Lift this spectacularly wonderful restriction.
        </note>
      </desc>
    </const>
    <const name="Stuck"                 value="7">
      <desc>
        Execution of the machine has reached the "Guru Meditation"
        condition. This indicates a severe error in the hypervisor itself.
        <note internal="yes">
          bird: Why this uncool name? Could we rename it to "GuruMeditation" or
                "Guru", perhaps? Or are there some other VMM states that are
                intended to be lumped in here as well?
        </note>
      </desc>
    </const>
    <const name="Teleporting"           value="8">
      <desc>
        The machine is about to be teleported to a different host or process.
        It is possible to pause a machine in this state, but it will go to the
        @c TeleportingPausedVM state and it will not be
        possible to resume it again unless the teleportation fails.
      </desc>
    </const>
    <const name="LiveSnapshotting"      value="9">
      <desc>
        A live snapshot is being taken.  The machine is running normally, but
        some of the runtime configuration options are inaccessible.  Also, if
        paused while in this state it will transition to
        @c Saving and it will not be resume the
        execution until the snapshot operation has completed.
      </desc>
    </const>
    <const name="Starting"              value="10">
      <desc>
        Machine is being started after powering it on from a
        zero execution state.
      </desc>
    </const>
    <const name="Stopping"              value="11">
      <desc>
        Machine is being normally stopped powering it off, or after the guest OS
        has initiated a shutdown sequence.
      </desc>
    </const>
    <const name="Saving"                value="12">
      <desc>
        Machine is saving its execution state to a file, or an online
        snapshot of the machine is being taken.
      </desc>
    </const>
    <const name="Restoring"             value="13">
      <desc>
        Execution state of the machine is being restored from a file
        after powering it on from the saved execution state.
      </desc>
    </const>
    <const name="TeleportingPausedVM"   value="14">
      <desc>
        The machine is being teleported to another host or process, but it is
        not running.  This is the paused variant of the
        @c state.
      </desc>
    </const>
    <const name="TeleportingIn"         value="15">
      <desc>
        Teleporting the machine state in from another host or process.
      </desc>
    </const>
    <const name="FaultTolerantSyncing"   value="16">
      <desc>
        The machine is being synced with a fault tolerant VM running elsewhere.
      </desc>
    </const>
    <const name="DeletingSnapshotOnline" value="17">
      <desc>
        Like @c DeletingSnapshot, but the merging of media is ongoing in
        the background while the machine is running.
      </desc>
    </const>
    <const name="DeletingSnapshotPaused" value="18">
      <desc>
        Like @c DeletingSnapshotOnline, but the machine was paused when the
        merging of differencing media was started.
      </desc>
    </const>
    <const name="RestoringSnapshot"     value="19">
      <desc>
        A machine snapshot is being restored; this typically does not take long.
      </desc>
    </const>
    <const name="DeletingSnapshot"      value="20">
      <desc>
        A machine snapshot is being deleted; this can take a long time since this
        may require merging differencing media. This value indicates that the
        machine is not running while the snapshot is being deleted.
      </desc>
    </const>
    <const name="SettingUp"             value="21">
      <desc>
        Lengthy setup operation is in progress.
      </desc>
    </const>

    <const name="FirstOnline" value="5" wsmap="suppress"> <!-- Running -->
      <desc>
        Pseudo-state: first online state (for use in relational expressions).
      </desc>
    </const>
    <const name="LastOnline"  value="18" wsmap="suppress"> <!-- DeletingSnapshotPaused -->
      <desc>
        Pseudo-state: last online state (for use in relational expressions).
      </desc>
    </const>

    <const name="FirstTransient" value="8" wsmap="suppress"> <!-- Teleporting -->
      <desc>
        Pseudo-state: first transient state (for use in relational expressions).
      </desc>
    </const>
    <const name="LastTransient"  value="21" wsmap="suppress"> <!-- SettingUp -->
      <desc>
        Pseudo-state: last transient state (for use in relational expressions).
      </desc>
    </const>

  </enum>

  <enum
    name="SessionState"
    uuid="cf2700c0-ea4b-47ae-9725-7810114b94d8"
    >
    <desc>
      Session state. This enumeration represents possible values of
      <link to="IMachine::sessionState"/> and <link to="ISession::state"/>
      attributes.
    </desc>

    <const name="Null"                  value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="Unlocked"              value="1">
      <desc>
        In <link to="IMachine::sessionState"/>, this means that the machine
        is not locked for any sessions.

        In <link to="ISession::state"/>, this means that no machine is
        currently locked for this session.
      </desc>
    </const>
    <const name="Locked"                value="2">
      <desc>
        In <link to="IMachine::sessionState"/>, this means that the machine
        is currently locked for a session, whose process identifier can
        then be found in the <link to="IMachine::sessionPID" /> attribute.

        In <link to="ISession::state"/>, this means that a machine is
        currently locked for this session, and the mutable machine object
        can be found in the <link to="ISession::machine"/> attribute
        (see <link to="IMachine::lockMachine" /> for details).
      </desc>
    </const>
    <const name="Spawning"              value="3">
      <desc>
        A new process is being spawned for the machine as a result of
        <link to="IMachine::launchVMProcess"/> call. This state also occurs
        as a short transient state during an <link to="IMachine::lockMachine"/>
        call.
      </desc>
    </const>
    <const name="Unlocking"             value="4">
      <desc>
        The session is being unlocked.
      </desc>
    </const>
  </enum>

  <enum
    name="CPUPropertyType"
    uuid="24d356a6-2f45-4abd-b977-1cbe9c4701f5"
    >
    <desc>
      Virtual CPU property type. This enumeration represents possible values of the
      IMachine get- and setCPUProperty methods.
    </desc>
    <const name="Null"                  value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="PAE"                   value="1">
      <desc>
        This setting determines whether VirtualBox will expose the Physical Address
        Extension (PAE) feature of the host CPU to the guest. Note that in case PAE
        is not available, it will not be reported.
      </desc>
    </const>
    <const name="Synthetic"             value="2">
      <desc>
        This setting determines whether VirtualBox will expose a synthetic CPU to the guest to allow
        teleporting between host systems that differ significantly.
      </desc>
    </const>
  </enum>


  <enum
    name="HWVirtExPropertyType"
    uuid="ce81dfdd-d2b8-4a90-bbea-40ee8b7ffcee"
    >
    <desc>
      Hardware virtualization property type. This enumeration represents possible values
      for the <link to="IMachine::getHWVirtExProperty"/> and
      <link to="IMachine::setHWVirtExProperty"/> methods.
    </desc>
    <const name="Null"                value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="Enabled"             value="1">
      <desc>
        Whether hardware virtualization (VT-x/AMD-V) is enabled at all. If
        such extensions are not available, they will not be used.
      </desc>
    </const>
    <const name="Exclusive"           value="2">
      <desc>
        Whether hardware virtualization is used exclusively by VirtualBox. When enabled,
        VirtualBox assumes it can acquire full and exclusive access to the VT-x or AMD-V
        feature of the host. To share these with other hypervisors, you must disable this property.
      </desc>
    </const>
    <const name="VPID"                value="3">
      <desc>
        Whether VT-x VPID is enabled. If this extension is not available, it will not be used.
      </desc>
    </const>
    <const name="NestedPaging"        value="4">
      <desc>
        Whether Nested Paging is enabled. If this extension is not available, it will not be used.
      </desc>
    </const>
    <const name="LargePages"          value="5">
      <desc>
        Whether large page allocation is enabled; requires nested paging and a 64 bits host.
      </desc>
    </const>
    <const name="Force"               value="6">
      <desc>
        Whether the VM should fail to start if hardware virtualization (VT-x/AMD-V) cannot be used. If
        not set, there will be an automatic fallback to software virtualization.
      </desc>
    </const>
  </enum>

  <enum
    name="FaultToleranceState"
    uuid="5124f7ec-6b67-493c-9dee-ee45a44114e1"
    >
    <desc>
      Used with <link to="IMachine::faultToleranceState" />.
    </desc>
    <const name="Inactive" value="1">
      <desc>No fault tolerance enabled.</desc>
    </const>
    <const name="Master" value="2">
      <desc>Fault tolerant master VM.</desc>
    </const>
    <const name="Standby" value="3">
      <desc>Fault tolerant standby VM.</desc>
    </const>
  </enum>

  <enum
    name="LockType"
    uuid="168a6a8e-12fd-4878-a1f9-38a750a56089"
    >
    <desc>
      Used with <link to="IMachine::lockMachine" />.
    </desc>
    <const name="Write" value="2">
      <desc>Lock the machine for writing.</desc>
    </const>
    <const name="Shared" value="1">
      <desc>Request only a shared read lock for remote-controlling the machine.</desc>
    </const>
    <const name="VM" value="3">
      <desc>Lock the machine for writing, and create objects necessary for
        running a VM in this process.</desc>
    </const>
  </enum>

  <enum
    name="SessionType"
    uuid="A13C02CB-0C2C-421E-8317-AC0E8AAA153A"
    >
    <desc>
      Session type. This enumeration represents possible values of the
      <link to="ISession::type"/> attribute.
    </desc>

    <const name="Null"                  value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="WriteLock"             value="1">
      <desc>
        Session has acquired an exclusive write lock on a machine
        using <link to="IMachine::lockMachine"/>.
      </desc>
    </const>
    <const name="Remote"                value="2">
      <desc>
        Session has launched a VM process using
        <link to="IMachine::launchVMProcess"/>
      </desc>
    </const>
    <const name="Shared"                value="3">
      <desc>
        Session has obtained a link to another session using
        <link to="IMachine::lockMachine"/>
      </desc>
    </const>
  </enum>

  <enum
    name="DeviceType"
    uuid="6d9420f7-0b56-4636-99f9-7346f1b01e57"
    >
    <desc>
      Device type.
    </desc>
    <const name="Null"              value="0">
      <desc>
        Null value, may also mean "no device" (not allowed for
        <link to="IConsole::getDeviceActivity"/>).
      </desc>
    </const>
    <const name="Floppy"            value="1">
      <desc>Floppy device.</desc>
    </const>
    <const name="DVD"               value="2">
      <desc>CD/DVD-ROM device.</desc>
    </const>
    <const name="HardDisk"          value="3">
      <desc>Hard disk device.</desc>
    </const>
    <const name="Network"           value="4">
      <desc>Network device.</desc>
    </const>
    <const name="USB"               value="5">
      <desc>USB device.</desc>
    </const>
    <const name="SharedFolder"      value="6">
      <desc>Shared folder device.</desc>
    </const>
  </enum>

  <enum
    name="DeviceActivity"
    uuid="6FC8AEAA-130A-4eb5-8954-3F921422D707"
    >
    <desc>
      Device activity for <link to="IConsole::getDeviceActivity"/>.
    </desc>

    <const name="Null"              value="0"/>
    <const name="Idle"              value="1"/>
    <const name="Reading"           value="2"/>
    <const name="Writing"           value="3"/>
  </enum>

  <enum
    name="ClipboardMode"
    uuid="33364716-4008-4701-8f14-be0fa3d62950"
    >
    <desc>
      Host-Guest clipboard interchange mode.
    </desc>

    <const name="Disabled"          value="0"/>
    <const name="HostToGuest"       value="1"/>
    <const name="GuestToHost"       value="2"/>
    <const name="Bidirectional"     value="3"/>
  </enum>

  <enum
    name="DragAndDropMode"
    uuid="b618ea0e-b6fb-4f8d-97f7-5e237e49b547"
    >
    <desc>
      Drag'n'Drop interchange mode.
    </desc>

    <const name="Disabled"          value="0"/>
    <const name="HostToGuest"       value="1"/>
    <const name="GuestToHost"       value="2"/>
    <const name="Bidirectional"     value="3"/>
  </enum>

  <enum
    name="Scope"
    uuid="7c91096e-499e-4eca-9f9b-9001438d7855"
    >
    <desc>
      Scope of the operation.

      A generic enumeration used in various methods to define the action or
      argument scope.
    </desc>

    <const name="Global"          value="0"/>
    <const name="Machine"         value="1"/>
    <const name="Session"         value="2"/>
  </enum>

  <enum
    name="BIOSBootMenuMode"
    uuid="ae4fb9f7-29d2-45b4-b2c7-d579603135d5"
    >
    <desc>
      BIOS boot menu mode.
    </desc>

    <const name="Disabled"        value="0"/>
    <const name="MenuOnly"        value="1"/>
    <const name="MessageAndMenu"  value="2"/>
  </enum>

  <enum
    name="ProcessorFeature"
    uuid="64c38e6b-8bcf-45ad-ac03-9b406287c5bf"
    >
    <desc>
      CPU features.
    </desc>

    <const name="HWVirtEx"        value="0"/>
    <const name="PAE"             value="1"/>
    <const name="LongMode"        value="2"/>
    <const name="NestedPaging"    value="3"/>
  </enum>

  <enum
    name="FirmwareType"
    uuid="b903f264-c230-483e-ac74-2b37ce60d371"
    >
    <desc>
      Firmware type.
    </desc>
    <const name="BIOS"           value="1">
      <desc>BIOS Firmware.</desc>
    </const>
    <const name="EFI"            value="2">
      <desc>EFI Firmware, bitness detected basing on OS type.</desc>
    </const>
    <const name="EFI32"          value="3">
      <desc>Efi firmware, 32-bit.</desc>
    </const>
    <const name="EFI64"          value="4">
      <desc>Efi firmware, 64-bit.</desc>
    </const>
    <const name="EFIDUAL"        value="5">
      <desc>Efi firmware, combined 32 and 64-bit.</desc>
    </const>
  </enum>

  <enum
    name="PointingHIDType"
    uuid="e44b2f7b-72ba-44fb-9e53-2186014f0d17"
    >
    <desc>
      Type of pointing device used in a virtual machine.
    </desc>
    <const name="None"           value="1">
      <desc>No mouse.</desc>
    </const>
    <const name="PS2Mouse"       value="2">
      <desc>PS/2 auxiliary device, a.k.a. mouse.</desc>
    </const>
    <const name="USBMouse"       value="3">
      <desc>USB mouse (relative pointer).</desc>
    </const>
    <const name="USBTablet"      value="4">
      <desc>USB tablet (absolute pointer).</desc>
    </const>
    <const name="ComboMouse"     value="5">
      <desc>Combined device, working as PS/2 or USB mouse, depending on guest behavior.
      Using of such device can have negative performance implications. </desc>
    </const>
  </enum>

  <enum
    name="KeyboardHIDType"
    uuid="383e43d7-5c7c-4ec8-9cb8-eda1bccd6699"
    >
    <desc>
      Type of keyboard device used in a virtual machine.
    </desc>
    <const name="None"              value="1">
      <desc>No keyboard.</desc>
    </const>
    <const name="PS2Keyboard"       value="2">
      <desc>PS/2 keyboard.</desc>
    </const>
    <const name="USBKeyboard"       value="3">
      <desc>USB keyboard.</desc>
    </const>
    <const name="ComboKeyboard"     value="4">
      <desc>Combined device, working as PS/2 or USB keyboard, depending on guest behavior.
      Using of such device can have negative performance implications. </desc>
    </const>
  </enum>

  <!--
  // IVirtualBoxErrorInfo
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IVirtualBoxErrorInfo" extends="$errorinfo"
    uuid="f91e6e91-49e1-4fd2-b21e-269003350d06"
    supportsErrorInfo="no"
    wsmap="managed"
    >
    <desc>
      The IVirtualBoxErrorInfo interface represents extended error information.

      Extended error information can be set by VirtualBox components after
      unsuccessful or partially successful method invocation. This information
      can be retrieved by the calling party as an IVirtualBoxErrorInfo object
      and then shown to the client in addition to the plain 32-bit result code.

      In MS COM, this interface extends the IErrorInfo interface,
      in XPCOM, it extends the nsIException interface. In both cases,
      it provides a set of common attributes to retrieve error
      information.

      Sometimes invocation of some component's method may involve methods of
      other components that may also fail (independently of this method's
      failure), or a series of non-fatal errors may precede a fatal error that
      causes method failure. In cases like that, it may be desirable to preserve
      information about all errors happened during method invocation and deliver
      it to the caller. The <link to="#next"/> attribute is intended
      specifically for this purpose and allows to represent a chain of errors
      through a single IVirtualBoxErrorInfo object set after method invocation.

      <note>errors are stored to a chain in the reverse order, i.e. the
      initial error object you query right after method invocation is the last
      error set by the callee, the object it points to in the @a next attribute
      is the previous error and so on, up to the first error (which is the last
      in the chain).</note>
    </desc>

    <attribute name="resultCode" type="long" readonly="yes">
      <desc>
        Result code of the error.
        Usually, it will be the same as the result code returned
        by the method that provided this error information, but not
        always. For example, on Win32, CoCreateInstance() will most
        likely return E_NOINTERFACE upon unsuccessful component
        instantiation attempt, but not the value the component factory
        returned. Value is typed 'long', not 'result',
        to make interface usable from scripting languages.
        <note>
          In MS COM, there is no equivalent.
          In XPCOM, it is the same as nsIException::result.
        </note>
      </desc>
    </attribute>

    <attribute name="interfaceID" type="uuid" mod="string" readonly="yes">
      <desc>
        UUID of the interface that defined the error.
        <note>
          In MS COM, it is the same as IErrorInfo::GetGUID, except for the
          data type.
          In XPCOM, there is no equivalent.
        </note>
      </desc>
    </attribute>

    <attribute name="component" type="wstring" readonly="yes">
      <desc>
        Name of the component that generated the error.
        <note>
          In MS COM, it is the same as IErrorInfo::GetSource.
          In XPCOM, there is no equivalent.
        </note>
      </desc>
    </attribute>

    <attribute name="text" type="wstring" readonly="yes">
      <desc>
        Text description of the error.
        <note>
          In MS COM, it is the same as IErrorInfo::GetDescription.
          In XPCOM, it is the same as nsIException::message.
        </note>
      </desc>
    </attribute>

    <attribute name="next" type="IVirtualBoxErrorInfo" readonly="yes">
      <desc>
        Next error object if there is any, or @c null otherwise.
        <note>
          In MS COM, there is no equivalent.
          In XPCOM, it is the same as nsIException::inner.
        </note>
      </desc>
    </attribute>

  </interface>

  <!--
  // IVirtualBox
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IDHCPServer" extends="$unknown"
    uuid="6cfe387c-74fb-4ca7-bff6-973bec8af7a3"
    wsmap="managed"
    >
    <desc>
      The IDHCPServer interface represents the vbox DHCP server configuration.

      To enumerate all the DHCP servers on the host, use the
      <link to="IVirtualBox::DHCPServers"/> attribute.
    </desc>

    <attribute name="enabled" type="boolean">
      <desc>
        specifies if the DHCP server is enabled
      </desc>
    </attribute>

    <attribute name="IPAddress" type="wstring" readonly="yes">
      <desc>
        specifies server IP
      </desc>
    </attribute>

    <attribute name="networkMask" type="wstring" readonly="yes">
      <desc>
        specifies server network mask
      </desc>
    </attribute>

    <attribute name="networkName" type="wstring" readonly="yes">
      <desc>
        specifies internal network name the server is used for
      </desc>
    </attribute>

    <attribute name="lowerIP" type="wstring" readonly="yes">
      <desc>
        specifies from IP address in server address range
      </desc>
    </attribute>

    <attribute name="upperIP" type="wstring" readonly="yes">
      <desc>
        specifies to IP address in server address range
      </desc>
    </attribute>

    <method name="setConfiguration">
      <desc>
        configures the server
        <result name="E_INVALIDARG">
          invalid configuration supplied
        </result>
      </desc>
      <param name="IPAddress" type="wstring" dir="in">
        <desc>
          server IP address
        </desc>
      </param>
      <param name="networkMask" type="wstring" dir="in">
        <desc>
          server network mask
      </desc>
      </param>
      <param name="FromIPAddress" type="wstring" dir="in">
        <desc>
          server From IP address for address range
        </desc>
      </param>
      <param name="ToIPAddress" type="wstring" dir="in">
        <desc>
          server To IP address for address range
        </desc>
      </param>
    </method>

    <method name="start">
      <desc>
        Starts DHCP server process.
        <result name="E_FAIL">
          Failed to start the process.
        </result>
      </desc>
      <param name="networkName" type="wstring" dir="in">
        <desc>
          Name of internal network DHCP server should attach to.
        </desc>
      </param>
      <param name="trunkName" type="wstring" dir="in">
        <desc>
          Name of internal network trunk.
        </desc>
      </param>
      <param name="trunkType" type="wstring" dir="in">
        <desc>
          Type of internal network trunk.
        </desc>
      </param>
    </method>

    <method name="stop">
      <desc>
        Stops DHCP server process.
        <result name="E_FAIL">
          Failed to stop the process.
        </result>
      </desc>
    </method>
  </interface>

  <interface
    name="IVirtualBox" extends="$unknown"
    uuid="3b2f08eb-b810-4715-bee0-bb06b9880ad2"
    wsmap="managed"
    >
    <desc>
      The IVirtualBox interface represents the main interface exposed by the
      product that provides virtual machine management.

      An instance of IVirtualBox is required for the product to do anything
      useful. Even though the interface does not expose this, internally,
      IVirtualBox is implemented as a singleton and actually lives in the
      process of the VirtualBox server (VBoxSVC.exe). This makes sure that
      IVirtualBox can track the state of all virtual machines on a particular
      host, regardless of which frontend started them.

      To enumerate all the virtual machines on the host, use the
      <link to="IVirtualBox::machines"/> attribute.
    </desc>

    <attribute name="version" type="wstring" readonly="yes">
      <desc>
        A string representing the version number of the product. The
        format is 3 integer numbers divided by dots (e.g. 1.0.1). The
        last number represents the build number and will frequently change.

        This may be followed by a _ALPHA[0-9]*, _BETA[0-9]* or _RC[0-9]* tag
        in prerelease builds.  Non-Oracle builds may (/shall) also have a
        publisher tag, at the end.  The publisher tag starts with an underscore
        just like the prerelease build type tag.
      </desc>
    </attribute>

    <attribute name="versionNormalized" type="wstring" readonly="yes">
      <desc>
        A string representing the version number of the product,
        without the publisher information (but still with other tags).
        See <link to="#version" />.
      </desc>
    </attribute>

    <attribute name="revision" type="unsigned long" readonly="yes">
      <desc>
        The internal build revision number of the product.
      </desc>
    </attribute>

    <attribute name="packageType" type="wstring" readonly="yes">
      <desc>
        A string representing the package type of this product. The
        format is OS_ARCH_DIST where OS is either WINDOWS, LINUX,
        SOLARIS, DARWIN. ARCH is either 32BITS or 64BITS. DIST
        is either GENERIC, UBUNTU_606, UBUNTU_710, or something like
        this.
      </desc>
    </attribute>

    <attribute name="APIVersion" type="wstring" readonly="yes">
      <desc>
        A string representing the VirtualBox API version number. The format is
        2 integer numbers divided by an underscore (e.g. 1_0). After the
        first public release of packages with a particular API version the
        API will not be changed in an incompatible way. Note that this
        guarantee does not apply to development builds, and also there is no
        guarantee that this version is identical to the first two integer
        numbers of the package version.
      </desc>
    </attribute>

    <attribute name="homeFolder" type="wstring" readonly="yes">
      <desc>
        Full path to the directory where the global settings file,
        <tt>VirtualBox.xml</tt>, is stored.

        In this version of VirtualBox, the value of this property is
        always <tt>&lt;user_dir&gt;/.VirtualBox</tt> (where
        <tt>&lt;user_dir&gt;</tt> is the path to the user directory,
        as determined by the host OS), and cannot be changed.

        This path is also used as the base to resolve relative paths in
        places where relative paths are allowed (unless otherwise
        expressly indicated).
      </desc>
    </attribute>

    <attribute name="settingsFilePath" type="wstring" readonly="yes">
      <desc>
        Full name of the global settings file.
        The value of this property corresponds to the value of
        <link to="#homeFolder"/> plus <tt>/VirtualBox.xml</tt>.
      </desc>
    </attribute>

    <attribute name="host" type="IHost" readonly="yes">
      <desc>Associated host object.</desc>
    </attribute>

    <attribute name="systemProperties" type="ISystemProperties" readonly="yes">
      <desc>Associated system information object.</desc>
    </attribute>

    <attribute name="machines" type="IMachine" readonly="yes" safearray="yes">
      <desc>
        Array of machine objects registered within this VirtualBox instance.
      </desc>
    </attribute>

    <attribute name="machineGroups" type="wstring" readonly="yes" safearray="yes">
      <desc>
        Array of all machine group names which are used by the machines which
        are accessible. Each group is only listed once, however they are listed
        in no particular order and there is no guarantee that there are no gaps
        in the group hierarchy (i.e. <tt>"/"</tt>, <tt>"/group/subgroup"</tt>
        is a valid result).
      </desc>
    </attribute>

    <attribute name="hardDisks" type="IMedium" readonly="yes" safearray="yes">
      <desc>
        Array of medium objects known to this VirtualBox installation.

        This array contains only base media. All differencing
        media of the given base medium can be enumerated using
        <link to="IMedium::children"/>.
      </desc>
    </attribute>

    <attribute name="DVDImages" type="IMedium" readonly="yes" safearray="yes">
      <desc>
        Array of CD/DVD image objects currently in use by this VirtualBox instance.
      </desc>
    </attribute>

    <attribute name="floppyImages" type="IMedium" readonly="yes" safearray="yes">
      <desc>
        Array of floppy image objects currently in use by this VirtualBox instance.
      </desc>
    </attribute>

    <attribute name="progressOperations" type="IProgress" readonly="yes" safearray="yes"/>

    <attribute name="guestOSTypes" type="IGuestOSType" readonly="yes" safearray="yes"/>

    <attribute name="sharedFolders" type="ISharedFolder" readonly="yes" safearray="yes">
      <desc>
        Collection of global shared folders. Global shared folders are
        available to all virtual machines.

        New shared folders are added to the collection using
        <link to="#createSharedFolder"/>. Existing shared folders can be
        removed using <link to="#removeSharedFolder"/>.

        <note>
          In the current version of the product, global shared folders are not
          implemented and therefore this collection is always empty.
        </note>
      </desc>
    </attribute>

    <attribute name="performanceCollector" type="IPerformanceCollector" readonly="yes">
      <desc>
        Associated performance collector object.
      </desc>
    </attribute>

    <attribute name="DHCPServers" type="IDHCPServer" safearray="yes" readonly="yes">
      <desc>
        DHCP servers.
      </desc>
    </attribute>

    <attribute name="eventSource" type="IEventSource" readonly="yes">
      <desc>
        Event source for VirtualBox events.
      </desc>
    </attribute>

    <attribute name="extensionPackManager" type="IExtPackManager" readonly="yes">
      <desc>
        The extension pack manager.
      </desc>
    </attribute>


    <attribute name="internalNetworks" type="wstring" safearray="yes" readonly="yes">
      <desc>
        Names of all internal networks.
      </desc>
    </attribute>

    <attribute name="genericNetworkDrivers" type="wstring" safearray="yes" readonly="yes">
      <desc>
        Names of all generic network drivers.
      </desc>
    </attribute>

    <method name="composeMachineFilename">
      <desc>
        Returns a recommended full path of the settings file name for a new virtual
        machine.

        This API serves two purposes:

        <ul>
          <li>It gets called by <link to="#createMachine" /> if @c null or
            empty string (which is recommended) is specified for the
            @a settingsFile argument there, which means that API should use
            a recommended default file name.</li>

          <li>It can be called manually by a client software before creating a machine,
            e.g. if that client wants to pre-create the machine directory to create
            virtual hard disks in that directory together with the new machine
            settings file. In that case, the file name should be stripped from the
            full settings file path returned by this function to obtain the
            machine directory.</li>
        </ul>

        See <link to="IMachine::name"/> and <link to="#createMachine"/> for more
        details about the machine name.

        @a groupName defines which additional subdirectory levels should be
        included. It must be either a valid group name or @c null or empty
        string which designates that the machine will not be related to a
        machine group.

        If @a baseFolder is a @c null or empty string (which is recommended), the
        default machine settings folder
        (see <link to="ISystemProperties::defaultMachineFolder" />) will be used as
        a base folder for the created machine, resulting in a file name like
        "/home/user/VirtualBox VMs/name/name.vbox". Otherwise the given base folder
        will be used.

        This method does not access the host disks. In particular, it does not check
        for whether a machine with this name already exists.
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Suggested machine name.</desc>
      </param>
      <param name="group" type="wstring" dir="in">
        <desc>Machine group name for the new machine or machine group. It is
        used to determine the right subdirectory.</desc>
      </param>
      <param name="createFlags" type="wstring" dir="in">
        <desc>Machine creation flags, see <link to="#createMachine" /> (optional).</desc>
      </param>
      <param name="baseFolder" type="wstring" dir="in">
        <desc>Base machine folder (optional).</desc>
      </param>
      <param name="file" type="wstring" dir="return">
        <desc>Fully qualified path where the machine would be created.</desc>
      </param>
    </method>

    <method name="createMachine">
      <desc>
        Creates a new virtual machine by creating a machine settings file at
        the given location.

        VirtualBox machine settings files use a custom XML dialect. Starting
        with VirtualBox 4.0, a ".vbox" extension is recommended, but not enforced,
        and machine files can be created at arbitrary locations.

        However, it is recommended that machines are created in the default
        machine folder (e.g. "/home/user/VirtualBox VMs/name/name.vbox"; see
        <link to="ISystemProperties::defaultMachineFolder" />). If you specify
        @c null or empty string (which is recommended) for the @a settingsFile
        argument, <link to="#composeMachineFilename" /> is called automatically
        to have such a recommended name composed based on the machine name
        given in the @a name argument and the primary group.

        If the resulting settings file already exists, this method will fail,
        unless the forceOverwrite flag is set.

        The new machine is created unregistered, with the initial configuration
        set according to the specified guest OS type. A typical sequence of
        actions to create a new virtual machine is as follows:

        <ol>
          <li>
            Call this method to have a new machine created. The returned machine
            object will be "mutable" allowing to change any machine property.
          </li>

          <li>
            Configure the machine using the appropriate attributes and methods.
          </li>

          <li>
            Call <link to="IMachine::saveSettings" /> to write the settings
            to the machine's XML settings file. The configuration of the newly
            created machine will not be saved to disk until this method is
            called.
          </li>

          <li>
            Call <link to="#registerMachine" /> to add the machine to the list
            of machines known to VirtualBox.
          </li>
        </ol>

        The specified guest OS type identifier must match an ID of one of known
        guest OS types listed in the <link to="IVirtualBox::guestOSTypes"/>
        array.

        <note>
          There is no way to change the name of the settings file or
          subfolder of the created machine directly.
        </note>

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          @a osTypeId is invalid.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Resulting settings file name is invalid or the settings file already
          exists or could not be created due to an I/O error.
        </result>
        <result name="E_INVALIDARG">
          @a name is empty or @c null.
        </result>
      </desc>

      <param name="settingsFile" type="wstring" dir="in">
        <desc>Fully qualified path where the settings file should be created,
          empty string or @c null for a default folder and file based on the
          @a name argument and the primary group.
        (see <link to="#composeMachineFilename" />).</desc>
      </param>
      <param name="name" type="wstring" dir="in">
        <desc>Machine name.</desc>
      </param>
      <param name="groups" type="wstring" safearray="yes" dir="in">
        <desc>Array of group names. @c null or an empty array have the same
          meaning as an array with just the empty string or <tt>"/"</tt>, i.e.
          create a machine without group association.</desc>
      </param>
      <param name="osTypeId" type="wstring" dir="in">
        <desc>Guest OS Type ID.</desc>
      </param>
      <param name="flags" type="wstring" dir="in">
        <desc>
          Additional property parameters, passed as a comma-separated list of
          "name=value" type entries. The following ones are recognized:
          <tt>forceOverwrite=1</tt> to overwrite an existing machine settings
          file, <tt>UUID=&lt;uuid&gt;</tt> to specify a machine UUID and
          <tt>directoryIncludesUUID=1</tt> to switch to a special VM directory
          naming scheme which should not be used unless necessary.
        </desc>
      </param>
      <param name="machine" type="IMachine" dir="return">
        <desc>Created machine object.</desc>
      </param>
    </method>

    <method name="openMachine">
      <desc>
        Opens a virtual machine from the existing settings file.
        The opened machine remains unregistered until you call
        <link to="#registerMachine"/>.

        The specified settings file name must be fully qualified.
        The file must exist and be a valid machine XML settings file
        whose contents will be used to construct the machine object.

        <result name="VBOX_E_FILE_ERROR">
          Settings file name invalid, not found or sharing violation.
        </result>
      </desc>
      <param name="settingsFile" type="wstring" dir="in">
        <desc>
          Name of the machine settings file.
        </desc>
      </param>
      <param name="machine" type="IMachine" dir="return">
        <desc>Opened machine object.</desc>
      </param>
      <note>
        <link to="IMachine::settingsModified"/> will return
        @c false for the created machine, until any of machine settings
        are changed.
      </note>
    </method>

    <method name="registerMachine">
      <desc>

        Registers the machine previously created using
        <link to="#createMachine"/> or opened using
        <link to="#openMachine"/> within this VirtualBox installation. After
        successful method invocation, the
        <link to="IMachineRegisteredEvent"/> event is fired.

        <note>
          This method implicitly calls <link to="IMachine::saveSettings"/>
          to save all current machine settings before registering it.
        </note>

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No matching virtual machine found.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Virtual machine was not created within this VirtualBox instance.
        </result>

      </desc>
      <param name="machine" type="IMachine" dir="in"/>
    </method>

    <method name="findMachine">
      <desc>
        Attempts to find a virtual machine given its name or UUID.

        <note>Inaccessible machines cannot be found by name, only by UUID, because their name
          cannot safely be determined.</note>

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Could not find registered machine matching @a nameOrId.
        </result>

      </desc>
      <param name="nameOrId" type="wstring" dir="in">
        <desc>What to search for. This can either be the UUID or the name of a virtual machine.</desc>
      </param>
      <param name="machine" type="IMachine" dir="return">
        <desc>Machine object, if found.</desc>
      </param>
    </method>

    <method name="getMachinesByGroups">
      <desc>
        Gets all machine references which are in one of the specified groups.
      </desc>
      <param name="groups" type="wstring" dir="in" safearray="yes">
        <desc>What groups to match. The usual group list rules apply, i.e.
        passing an empty list will match VMs in the toplevel group, likewise
        the empty string.</desc>
      </param>
      <param name="machines" type="IMachine" dir="return" safearray="yes">
        <desc>All machines which matched.</desc>
      </param>
    </method>

    <method name="getMachineStates">
      <desc>
        Gets the state of several machines in a single operation.
      </desc>
      <param name="machines" type="IMachine" dir="in" safearray="yes">
        <desc>Array with the machine references.</desc>
      </param>
      <param name="states" type="MachineState" dir="return" safearray="yes">
        <desc>Machine states, corresponding to the machines.</desc>
      </param>
    </method>

    <method name="createAppliance">
      <desc>
        Creates a new appliance object, which represents an appliance in the Open Virtual Machine
        Format (OVF). This can then be used to import an OVF appliance into VirtualBox or to export
        machines as an OVF appliance; see the documentation for <link to="IAppliance" /> for details.
      </desc>
      <param name="appliance" type="IAppliance" dir="return">
        <desc>New appliance.</desc>
      </param>
    </method>

    <method name="createHardDisk">
      <desc>
        Creates a new base medium object that will use the given storage
        format and location for medium data.

        The actual storage unit is not created by this method. In order to
        do it, and before you are able to attach the created medium to
        virtual machines, you must call one of the following methods to
        allocate a format-specific storage unit at the specified location:
        <ul>
          <li><link to="IMedium::createBaseStorage"/></li>
          <li><link to="IMedium::createDiffStorage"/></li>
        </ul>

        Some medium attributes, such as <link to="IMedium::id"/>, may
        remain uninitialized until the medium storage unit is successfully
        created by one of the above methods.

        After the storage unit is successfully created, it will be
        accessible through the <link to="#openMedium"/> method and can
        be found in the <link to="#hardDisks"/> array.

        The list of all storage formats supported by this VirtualBox
        installation can be obtained using
        <link to="ISystemProperties::mediumFormats"/>. If the @a format
        attribute is empty or @c null then the default storage format
        specified by <link to="ISystemProperties::defaultHardDiskFormat"/> will
        be used for creating a storage unit of the medium.

        Note that the format of the location string is storage format specific.
        See <link to="IMedium::location"/> and IMedium for more details.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          @a format identifier is invalid. See
          <link to="ISystemProperties::mediumFormats"/>.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          @a location is a not valid file name (for file-based formats only).
        </result>
      </desc>
      <param name="format" type="wstring" dir="in">
        <desc>
          Identifier of the storage format to use for the new medium.
        </desc>
      </param>
      <param name="location" type="wstring" dir="in">
        <desc>
          Location of the storage unit for the new medium.
        </desc>
      </param>
      <param name="medium" type="IMedium" dir="return">
        <desc>Created medium object.</desc>
      </param>
    </method>

    <method name="openMedium">
      <desc>
        Finds existing media or opens a medium from an existing storage location.

        Once a medium has been opened, it can be passed to other VirtualBox
        methods, in particular to <link to="IMachine::attachDevice" />.

        Depending on the given device type, the file at the storage location
        must be in one of the media formats understood by VirtualBox:

        <ul>
          <li>With a "HardDisk" device type, the file must be a hard disk image
            in one of the formats supported by VirtualBox (see
            <link to="ISystemProperties::mediumFormats" />).
            After this method succeeds, if the medium is a base medium, it
            will be added to the <link to="#hardDisks"/> array attribute. </li>
          <li>With a "DVD" device type, the file must be an ISO 9960 CD/DVD image.
            After this method succeeds, the medium will be added to the
            <link to="#DVDImages"/> array attribute.</li>
          <li>With a "Floppy" device type, the file must be an RAW floppy image.
            After this method succeeds, the medium will be added to the
            <link to="#floppyImages"/> array attribute.</li>
        </ul>

        After having been opened, the medium can be re-found by this method
        and can be attached to virtual machines. See <link to="IMedium" /> for
        more details.

        The UUID of the newly opened medium will either be retrieved from the
        storage location, if the format supports it (e.g. for hard disk images),
        or a new UUID will be randomly generated (e.g. for ISO and RAW files).
        If for some reason you need to change the medium's UUID, use
        <link to="IMedium::setIds" />.

        If a differencing hard disk medium is to be opened by this method, the
        operation will succeed only if its parent medium and all ancestors,
        if any, are already known to this VirtualBox installation (for example,
        were opened by this method before).

        This method attempts to guess the storage format of the specified medium
        by reading medium data at the specified location.

        If @a accessMode is ReadWrite (which it should be for hard disks and floppies),
        the image is opened for read/write access and must have according permissions,
        as VirtualBox may actually write status information into the disk's metadata
        sections.

        Note that write access is required for all typical hard disk usage in VirtualBox,
        since VirtualBox may need to write metadata such as a UUID into the image.
        The only exception is opening a source image temporarily for copying and
        cloning (see <link to="IMedium::cloneTo" /> when the image will be closed
        again soon.

        The format of the location string is storage format specific. See
        <link to="IMedium::location"/> and IMedium for more details.

        <result name="VBOX_E_FILE_ERROR">
          Invalid medium storage file location or could not find the medium
          at the specified location.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not get medium storage format.
        </result>
        <result name="E_INVALIDARG">
          Invalid medium storage format.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Medium has already been added to a media registry.
        </result>
      </desc>
      <param name="location" type="wstring" dir="in">
        <desc>
          Location of the storage unit that contains medium data in one of
          the supported storage formats.
        </desc>
      </param>
      <param name="deviceType" type="DeviceType" dir="in">
        <desc>
          Must be one of "HardDisk", "DVD" or "Floppy".
        </desc>
      </param>
      <param name="accessMode" type="AccessMode" dir="in">
        <desc>Whether to open the image in read/write or read-only mode. For
        a "DVD" device type, this is ignored and read-only mode is always assumed.</desc>
      </param>
      <param name="forceNewUuid" type="boolean" dir="in">
         <desc>Allows the caller to request a completely new medium UUID for
           the image which is to be opened. Useful if one intends to open an exact
           copy of a previously opened image, as this would normally fail due to
           the duplicate UUID.</desc>
         </param>
      <param name="medium" type="IMedium" dir="return">
        <desc>Opened medium object.</desc>
      </param>
    </method>

    <method name="getGuestOSType">
      <desc>
        Returns an object describing the specified guest OS type.

        The requested guest OS type is specified using a string which is a
        mnemonic identifier of the guest operating system, such as
        <tt>"win31"</tt> or <tt>"ubuntu"</tt>. The guest OS type ID of a
        particular virtual machine can be read or set using the
        <link to="IMachine::OSTypeId"/> attribute.

        The <link to="IVirtualBox::guestOSTypes"/> collection contains all
        available guest OS type objects. Each object has an
        <link to="IGuestOSType::id"/> attribute which contains an identifier of
        the guest OS this object describes.

        <result name="E_INVALIDARG">
          @a id is not a valid Guest OS type.
        </result>

      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>Guest OS type ID string.</desc>
      </param>
      <param name="type" type="IGuestOSType" dir="return">
        <desc>Guest OS type object.</desc>
      </param>
    </method>

    <method name="createSharedFolder">
      <desc>
        Creates a new global shared folder by associating the given logical
        name with the given host path, adds it to the collection of shared
        folders and starts sharing it. Refer to the description of
        <link to="ISharedFolder"/> to read more about logical names.
        <note>
          In the current implementation, this operation is not
          implemented.
        </note>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Unique logical name of the shared folder.</desc>
      </param>
      <param name="hostPath" type="wstring" dir="in">
        <desc>Full path to the shared folder in the host file system.</desc>
      </param>
      <param name="writable" type="boolean" dir="in">
        <desc>Whether the share is writable or readonly</desc>
      </param>
      <param name="automount" type="boolean" dir="in">
        <desc>Whether the share gets automatically mounted by the guest
          or not.</desc>
      </param>
    </method>

    <method name="removeSharedFolder">
      <desc>
        Removes the global shared folder with the given name previously
        created by <link to="#createSharedFolder"/> from the collection of
        shared folders and stops sharing it.
        <note>
          In the current implementation, this operation is not
          implemented.
        </note>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Logical name of the shared folder to remove.</desc>
      </param>
    </method>

    <method name="getExtraDataKeys">
      <desc>
        Returns an array representing the global extra data keys which currently
        have values defined.
      </desc>
      <param name="value" type="wstring" dir="return" safearray="yes">
        <desc>Array of extra data keys.</desc>
      </param>
    </method>

    <method name="getExtraData">
      <desc>
        Returns associated global extra data.

        If the requested data @a key does not exist, this function will
        succeed and return an empty string in the @a value argument.

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>

      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to get.</desc>
      </param>
      <param name="value" type="wstring" dir="return">
        <desc>Value of the requested data key.</desc>
      </param>
    </method>

    <method name="setExtraData">
      <desc>
        Sets associated global extra data.

        If you pass @c null or empty string as a key @a value, the given @a key
        will be deleted.

        <note>
          Before performing the actual data change, this method will ask all
          registered event listener using the
          <link to="IExtraDataCanChangeEvent"/>
          notification for a permission. If one of the listeners refuses the
          new value, the change will not be performed.
        </note>
        <note>
          On success, the
          <link to="IExtraDataChangedEvent"/> notification
          is called to inform all registered listeners about a successful data
          change.
        </note>

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>
        <result name="E_ACCESSDENIED">
          Modification request refused.
        </result>

      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to set.</desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>Value to assign to the key.</desc>
      </param>
    </method>

    <method name="setSettingsSecret">
      <desc>
        Unlocks the secret data by passing the unlock password to the
        server. The server will cache the password for that machine.

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable.
        </result>

      </desc>
      <param name="password" type="wstring" dir="in">
        <desc>
          The cipher key.
        </desc>
      </param>
    </method>

    <!--method name="createDHCPServerForInterface">
      <desc>
        Creates a DHCP server settings to be used for the given interface
        <result name="E_INVALIDARG">
          Host network interface @a name already exists.
        </result>
      </desc>
      <param name="interface" type="IHostNetworkInterface" dir="in">
        <desc>Network Interface</desc>
      </param>
      <param name="server" type="IDHCPServer" dir="out">
        <desc>DHCP server settings</desc>
      </param>
    </method-->

    <method name="createDHCPServer">
      <desc>
        Creates a DHCP server settings to be used for the given internal network name
        <result name="E_INVALIDARG">
          Host network interface @a name already exists.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>server name</desc>
      </param>
      <param name="server" type="IDHCPServer" dir="return">
        <desc>DHCP server settings</desc>
      </param>
    </method>

    <method name="findDHCPServerByNetworkName">
      <desc>
        Searches a DHCP server settings to be used for the given internal network name
        <result name="E_INVALIDARG">
          Host network interface @a name already exists.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>server name</desc>
      </param>
      <param name="server" type="IDHCPServer" dir="return">
        <desc>DHCP server settings</desc>
      </param>
    </method>

    <!--method name="findDHCPServerForInterface">
      <desc>
        Searches a DHCP server settings to be used for the given interface
        <result name="E_INVALIDARG">
          Host network interface @a name already exists.
        </result>
      </desc>
      <param name="interface" type="IHostNetworkInterface" dir="in">
        <desc>Network Interface</desc>
      </param>
      <param name="server" type="IDHCPServer" dir="out">
        <desc>DHCP server settings</desc>
      </param>
    </method-->

    <method name="removeDHCPServer">
      <desc>
        Removes the DHCP server settings
        <result name="E_INVALIDARG">
          Host network interface @a name already exists.
        </result>
      </desc>
      <param name="server" type="IDHCPServer" dir="in">
        <desc>DHCP server settings to be removed</desc>
      </param>
    </method>


    <method name="checkFirmwarePresent">
      <desc>
        Check if this VirtualBox installation has a firmware
        of the given type available, either system-wide or per-user.
        Optionally, this may return a hint where this firmware can be
        downloaded from.
      </desc>
      <param name="firmwareType" type="FirmwareType" dir="in">
        <desc>
          Type of firmware to check.
        </desc>
      </param>
      <param name="version" type="wstring" dir="in">
        <desc>Expected version number, usually empty string (presently ignored).</desc>
      </param>

      <param name="url" type="wstring" dir="out">
        <desc>
          Suggested URL to download this firmware from.
        </desc>
      </param>

      <param name="file" type="wstring" dir="out">
        <desc>
          Filename of firmware, only valid if result == TRUE.
        </desc>
      </param>

      <param name="result" type="boolean" dir="return">
        <desc>If firmware of this type and version is available.</desc>
      </param>
    </method>

  </interface>

  <!--
  // IVFSExplorer
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="VFSType"
    uuid="813999ba-b949-48a8-9230-aadc6285e2f2"
    >
    <desc>
      Virtual file systems supported by VFSExplorer.
    </desc>

    <const name="File" value="1" />
    <const name="Cloud" value="2" />
    <const name="S3" value="3" />
    <const name="WebDav" value="4" />
  </enum>

  <enum
    name="VFSFileType"
    uuid="714333cd-44e2-415f-a245-d378fa9b1242"
    >
    <desc>
      File types known by VFSExplorer.
    </desc>

    <const name="Unknown" value="1" />
    <const name="Fifo" value="2" />
    <const name="DevChar" value="3" />
    <const name="Directory" value="4" />
    <const name="DevBlock" value="5" />
    <const name="File" value="6" />
    <const name="SymLink" value="7" />
    <const name="Socket" value="8" />
    <const name="WhiteOut" value="9" />
  </enum>

  <interface
    name="IVFSExplorer" extends="$unknown"
    uuid="003d7f92-d38e-487f-b790-8c5e8631cb2f"
    wsmap="managed"
    >
    <desc>
      The VFSExplorer interface unifies access to different file system
      types. This includes local file systems as well remote file systems like
      S3. For a list of supported types see <link to="VFSType" />.
      An instance of this is returned by <link to="IAppliance::createVFSExplorer" />.
    </desc>

    <attribute name="path" type="wstring" readonly="yes">
      <desc>Returns the current path in the virtual file system.</desc>
    </attribute>

    <attribute name="type" type="VFSType" readonly="yes">
      <desc>Returns the file system type which is currently in use.</desc>
    </attribute>

    <method name="update">
      <desc>Updates the internal list of files/directories from the
      current directory level. Use <link to="#entryList" /> to get the full list
      after a call to this method.</desc>

      <param name="aProgress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="cd">
      <desc>Change the current directory level.</desc>

      <param name="aDir" type="wstring" dir="in">
        <desc>The name of the directory to go in.</desc>
      </param>

      <param name="aProgress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="cdUp">
      <desc>Go one directory upwards from the current directory level.</desc>

      <param name="aProgress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="entryList">
      <desc>Returns a list of files/directories after a call to <link
      to="#update" />. The user is responsible for keeping this internal
      list up do date.</desc>

      <param name="aNames" type="wstring" safearray="yes" dir="out">
        <desc>The list of names for the entries.</desc>
      </param>

      <param name="aTypes" type="unsigned long" safearray="yes" dir="out">
        <desc>The list of types for the entries.</desc>
      </param>

      <param name="aSizes" type="unsigned long" safearray="yes" dir="out">
        <desc>The list of sizes (in bytes) for the entries.</desc>
      </param>

      <param name="aModes" type="unsigned long" safearray="yes" dir="out">
        <desc>The list of file modes (in octal form) for the entries.</desc>
      </param>
    </method>

    <method name="exists">
      <desc>Checks if the given file list exists in the current directory
      level.</desc>

      <param name="aNames" type="wstring" safearray="yes" dir="in">
        <desc>The names to check.</desc>
      </param>

      <param name="aExists" type="wstring" safearray="yes" dir="return">
        <desc>The names which exist.</desc>
      </param>
    </method>

    <method name="remove">
      <desc>Deletes the given files in the current directory level.</desc>

      <param name="aNames" type="wstring" safearray="yes" dir="in">
        <desc>The names to remove.</desc>
      </param>

      <param name="aProgress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

  </interface>

  <enum
    name="ImportOptions" extends="$unknown"
    uuid="0a981523-3b20-4004-8ee3-dfd322202ace"
    >

    <desc>
    Import options, used with <link to="IAppliance::importMachines" />.
    </desc>

    <const name="KeepAllMACs"        value="1">
      <desc>Don't generate new MAC addresses of the attached network adapters.</desc>
    </const>
    <const name="KeepNATMACs"        value="2">
      <desc>Don't generate new MAC addresses of the attached network adapters when they are using NAT.</desc>
    </const>

  </enum>


  <!--
  // IAppliance
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IAppliance" extends="$unknown"
    uuid="3059cf9e-25c7-4f0b-9fa5-3c42e441670b"
    wsmap="managed"
    >
    <desc>
        Represents a platform-independent appliance in OVF format. An instance of this is returned
        by <link to="IVirtualBox::createAppliance" />, which can then be used to import and export
        virtual machines within an appliance with VirtualBox.

        The OVF standard suggests two different physical file formats:

        <ol>
            <li>If the appliance is distributed as a set of files, there must be at least one XML descriptor
                file that conforms to the OVF standard and carries an <tt>.ovf</tt> file extension. If
                this descriptor file references other files such as disk images, as OVF appliances typically
                do, those additional files must be in the same directory as the descriptor file.</li>

              <li>If the appliance is distributed as a single file, it must be in TAR format and have the
                <tt>.ova</tt> file extension. This TAR file must then contain at least the OVF descriptor
                files and optionally other files.

                At this time, VirtualBox does not not yet support the packed (TAR) variant; support will
                be added with a later version.</li>
        </ol>

        <b>Importing</b> an OVF appliance into VirtualBox as instances of
        <link to="IMachine" /> involves the following sequence of API calls:

        <ol>
          <li>Call <link to="IVirtualBox::createAppliance" />. This will create an empty IAppliance object.
          </li>

          <li>On the new object, call <link to="#read" /> with the full path of the OVF file you
              would like to import. So long as this file is syntactically valid, this will succeed
              and fill the appliance object with the parsed data from the OVF file.
          </li>

          <li>Next, call <link to="#interpret" />, which analyzes the OVF data and sets up the
              contents of the IAppliance attributes accordingly. These can be inspected by a
              VirtualBox front-end such as the GUI, and the suggestions can be displayed to the
              user. In particular, the <link to="#virtualSystemDescriptions" /> array contains
              instances of <link to="IVirtualSystemDescription" /> which represent the virtual
              systems (machines) in the OVF, which in turn describe the virtual hardware prescribed
              by the OVF (network and hardware adapters, virtual disk images, memory size and so on).
              The GUI can then give the user the option to confirm and/or change these suggestions.
          </li>

          <li>If desired, call <link to="IVirtualSystemDescription::setFinalValues" /> for each
              virtual system (machine) to override the suggestions made by the <link to="#interpret" /> routine.
          </li>

          <li>Finally, call <link to="#importMachines" /> to  create virtual machines in
              VirtualBox as instances of <link to="IMachine" /> that match the information in the
              virtual system descriptions. After this call succeeded, the UUIDs of the machines created
              can be found in the <link to="#machines" /> array attribute.
          </li>
        </ol>

        <b>Exporting</b> VirtualBox machines into an OVF appliance involves the following steps:

        <ol>
            <li>As with importing, first call <link to="IVirtualBox::createAppliance" /> to create
                an empty IAppliance object.
            </li>

            <li>For each machine you would like to export, call <link to="IMachine::export" />
                with the IAppliance object you just created. Each such call creates one instance of
                <link to="IVirtualSystemDescription" /> inside the appliance.
            </li>

            <li>If desired, call <link to="IVirtualSystemDescription::setFinalValues" /> for each
                virtual system (machine) to override the suggestions made by the <link to="IMachine::export"/> routine.
            </li>

            <li>Finally, call <link to="#write" /> with a path specification to have the OVF
                file written.</li>
        </ol>

    </desc>

    <attribute name="path" type="wstring" readonly="yes">
      <desc>Path to the main file of the OVF appliance, which is either the <tt>.ovf</tt> or
          the <tt>.ova</tt> file passed to <link to="#read" /> (for import) or
          <link to="#write" /> (for export).
          This attribute is empty until one of these methods has been called.
      </desc>
    </attribute>

    <attribute name="disks" type="wstring" readonly="yes" safearray="yes">
      <desc>
        Array of virtual disk definitions. One such description exists for each
        disk definition in the OVF; each string array item represents one such piece of
        disk information, with the information fields separated by tab (\\t) characters.

        The caller should be prepared for additional fields being appended to
        this string in future versions of VirtualBox and therefore check for
        the number of tabs in the strings returned.

        In the current version, the following eight fields are returned per string
        in the array:

        <ol>
            <li>Disk ID (unique string identifier given to disk)</li>

            <li>Capacity (unsigned integer indicating the maximum capacity of the disk)</li>

            <li>Populated size (optional unsigned integer indicating the current size of the
            disk; can be approximate; -1 if unspecified)</li>

            <li>Format (string identifying the disk format, typically
            "http://www.vmware.com/specifications/vmdk.html#sparse")</li>

            <li>Reference (where to find the disk image, typically a file name; if empty,
            then the disk should be created on import)</li>

            <li>Image size (optional unsigned integer indicating the size of the image,
            which need not necessarily be the same as the values specified above, since
            the image may be compressed or sparse; -1 if not specified)</li>

            <li>Chunk size (optional unsigned integer if the image is split into chunks;
            presently unsupported and always -1)</li>

            <li>Compression (optional string equalling "gzip" if the image is gzip-compressed)</li>
        </ol>
      </desc>
    </attribute>

    <attribute name="virtualSystemDescriptions" type="IVirtualSystemDescription" readonly="yes" safearray="yes">
      <desc> Array of virtual system descriptions. One such description is created
      for each virtual system (machine) found in the OVF.
      This array is empty until either <link to="#interpret" /> (for import) or <link to="IMachine::export" />
      (for export) has been called.
      </desc>
    </attribute>

    <attribute name="machines" type="wstring" readonly="yes" safearray="yes">
      <desc>
        Contains the UUIDs of the machines created from the information in this appliances. This is only
        relevant for the import case, and will only contain data after a call to <link to="#importMachines" />
        succeeded.
      </desc>
    </attribute>

    <method name="read">
      <desc>
        Reads an OVF file into the appliance object.

        This method succeeds if the OVF is syntactically valid and, by itself, without errors. The
        mere fact that this method returns successfully does not mean that VirtualBox supports all
        features requested by the appliance; this can only be examined after a call to <link to="#interpret" />.
      </desc>
      <param name="file" type="wstring" dir="in">
        <desc>
          Name of appliance file to open (either with an <tt>.ovf</tt> or <tt>.ova</tt> extension, depending
          on whether the appliance is distributed as a set of files or as a single file, respectively).
        </desc>
      </param>
      <param name="aProgress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="interpret">
      <desc>
        Interprets the OVF data that was read when the appliance was constructed. After
        calling this method, one can inspect the
        <link to="#virtualSystemDescriptions" /> array attribute, which will then contain
        one <link to="IVirtualSystemDescription" /> for each virtual machine found in
        the appliance.

        Calling this method is the second step of importing an appliance into VirtualBox;
        see <link to="IAppliance" /> for an overview.

        After calling this method, one should call <link to="#getWarnings" /> to find out
        if problems were encountered during the processing which might later lead to
        errors.
      </desc>
    </method>

    <method name="importMachines">
      <desc>
        Imports the appliance into VirtualBox by creating instances of <link to="IMachine" />
        and other interfaces that match the information contained in the appliance as
        closely as possible, as represented by the import instructions in the
        <link to="#virtualSystemDescriptions" /> array.

        Calling this method is the final step of importing an appliance into VirtualBox;
        see <link to="IAppliance" /> for an overview.

        Since importing the appliance will most probably involve copying and converting
        disk images, which can take a long time, this method operates asynchronously and
        returns an IProgress object to allow the caller to monitor the progress.

        After the import succeeded, the UUIDs of the IMachine instances created can be
        retrieved from the <link to="#machines" /> array attribute.
      </desc>

      <param name="options" type="ImportOptions" dir="in" safearray="yes">
        <desc>Options for the importing operation.</desc>
      </param>

      <param name="aProgress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="createVFSExplorer">
      <desc>Returns a <link to="IVFSExplorer" /> object for the given URI.</desc>

      <param name="aUri" type="wstring" dir="in">
        <desc>The URI describing the file system to use.</desc>
      </param>

      <param name="aExplorer" type="IVFSExplorer" dir="return">
        <desc></desc>
      </param>
    </method>

    <method name="write">
      <desc>
          Writes the contents of the appliance exports into a new OVF file.

          Calling this method is the final step of exporting an appliance from VirtualBox;
          see <link to="IAppliance" /> for an overview.

          Since exporting the appliance will most probably involve copying and converting
          disk images, which can take a long time, this method operates asynchronously and
          returns an IProgress object to allow the caller to monitor the progress.
      </desc>
      <param name="format" type="wstring" dir="in">
        <desc>
            Output format, as a string. Currently supported formats are "ovf-0.9", "ovf-1.0"
            and "ovf-2.0"; future versions of VirtualBox may support additional formats.
        </desc>
      </param>
      <param name="manifest" type="boolean" dir="in">
        <desc>
            Indicate if the optional manifest file (.mf) should be written. The manifest file
            is used for integrity checks prior import.
        </desc>
      </param>
      <param name="path" type="wstring" dir="in">
          <desc>
              Name of appliance file to open (either with an <tt>.ovf</tt> or <tt>.ova</tt> extension, depending
              on whether the appliance is distributed as a set of files or as a single file, respectively).
          </desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="getWarnings">
      <desc>Returns textual warnings which occurred during execution of <link to="#interpret" />.</desc>

      <param name="aWarnings" type="wstring" dir="return" safearray="yes">
        <desc></desc>
      </param>
    </method>

  </interface>

  <enum
    name="VirtualSystemDescriptionType"
    uuid="303c0900-a746-4612-8c67-79003e91f459"
    >
    <desc>Used with <link to="IVirtualSystemDescription" /> to describe the type of
    a configuration value.</desc>

    <const name="Ignore" value="1" />
    <const name="OS" value="2" />
    <const name="Name" value="3" />
    <const name="Product" value="4" />
    <const name="Vendor" value="5" />
    <const name="Version" value="6" />
    <const name="ProductUrl" value="7" />
    <const name="VendorUrl" value="8" />
    <const name="Description" value="9" />
    <const name="License" value="10" />
    <const name="Miscellaneous" value="11" />
    <const name="CPU" value="12" />
    <const name="Memory" value="13" />
    <const name="HardDiskControllerIDE" value="14" />
    <const name="HardDiskControllerSATA" value="15" />
    <const name="HardDiskControllerSCSI" value="16" />
    <const name="HardDiskControllerSAS" value="17" />
    <const name="HardDiskImage" value="18" />
    <const name="Floppy" value="19" />
    <const name="CDROM" value="20" />
    <const name="NetworkAdapter" value="21" />
    <const name="USBController" value="22" />
    <const name="SoundCard" value="23" />
    <const name="SettingsFile" value="24">
      <desc>Not used/implemented right now, will be added later in 4.1.x.</desc>
    </const>
  </enum>

  <enum
    name="VirtualSystemDescriptionValueType"
    uuid="56d9403f-3425-4118-9919-36f2a9b8c77c"
    >
    <desc>Used with <link to="IVirtualSystemDescription::getValuesByType" /> to describe the value
    type to fetch.</desc>

    <const name="Reference" value="1" />
    <const name="Original" value="2" />
    <const name="Auto" value="3" />
    <const name="ExtraConfig" value="4" />

  </enum>

  <interface
    name="IVirtualSystemDescription" extends="$unknown"
    uuid="d7525e6c-531a-4c51-8e04-41235083a3d8"
    wsmap="managed"
    >

    <desc>Represents one virtual system (machine) in an appliance. This interface is used in
      the <link to="IAppliance::virtualSystemDescriptions" /> array. After
      <link to="IAppliance::interpret" /> has been called, that array contains information
      about how the virtual systems described in the OVF should best be imported into
      VirtualBox virtual machines. See <link to="IAppliance" /> for the steps required to
      import an OVF into VirtualBox.
    </desc>

    <attribute name="count" type="unsigned long" readonly="yes">
      <desc>Return the number of virtual system description entries.</desc>
    </attribute>

    <method name="getDescription">
      <desc>Returns information about the virtual system as arrays of instruction items. In each array, the
      items with the same indices correspond and jointly represent an import instruction for VirtualBox.

      The list below identifies the value sets that are possible depending on the
      <link to="VirtualSystemDescriptionType" /> enum value in the array item in @a aTypes[]. In each case,
      the array item with the same index in @a aOvfValues[] will contain the original value as contained
      in the OVF file (just for informational purposes), and the corresponding item in @a aVBoxValues[]
      will contain a suggested value to be used for VirtualBox. Depending on the description type,
      the @a aExtraConfigValues[] array item may also be used.

      <ul>
      <li>
        "OS": the guest operating system type. There must be exactly one such array item on import. The
        corresponding item in @a  aVBoxValues[] contains the suggested guest operating system for VirtualBox.
        This will be one of the values listed in <link to="IVirtualBox::guestOSTypes" />. The corresponding
        item in @a aOvfValues[] will contain a numerical value that described the operating system in the OVF.
      </li>
      <li>
        "Name": the name to give to the new virtual machine. There can be at most one such array item;
        if none is present on import, then an automatic name will be created from the operating system
        type. The corresponding item im @a aOvfValues[] will contain the suggested virtual machine name
        from the OVF file, and @a aVBoxValues[] will contain a suggestion for a unique VirtualBox
        <link to="IMachine" /> name that does not exist yet.
      </li>
      <li>
          "Description": an arbitrary description.
      </li>
      <li>
          "License": the EULA section from the OVF, if present. It is the responsibility of the calling
          code to display such a license for agreement; the Main API does not enforce any such policy.
      </li>
      <li>
          Miscellaneous: reserved for future use.
      </li>
      <li>
        "CPU": the number of CPUs. There can be at most one such item, which will presently be ignored.
      </li>
      <li>
        "Memory": the amount of guest RAM, in bytes. There can be at most one such array item; if none
        is present on import, then VirtualBox will set a meaningful default based on the operating system
        type.
      </li>
      <li>
        "HardDiskControllerIDE": an IDE hard disk controller. There can be at most two such items.
        An optional value in @a aOvfValues[] and @a aVBoxValues[] can be "PIIX3" or "PIIX4" to specify
        the type of IDE controller; this corresponds to the ResourceSubType element which VirtualBox
        writes into the OVF.
        The matching item in the @a aRefs[] array will contain an integer that items of the "Harddisk"
        type can use to specify which hard disk controller a virtual disk should be connected to.
        Note that in OVF, an IDE controller has two channels, corresponding to "master" and "slave"
        in traditional terminology, whereas the IDE storage controller that VirtualBox supports in
        its virtual machines supports four channels (primary master, primary slave, secondary master,
        secondary slave) and thus maps to two IDE controllers in the OVF sense.
      </li>
      <li>
        "HardDiskControllerSATA": an SATA hard disk controller. There can be at most one such item. This
        has no value in @a aOvfValues[] or @a aVBoxValues[].
        The matching item in the @a aRefs[] array will be used as with IDE controllers (see above).
      </li>
      <li>
        "HardDiskControllerSCSI": a SCSI hard disk controller. There can be at most one such item.
        The items in @a aOvfValues[] and @a aVBoxValues[] will either be "LsiLogic", "BusLogic" or
        "LsiLogicSas". (Note that in OVF, the LsiLogicSas controller is treated as a SCSI controller
        whereas VirtualBox considers it a class of storage controllers of its own; see
        <link to="StorageControllerType" />).
        The matching item in the @a aRefs[] array will be used as with IDE controllers (see above).
      </li>
      <li>
        "HardDiskImage": a virtual hard disk, most probably as a reference to an image file. There can be an
        arbitrary number of these items, one for each virtual disk image that accompanies the OVF.

        The array item in @a aOvfValues[] will contain the file specification from the OVF file (without
        a path since the image file should be in the same location as the OVF file itself), whereas the
        item in @a aVBoxValues[] will contain a qualified path specification to where VirtualBox uses the
        hard disk image. This means that on import the image will be copied and converted from the
        "ovf" location to the "vbox" location; on export, this will be handled the other way round.

        The matching item in the @a aExtraConfigValues[] array must contain a string of the following
        format: "controller=&lt;index&gt;;channel=&lt;c&gt;"
        In this string, &lt;index&gt; must be an integer specifying the hard disk controller to connect
        the image to. That number must be the index of an array item with one of the hard disk controller
        types (HardDiskControllerSCSI, HardDiskControllerSATA, HardDiskControllerIDE).
        In addition, &lt;c&gt; must specify the channel to use on that controller. For IDE controllers,
        this can be 0 or 1 for master or slave, respectively. For compatibility with VirtualBox versions
        before 3.2, the values 2 and 3 (for secondary master and secondary slave) are also supported, but
        no longer exported. For SATA and SCSI controllers, the channel can range from 0-29.
      </li>
      <li>
        "CDROM": a virtual CD-ROM drive. The matching item in @a aExtraConfigValue[] contains the same
        attachment information as with "HardDiskImage" items.
      </li>
      <li>
        "CDROM": a virtual floppy drive. The matching item in @a aExtraConfigValue[] contains the same
        attachment information as with "HardDiskImage" items.
      </li>
      <li>
        "NetworkAdapter": a network adapter. The array item in @a aVBoxValues[] will specify the hardware
        for the network adapter, whereas the array item in @a aExtraConfigValues[] will have a string
        of the "type=&lt;X&gt;" format, where &lt;X&gt; must be either "NAT" or "Bridged".
      </li>
      <li>
          "USBController": a USB controller. There can be at most one such item. If and only if such an
          item ispresent, USB support will be enabled for the new virtual machine.
      </li>
      <li>
          "SoundCard": a sound card. There can be at most one such item. If and only if such an item is
          present, sound support will be enabled for the new virtual machine. Note that the virtual
          machine in VirtualBox will always be presented with the standard VirtualBox soundcard, which
          may be different from the virtual soundcard expected by the appliance.
      </li>
      </ul>

      </desc>

      <param name="aTypes" type="VirtualSystemDescriptionType" dir="out" safearray="yes">
        <desc></desc>
      </param>

      <param name="aRefs" type="wstring" dir="out" safearray="yes">
        <desc></desc>
      </param>

      <param name="aOvfValues" type="wstring" dir="out" safearray="yes">
        <desc></desc>
      </param>

      <param name="aVBoxValues" type="wstring" dir="out" safearray="yes">
        <desc></desc>
      </param>

      <param name="aExtraConfigValues" type="wstring" dir="out" safearray="yes">
        <desc></desc>
      </param>

    </method>

    <method name="getDescriptionByType">
      <desc>This is the same as <link to="#getDescription" /> except that you can specify which types
      should be returned.</desc>

      <param name="aType" type="VirtualSystemDescriptionType" dir="in">
        <desc></desc>
      </param>

      <param name="aTypes" type="VirtualSystemDescriptionType" dir="out" safearray="yes">
        <desc></desc>
      </param>

      <param name="aRefs" type="wstring" dir="out" safearray="yes">
        <desc></desc>
      </param>

      <param name="aOvfValues" type="wstring" dir="out" safearray="yes">
        <desc></desc>
      </param>

      <param name="aVBoxValues" type="wstring" dir="out" safearray="yes">
        <desc></desc>
      </param>

      <param name="aExtraConfigValues" type="wstring" dir="out" safearray="yes">
        <desc></desc>
      </param>

    </method>

    <method name="getValuesByType">
      <desc>This is the same as <link to="#getDescriptionByType" /> except that you can specify which
      value types should be returned. See <link to="VirtualSystemDescriptionValueType" /> for possible
      values.</desc>

      <param name="aType" type="VirtualSystemDescriptionType" dir="in">
        <desc></desc>
      </param>

      <param name="aWhich" type="VirtualSystemDescriptionValueType" dir="in">
        <desc></desc>
      </param>

      <param name="aValues" type="wstring" dir="return" safearray="yes">
        <desc></desc>
      </param>

    </method>

    <method name="setFinalValues">
      <desc>
        This method allows the appliance's user to change the configuration for the virtual
        system descriptions. For each array item returned from <link to="#getDescription" />,
        you must pass in one boolean value and one configuration value.

        Each item in the boolean array determines whether the particular configuration item
        should be enabled.
        You can only disable items of the types HardDiskControllerIDE, HardDiskControllerSATA,
        HardDiskControllerSCSI, HardDiskImage, CDROM, Floppy, NetworkAdapter, USBController
        and SoundCard.

        For the "vbox" and "extra configuration" values, if you pass in the same arrays
        as returned in the aVBoxValues and aExtraConfigValues arrays from <link to="#getDescription"/>,
        the configuration remains unchanged. Please see the documentation for <link to="#getDescription"/>
        for valid configuration values for the individual array item types. If the
        corresponding item in the aEnabled array is @c false, the configuration value is ignored.
      </desc>

      <param name="aEnabled" type="boolean" dir="in" safearray="yes">
        <desc></desc>
      </param>

      <param name="aVBoxValues" type="wstring" dir="in" safearray="yes">
        <desc></desc>
      </param>

      <param name="aExtraConfigValues" type="wstring" dir="in" safearray="yes">
        <desc></desc>
      </param>
    </method>

    <method name="addDescription">
      <desc>
      This method adds an additional description entry to the stack of already
      available descriptions for this virtual system. This is handy for writing
      values which aren't directly supported by VirtualBox. One example would
      be the License type of <link to="VirtualSystemDescriptionType" />.
      </desc>

      <param name="aType" type="VirtualSystemDescriptionType" dir="in">
        <desc></desc>
      </param>

      <param name="aVBoxValue" type="wstring" dir="in">
        <desc></desc>
      </param>

      <param name="aExtraConfigValue" type="wstring" dir="in">
        <desc></desc>
      </param>
    </method>
  </interface>


  <!--
  // IMachine
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IInternalMachineControl" extends="$unknown"
    uuid="ec824977-e43f-479c-81c9-ac6cae1423a5"
    internal="yes"
    wsmap="suppress"
    >
    <method name="setRemoveSavedStateFile">
      <desc>
        Updates the flag whether the saved state file is removed on a
        machine state change from Saved to PoweredOff.
      </desc>
      <param name="aRemove" type="boolean" dir="in"/>
    </method>

    <method name="updateState">
      <desc>
        Updates the VM state.
        <note>
          This operation will also update the settings file with the correct
          information about the saved state file and delete this file from disk
          when appropriate.
        </note>
      </desc>
      <param name="state" type="MachineState" dir="in"/>
    </method>

    <method name="getIPCId">
      <param name="id" type="wstring" dir="return"/>
    </method>

    <method name="beginPowerUp">
      <desc>
        Tells VBoxSVC that <link to="IConsole::powerUp"/> is under ways and
        gives it the progress object that should be part of any pending
        <link to="IMachine::launchVMProcess"/> operations.  The progress
        object may be called back to reflect an early cancelation, so some care
        have to be taken with respect to any cancelation callbacks. The console
        object will call <link to="IInternalMachineControl::endPowerUp"/>
        to signal the completion of the progress object.
      </desc>
      <param name="aProgress" type="IProgress" dir="in" />
    </method>

    <method name="endPowerUp">
      <desc>
        Tells VBoxSVC that <link to="IConsole::powerUp"/> has completed.
        This method may query status information from the progress object it
        received in <link to="IInternalMachineControl::beginPowerUp"/> and copy
        it over to any in-progress <link to="IMachine::launchVMProcess"/>
        call in order to complete that progress object.
      </desc>
      <param name="result" type="long" dir="in"/>
    </method>

    <method name="beginPoweringDown">
      <desc>
        Called by the VM process to inform the server it wants to
        stop the VM execution and power down.
      </desc>
      <param name="progress" type="IProgress" dir="out">
        <desc>
          Progress object created by VBoxSVC to wait until
          the VM is powered down.
        </desc>
      </param>
    </method>

    <method name="endPoweringDown">
      <desc>
        Called by the VM process to inform the server that powering
        down previously requested by #beginPoweringDown is either
        successfully finished or there was a failure.

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>

      </desc>

      <param name="result" type="long" dir="in">
        <desc>@c S_OK to indicate success.
        </desc>
      </param>
      <param name="errMsg" type="wstring" dir="in">
        <desc>@c human readable error message in case of failure.
        </desc>
      </param>
    </method>

    <method name="runUSBDeviceFilters">
      <desc>
        Asks the server to run USB devices filters of the associated
        machine against the given USB device and tell if there is
        a match.
        <note>
          Intended to be used only for remote USB devices. Local
          ones don't require to call this method (this is done
          implicitly by the Host and USBProxyService).
        </note>
      </desc>
      <param name="device" type="IUSBDevice" dir="in"/>
      <param name="matched" type="boolean" dir="out"/>
      <param name="maskedInterfaces" type="unsigned long" dir="out"/>
    </method>

    <method name="captureUSBDevice">
      <desc>
        Requests a capture of the given host USB device.
        When the request is completed, the VM process will
        get a <link to="IInternalSessionControl::onUSBDeviceAttach"/>
        notification.
      </desc>
      <param name="id" type="uuid" mod="string" dir="in"/>
    </method>

    <method name="detachUSBDevice">
      <desc>
        Notification that a VM is going to detach (@a done = @c false) or has
        already detached (@a done = @c true) the given USB device.
        When the @a done = @c true request is completed, the VM process will
        get a <link to="IInternalSessionControl::onUSBDeviceDetach"/>
        notification.
        <note>
          In the @a done = @c true case, the server must run its own filters
          and filters of all VMs but this one on the detached device
          as if it were just attached to the host computer.
        </note>
      </desc>
      <param name="id" type="uuid" mod="string" dir="in"/>
      <param name="done" type="boolean" dir="in"/>
    </method>

    <method name="autoCaptureUSBDevices">
      <desc>
        Requests a capture all matching USB devices attached to the host.
        When the request is completed, the VM process will
        get a <link to="IInternalSessionControl::onUSBDeviceAttach"/>
        notification per every captured device.
      </desc>
    </method>

    <method name="detachAllUSBDevices">
      <desc>
        Notification that a VM that is being powered down. The done
        parameter indicates whether which stage of the power down
        we're at. When @a done = @c false the VM is announcing its
        intentions, while when @a done = @c true the VM is reporting
        what it has done.
        <note>
          In the @a done = @c true case, the server must run its own filters
          and filters of all VMs but this one on all detach devices as
          if they were just attached to the host computer.
        </note>
      </desc>
      <param name="done" type="boolean" dir="in"/>
    </method>

    <method name="onSessionEnd">
      <desc>
        Triggered by the given session object when the session is about
        to close normally.
      </desc>
      <param name="session" type="ISession" dir="in">
        <desc>Session that is being closed</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>
          Used to wait until the corresponding machine is actually
          dissociated from the given session on the server.
          Returned only when this session is a direct one.
        </desc>
      </param>
    </method>

    <method name="beginSavingState">
      <desc>
        Called by the VM process to inform the server it wants to
        save the current state and stop the VM execution.
      </desc>
      <param name="progress" type="IProgress" dir="out">
        <desc>
          Progress object created by VBoxSVC to wait until
          the state is saved.
        </desc>
      </param>
      <param name="stateFilePath" type="wstring" dir="out">
        <desc>
          File path the VM process must save the execution state to.
        </desc>
      </param>
    </method>

    <method name="endSavingState">
      <desc>
        Called by the VM process to inform the server that saving
        the state previously requested by #beginSavingState is either
        successfully finished or there was a failure.

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>

      </desc>

      <param name="result" type="long" dir="in">
        <desc>@c S_OK to indicate success.
        </desc>
      </param>
      <param name="errMsg" type="wstring" dir="in">
        <desc>@c human readable error message in case of failure.
        </desc>
      </param>
    </method>

    <method name="adoptSavedState">
      <desc>
        Gets called by <link to="IConsole::adoptSavedState"/>.
        <result name="VBOX_E_FILE_ERROR">
          Invalid saved state file path.
        </result>
      </desc>
      <param name="savedStateFile" type="wstring" dir="in">
        <desc>Path to the saved state file to adopt.</desc>
      </param>
    </method>

    <method name="beginTakingSnapshot">
      <desc>
        Called from the VM process to request from the server to perform the
        server-side actions of creating a snapshot (creating differencing images
        and the snapshot object).

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>
      </desc>
      <param name="initiator" type="IConsole" dir="in">
        <desc>The console object that initiated this call.</desc>
      </param>
      <param name="name" type="wstring" dir="in">
        <desc>Snapshot name.</desc>
      </param>
      <param name="description" type="wstring" dir="in">
        <desc>Snapshot description.</desc>
      </param>
      <param name="consoleProgress" type="IProgress" dir="in">
        <desc>
          Progress object created by the VM process tracking the
          snapshot's progress. This has the following sub-operations:
          <ul>
            <li>setting up (weight 1);</li>
            <li>one for each medium attachment that needs a differencing image (weight 1 each);</li>
            <li>another one to copy the VM state (if offline with saved state, weight is VM memory size in MB);</li>
            <li>another one to save the VM state (if online, weight is VM memory size in MB);</li>
            <li>finishing up (weight 1)</li>
          </ul>
        </desc>
      </param>
      <param name="fTakingSnapshotOnline" type="boolean" dir="in">
        <desc>
          Whether this is an online snapshot (i.e. the machine is running).
        </desc>
      </param>
      <param name="stateFilePath" type="wstring" dir="out">
        <desc>
          File path the VM process must save the execution state to.
        </desc>
      </param>
    </method>

    <method name="endTakingSnapshot">
      <desc>
        Called by the VM process to inform the server that the snapshot
        previously requested by #beginTakingSnapshot is either
        successfully taken or there was a failure.
      </desc>

      <param name="success" type="boolean" dir="in">
        <desc>@c true to indicate success and @c false otherwise</desc>
      </param>
    </method>

    <method name="deleteSnapshot">
      <desc>
        Gets called by <link to="IConsole::deleteSnapshot"/>,
        <link to="IConsole::deleteSnapshotAndAllChildren"/> and
        <link to="IConsole::deleteSnapshotRange"/>.
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Snapshot has more than one child snapshot. Only possible if the
          delete operation does not delete all children or the range does
          not meet the linearity condition.
        </result>
      </desc>
      <param name="initiator" type="IConsole" dir="in">
        <desc>The console object that initiated this call.</desc>
      </param>
      <param name="startId" type="uuid" mod="string" dir="in">
        <desc>UUID of the first snapshot to delete.</desc>
      </param>
      <param name="endId" type="uuid" mod="string" dir="in">
        <desc>UUID of the last snapshot to delete.</desc>
      </param>
      <param name="deleteAllChildren" type="boolean" dir="in">
        <desc>Whether all children should be deleted.</desc>
      </param>
      <param name="machineState" type="MachineState" dir="out">
        <desc>New machine state after this operation is started.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="finishOnlineMergeMedium">
      <desc>
        Gets called by <link to="IInternalSessionControl::onlineMergeMedium"/>.
      </desc>
      <param name="mediumAttachment" type="IMediumAttachment" dir="in">
        <desc>The medium attachment which needs to be cleaned up.</desc>
      </param>
      <param name="source" type="IMedium" dir="in">
        <desc>Merge source medium.</desc>
      </param>
      <param name="target" type="IMedium" dir="in">
        <desc>Merge target medium.</desc>
      </param>
      <param name="mergeForward" type="boolean" dir="in">
        <desc>Merge direction.</desc>
      </param>
      <param name="parentForTarget" type="IMedium" dir="in">
        <desc>For forward merges: new parent for target medium.</desc>
      </param>
      <param name="childrenToReparent" type="IMedium" safearray="yes" dir="in">
        <desc>For backward merges: list of media which need their parent UUID
        updated.</desc>
      </param>
    </method>

    <method name="restoreSnapshot">
      <desc>
        Gets called by <link to="IConsole::restoreSnapshot"/>.
      </desc>
      <param name="initiator" type="IConsole" dir="in">
        <desc>The console object that initiated this call.</desc>
      </param>
      <param name="snapshot" type="ISnapshot" dir="in">
        <desc>The snapshot to restore the VM state from.</desc>
      </param>
      <param name="machineState" type="MachineState" dir="out">
        <desc>New machine state after this operation is started.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="pullGuestProperties">
      <desc>
        Get the list of the guest properties matching a set of patterns along
        with their values, time stamps and flags and give responsibility for
        managing properties to the console.
      </desc>
      <param name="name" type="wstring" dir="out" safearray="yes">
        <desc>
          The names of the properties returned.
        </desc>
      </param>
      <param name="value" type="wstring" dir="out" safearray="yes">
        <desc>
          The values of the properties returned.  The array entries match the
          corresponding entries in the @a name array.
        </desc>
      </param>
      <param name="timestamp" type="long long" dir="out" safearray="yes">
        <desc>
          The time stamps of the properties returned.  The array entries match
          the corresponding entries in the @a name array.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="out" safearray="yes">
        <desc>
          The flags of the properties returned.  The array entries match the
          corresponding entries in the @a name array.
        </desc>
      </param>
    </method>

    <method name="pushGuestProperty">
      <desc>
        Update a single guest property in IMachine.
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          The name of the property to be updated.
        </desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>
          The value of the property.
        </desc>
      </param>
      <param name="timestamp" type="long long" dir="in">
        <desc>
          The timestamp of the property.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="in">
        <desc>
          The flags of the property.
        </desc>
      </param>
    </method>

    <method name="lockMedia">
      <desc>
        Locks all media attached to the machine for writing and parents of
        attached differencing media (if any) for reading. This operation is
        atomic so that if it fails no media is actually locked.

        This method is intended to be called when the machine is in Starting or
        Restoring state. The locked media will be automatically unlocked when
        the machine is powered off or crashed.
      </desc>
    </method>
    <method name="unlockMedia">
      <desc>
        Unlocks all media previously locked using
        <link to="IInternalMachineControl::lockMedia"/>.

        This method is intended to be used with teleportation so that it is
        possible to teleport between processes on the same machine.
      </desc>
    </method>

    <method name="ejectMedium">
      <desc>
        Tells VBoxSVC that the guest has ejected the medium associated with
        the medium attachment.
      </desc>
      <param name="attachment" type="IMediumAttachment" dir="in">
        <desc>
          The medium attachment where the eject happened.
        </desc>
      </param>
      <param name="newAttachment" type="IMediumAttachment" dir="return">
        <desc>
          A new reference to the medium attachment, as the config change can
          result in the creation of a new instance.
        </desc>
      </param>
    </method>

    <method name="reportGuestStatistics">
      <desc>
        Passes collected guest statistics to VBoxSVC.
      </desc>
      <param name="validStats" type="unsigned long" dir="in">
        <desc>
          Mask defining which parameters are valid. For example: 0x11 means
          that cpuIdle and XXX are valid. Other parameters should be ignored.
        </desc>
      </param>
      <param name="cpuUser" type="unsigned long" dir="in">
        <desc>Percentage of processor time spent in user mode as seen by the guest.</desc>
      </param>
      <param name="cpuKernel" type="unsigned long" dir="in">
        <desc>Percentage of processor time spent in kernel mode as seen by the guest.</desc>
      </param>
      <param name="cpuIdle" type="unsigned long" dir="in">
        <desc>Percentage of processor time spent idling as seen by the guest.</desc>
      </param>
      <param name="memTotal" type="unsigned long" dir="in">
        <desc>Total amount of physical guest RAM.</desc>
      </param>
      <param name="memFree" type="unsigned long" dir="in">
        <desc>Free amount of physical guest RAM.</desc>
      </param>
      <param name="memBalloon" type="unsigned long" dir="in">
        <desc>Amount of ballooned physical guest RAM.</desc>
      </param>
      <param name="memShared" type="unsigned long" dir="in">
        <desc>Amount of shared physical guest RAM.</desc>
      </param>
      <param name="memCache" type="unsigned long" dir="in">
        <desc>Total amount of guest (disk) cache memory.</desc>
      </param>
      <param name="pagedTotal" type="unsigned long" dir="in">
        <desc>Total amount of space in the page file.</desc>
      </param>
      <param name="memAllocTotal" type="unsigned long" dir="in">
        <desc>Total amount of memory allocated by the hypervisor.</desc>
      </param>
      <param name="memFreeTotal" type="unsigned long" dir="in">
        <desc>Total amount of free memory available in the hypervisor.</desc>
      </param>
      <param name="memBalloonTotal" type="unsigned long" dir="in">
        <desc>Total amount of memory ballooned by the hypervisor.</desc>
      </param>
      <param name="memSharedTotal" type="unsigned long" dir="in">
        <desc>Total amount of shared memory in the hypervisor.</desc>
      </param>
    </method>
  </interface>

  <interface
    name="IBIOSSettings" extends="$unknown"
    uuid="38b54279-dc35-4f5e-a431-835b867c6b5e"
    wsmap="managed"
    >
    <desc>
        The IBIOSSettings interface represents BIOS settings of the virtual
        machine. This is used only in the <link to="IMachine::BIOSSettings" /> attribute.
    </desc>
    <attribute name="logoFadeIn" type="boolean">
      <desc>Fade in flag for BIOS logo animation.</desc>
    </attribute>

    <attribute name="logoFadeOut" type="boolean">
      <desc>Fade out flag for BIOS logo animation.</desc>
    </attribute>

    <attribute name="logoDisplayTime" type="unsigned long">
      <desc>BIOS logo display time in milliseconds (0 = default).</desc>
    </attribute>

    <attribute name="logoImagePath" type="wstring">
      <desc>
        Local file system path for external BIOS splash image. Empty string
        means the default image is shown on boot.
      </desc>
    </attribute>

    <attribute name="bootMenuMode" type="BIOSBootMenuMode">
      <desc>Mode of the BIOS boot device menu.</desc>
    </attribute>

    <attribute name="ACPIEnabled" type="boolean">
      <desc>ACPI support flag.</desc>
    </attribute>

    <attribute name="IOAPICEnabled" type="boolean">
      <desc>
        IO APIC support flag. If set, VirtualBox will provide an IO APIC
        and support IRQs above 15.
      </desc>
    </attribute>

    <attribute name="timeOffset" type="long long">
      <desc>
        Offset in milliseconds from the host system time. This allows for
        guests running with a different system date/time than the host.
        It is equivalent to setting the system date/time in the BIOS except
        it is not an absolute value but a relative one. Guest Additions
        time synchronization honors this offset.
      </desc>
    </attribute>

    <attribute name="PXEDebugEnabled" type="boolean">
      <desc>
        PXE debug logging flag. If set, VirtualBox will write extensive
        PXE trace information to the release log.
      </desc>
    </attribute>
  </interface>

  <enum
    name="CleanupMode"
    uuid="67897c50-7cca-47a9-83f6-ce8fd8eb5441"
    >
    <desc>Cleanup mode, used with <link to="IMachine::unregister" />.
    </desc>
    <const name="UnregisterOnly"                  value="1">
      <desc>Unregister only the machine, but neither delete snapshots nor detach media.</desc>
    </const>
    <const name="DetachAllReturnNone"             value="2">
      <desc>Delete all snapshots and detach all media but return none; this will keep all media registered.</desc>
    </const>
    <const name="DetachAllReturnHardDisksOnly"    value="3">
      <desc>Delete all snapshots, detach all media and return hard disks for closing, but not removable media.</desc>
    </const>
    <const name="Full"                            value="4">
      <desc>Delete all snapshots, detach all media and return all media for closing.</desc>
    </const>
  </enum>

  <interface
    name="IPCIAddress" extends="$unknown"
    uuid="D88B324F-DB19-4D3B-A1A9-BF5B127199A8"
    wsmap="struct"
    >

    <desc>
      Address on the PCI bus.
    </desc>

    <attribute name="bus" type="short">
      <desc>
        Bus number.
      </desc>
    </attribute>

    <attribute name="device" type="short">
      <desc>
        Device number.
      </desc>
    </attribute>

    <attribute name="devFunction" type="short">
      <desc>
        Device function number.
      </desc>
    </attribute>

    <method name="asLong">
      <desc>
        Convert PCI address into long.
      </desc>
      <param name="result" type="long" dir="return" />
    </method>

    <method name="fromLong">
      <desc>
        Make PCI address from long.
      </desc>
      <param name="number" type="long" dir="in" />
    </method>
  </interface>

  <interface
    name="IPCIDeviceAttachment" extends="$unknown"
    uuid="91f33d6f-e621-4f70-a77e-15f0e3c714d5"
    wsmap="struct"
    >

    <desc>
      Information about PCI attachments.
    </desc>

    <attribute name="name" type="wstring" readonly="yes">
      <desc>
        Device name.
      </desc>
    </attribute>

    <attribute name="isPhysicalDevice" type="boolean" readonly="yes">
      <desc>
        If this is physical or virtual device.
      </desc>
    </attribute>

    <attribute name="hostAddress" type="long" readonly="yes">
      <desc>
        Address of device on the host, applicable only to host devices.
      </desc>
    </attribute>

    <attribute name="guestAddress" type="long" readonly="yes">
      <desc>
        Address of device on the guest.
      </desc>
    </attribute>

  </interface>

  <enum
    name="CloneMode" extends="$unknown"
    uuid="A7A159FE-5096-4B8D-8C3C-D033CB0B35A8"
    >

    <desc>
    Clone mode, used with <link to="IMachine::cloneTo" />.
    </desc>

    <const name="MachineState"                 value="1">
      <desc>Clone the state of the selected machine.</desc>
    </const>
    <const name="MachineAndChildStates"        value="2">
      <desc>Clone the state of the selected machine and its child snapshots if present.</desc>
    </const>
    <const name="AllStates"                    value="3">
      <desc>Clone all states (including all snapshots) of the machine, regardless of the machine object used.</desc>
    </const>

  </enum>

  <enum
    name="CloneOptions" extends="$unknown"
    uuid="22243f8e-96ab-497c-8cf0-f40a566c630b"
    >

    <desc>
    Clone options, used with <link to="IMachine::cloneTo" />.
    </desc>

    <const name="Link"               value="1">
      <desc>Create a clone VM where all virtual disks are linked to the original VM.</desc>
    </const>
    <const name="KeepAllMACs"        value="2">
      <desc>Don't generate new MAC addresses of the attached network adapters.</desc>
    </const>
    <const name="KeepNATMACs"        value="3">
      <desc>Don't generate new MAC addresses of the attached network adapters when they are using NAT.</desc>
    </const>
    <const name="KeepDiskNames"      value="4">
      <desc>Don't change the disk names.</desc>
    </const>

  </enum>

  <enum
    name="AutostopType" extends="$unknown"
    uuid="6bb96740-cf34-470d-aab2-2cd48ea2e10e"
    >

    <desc>
    Autostop types, used with <link to="IMachine::autostopType" />.
    </desc>

    <const name="Disabled"           value="1">
      <desc>Stopping the VM during system shutdown is disabled.</desc>
    </const>
    <const name="SaveState"          value="2">
      <desc>The state of the VM will be saved when the system shuts down.</desc>
    </const>
    <const name="PowerOff"           value="3">
      <desc>The VM is powered off when the system shuts down.</desc>
    </const>
    <const name="AcpiShutdown"       value="4">
      <desc>An ACPI shutdown event is generated.</desc>
    </const>

  </enum>


  <interface
    name="IMachine" extends="$unknown"
    uuid="22781af3-1c96-4126-9edf-67a020e0e858"
    wsmap="managed"
    >
    <desc>
      The IMachine interface represents a virtual machine, or guest, created
      in VirtualBox.

      This interface is used in two contexts. First of all, a collection of
      objects implementing this interface is stored in the
      <link to="IVirtualBox::machines"/> attribute which lists all the virtual
      machines that are currently registered with this VirtualBox
      installation. Also, once a session has been opened for the given virtual
      machine (e.g. the virtual machine is running), the machine object
      associated with the open session can be queried from the session object;
      see <link to="ISession"/> for details.

      The main role of this interface is to expose the settings of the virtual
      machine and provide methods to change various aspects of the virtual
      machine's configuration. For machine objects stored in the
      <link to="IVirtualBox::machines"/> collection, all attributes are
      read-only unless explicitly stated otherwise in individual attribute
      and method descriptions.

      In order to change a machine setting, a session for this machine must be
      opened using one of the <link to="IMachine::lockMachine" /> or
      <link to="IMachine::launchVMProcess"/> methods. After the
      machine has been successfully locked for a session, a mutable machine object
      needs to be queried from the session object and then the desired settings
      changes can be applied to the returned object using IMachine attributes and
      methods. See the <link to="ISession"/> interface description for more
      information about sessions.

      Note that IMachine does not provide methods to control virtual machine
      execution (such as start the machine, or power it down) -- these methods
      are grouped in a separate interface called <link to="IConsole" />.

      <see><link to="ISession"/>, <link to="IConsole"/></see>
    </desc>

    <attribute name="parent" type="IVirtualBox" readonly="yes">
      <desc>Associated parent object.</desc>
    </attribute>

    <attribute name="accessible" type="boolean" readonly="yes">
      <desc>
        Whether this virtual machine is currently accessible or not.

        A machine is always deemed accessible unless it is registered <i>and</i>
        its settings file cannot be read or parsed (either because the file itself
        is unavailable or has invalid XML contents).

        Every time this property is read, the accessibility state of
        this machine is re-evaluated. If the returned value is @c false,
        the <link to="#accessError"/> property may be used to get the
        detailed error information describing the reason of
        inaccessibility, including XML error messages.

        When the machine is inaccessible, only the following properties
        can be used on it:
        <ul>
          <li><link to="#parent"/></li>
          <li><link to="#id"/></li>
          <li><link to="#settingsFilePath"/></li>
          <li><link to="#accessible"/></li>
          <li><link to="#accessError"/></li>
        </ul>

        An attempt to access any other property or method will return
        an error.

        The only possible action you can perform on an inaccessible
        machine is to unregister it using the
        <link to="IMachine::unregister"/> call (or, to check
        for the accessibility state once more by querying this
        property).

        <note>
          In the current implementation, once this property returns
          @c true, the machine will never become inaccessible
          later, even if its settings file cannot be successfully
          read/written any more (at least, until the VirtualBox
          server is restarted). This limitation may be removed in
          future releases.
        </note>
      </desc>
    </attribute>

    <attribute name="accessError" type="IVirtualBoxErrorInfo" readonly="yes">
      <desc>
        Error information describing the reason of machine
        inaccessibility.

        Reading this property is only valid after the last call to
        <link to="#accessible"/> returned @c false (i.e. the
        machine is currently inaccessible). Otherwise, a @c null
        IVirtualBoxErrorInfo object will be returned.
      </desc>
    </attribute>

    <attribute name="name" type="wstring">
      <desc>
        Name of the virtual machine.

        Besides being used for human-readable identification purposes
        everywhere in VirtualBox, the virtual machine name is also used
        as a name of the machine's settings file and as a name of the
        subdirectory this settings file resides in. Thus, every time you
        change the value of this property, the settings file will be
        renamed once you call <link to="#saveSettings"/> to confirm the
        change. The containing subdirectory will be also renamed, but
        only if it has exactly the same name as the settings file
        itself prior to changing this property (for backward compatibility
        with previous API releases). The above implies the following
        limitations:
        <ul>
          <li>The machine name cannot be empty.</li>
          <li>The machine name can contain only characters that are valid
            file name characters according to the rules of the file
            system used to store VirtualBox configuration.</li>
          <li>You cannot have two or more machines with the same name
            if they use the same subdirectory for storing the machine
            settings files.</li>
          <li>You cannot change the name of the machine if it is running,
            or if any file in the directory containing the settings file
            is being used by another running machine or by any other
            process in the host operating system at a time when
            <link to="#saveSettings"/> is called.
          </li>
        </ul>
        If any of the above limitations are hit, <link to="#saveSettings"/>
        will return an appropriate error message explaining the exact
        reason and the changes you made to this machine will not be saved.

        Starting with VirtualBox 4.0, a ".vbox" extension of the settings
        file is recommended, but not enforced. (Previous versions always
        used a generic ".xml" extension.)
      </desc>
    </attribute>

    <attribute name="description" type="wstring">
      <desc>
        Description of the virtual machine.

        The description attribute can contain any text and is
        typically used to describe the hardware and software
        configuration of the virtual machine in detail (i.e. network
        settings, versions of the installed software and so on).
      </desc>
    </attribute>

    <attribute name="id" type="uuid" mod="string" readonly="yes">
      <desc>UUID of the virtual machine.</desc>
    </attribute>

    <attribute name="groups" type="wstring" safearray="yes">
      <desc>
        Array of machine group names of which this machine is a member.
        <tt>""</tt> and <tt>"/"</tt> are synonyms for the toplevel group. Each
        group is only listed once, however they are listed in no particular
        order and there is no guarantee that there are no gaps in the group
        hierarchy (i.e. <tt>"/group"</tt>,
        <tt>"/group/subgroup/subsubgroup"</tt> is a valid result).
      </desc>
    </attribute>

    <attribute name="OSTypeId" type="wstring">
      <desc>
        User-defined identifier of the Guest OS type.
        You may use <link to="IVirtualBox::getGuestOSType"/> to obtain
        an IGuestOSType object representing details about the given
        Guest OS type.
        <note>
          This value may differ from the value returned by
          <link to="IGuest::OSTypeId"/> if Guest Additions are
          installed to the guest OS.
        </note>
      </desc>
    </attribute>

    <attribute name="hardwareVersion" type="wstring">
      <desc>Hardware version identifier. Internal use only for now.</desc>
    </attribute>

    <attribute name="hardwareUUID" type="uuid" mod="string">
      <desc>
        The UUID presented to the guest via memory tables, hardware and guest
        properties.  For most VMs this is the same as the @a id, but for VMs
        which have been cloned or teleported it may be the same as the source
        VM. The latter is because the guest shouldn't notice that it was
        cloned or teleported.
      </desc>
    </attribute>

    <attribute name="CPUCount" type="unsigned long">
      <desc>Number of virtual CPUs in the VM.</desc>
    </attribute>

    <attribute name="CPUHotPlugEnabled" type="boolean">
      <desc>
        This setting determines whether VirtualBox allows CPU
        hotplugging for this machine.</desc>
    </attribute>

    <attribute name="CPUExecutionCap" type="unsigned long">
      <desc>
        Means to limit the number of CPU cycles a guest can use. The unit
        is percentage of host CPU cycles per second. The valid range
        is 1 - 100. 100 (the default) implies no limit.
      </desc>
    </attribute>

    <attribute name="memorySize" type="unsigned long">
      <desc>System memory size in megabytes.</desc>
    </attribute>

    <attribute name="memoryBalloonSize" type="unsigned long">
      <desc>Memory balloon size in megabytes.</desc>
    </attribute>

    <attribute name="pageFusionEnabled" type="boolean">
      <desc>
        This setting determines whether VirtualBox allows page
        fusion for this machine (64 bits host only).
      </desc>
    </attribute>

    <attribute name="VRAMSize" type="unsigned long">
      <desc>Video memory size in megabytes.</desc>
    </attribute>

    <attribute name="accelerate3DEnabled" type="boolean" default="false">
      <desc>
        This setting determines whether VirtualBox allows this machine to make
        use of the 3D graphics support available on the host.</desc>
    </attribute>

    <attribute name="accelerate2DVideoEnabled" type="boolean" default="false">
      <desc>
        This setting determines whether VirtualBox allows this machine to make
        use of the 2D video acceleration support available on the host.</desc>
    </attribute>

    <attribute name="monitorCount" type="unsigned long">
      <desc>
        Number of virtual monitors.
        <note>
          Only effective on Windows XP and later guests with
          Guest Additions installed.
        </note>
      </desc>
    </attribute>

    <attribute name="VideoCaptureEnabled" type="boolean" default="false">
      <desc>
        This setting determines whether VirtualBox uses video recording to
        record VM session.</desc>
    </attribute>

    <attribute name="VideoCaptureFile" type="wstring" default="Test.webm">
      <desc>
        This setting determines what filename VirtualBox uses to save
        the recorded content.</desc>
    </attribute>

    <attribute name="VideoCaptureWidth" type="unsigned long" default="640">
      <desc>
        This setting determines what should be the horizontal resolution of
        recorded video.</desc>
    </attribute>

    <attribute name="VideoCaptureHeight" type="unsigned long" default="480">
      <desc>
        This setting determines what should be the vertical resolution
        of recorded video.</desc>
    </attribute>

    <attribute name="BIOSSettings" type="IBIOSSettings" readonly="yes">
      <desc>Object containing all BIOS settings.</desc>
    </attribute>

    <attribute name="firmwareType" type="FirmwareType">
      <desc>Type of firmware (such as legacy BIOS or EFI), used for initial
        bootstrap in this VM.</desc>
    </attribute>

    <attribute name="pointingHIDType" type="PointingHIDType">
      <desc>Type of pointing HID (such as mouse or tablet) used in this VM.
        The default is typically "PS2Mouse" but can vary depending on the
        requirements of the guest operating system.</desc>
    </attribute>

    <attribute name="keyboardHIDType" type="KeyboardHIDType">
      <desc>Type of keyboard HID used in this VM.
        The default is typically "PS2Keyboard" but can vary depending on the
        requirements of the guest operating system.</desc>
    </attribute>

    <attribute name="HPETEnabled" type="boolean">
      <desc>This attribute controls if High Precision Event Timer (HPET) is
        enabled in this VM. Use this property if you want to provide guests
        with additional time source, or if guest requires HPET to function correctly.
        Default is false.</desc>
    </attribute>

    <attribute name="chipsetType" type="ChipsetType">
      <desc>Chipset type used in this VM.</desc>
    </attribute>

    <attribute name="snapshotFolder" type="wstring">
      <desc>
        Full path to the directory used to store snapshot data
        (differencing media and saved state files) of this machine.

        The initial value of this property is
        <tt>&lt;</tt><link to="#settingsFilePath">
          path_to_settings_file</link><tt>&gt;/&lt;</tt>
        <link to="#id">machine_uuid</link>
        <tt>&gt;</tt>.

        Currently, it is an error to try to change this property on
        a machine that has snapshots (because this would require to
        move possibly large files to a different location).
        A separate method will be available for this purpose later.

        <note>
          Setting this property to @c null or to an empty string will restore
          the initial value.
        </note>
        <note>
          When setting this property, the specified path can be
          absolute (full path) or relative to the directory where the
          <link to="#settingsFilePath">machine settings file</link>
          is located. When reading this property, a full path is
          always returned.
        </note>
        <note>
          The specified path may not exist, it will be created
          when necessary.
        </note>
      </desc>
    </attribute>

    <attribute name="VRDEServer" type="IVRDEServer" readonly="yes">
      <desc>VirtualBox Remote Desktop Extension (VRDE) server object.</desc>
    </attribute>

    <attribute name="emulatedUSBWebcameraEnabled" type="boolean" default="false"/>
    <attribute name="emulatedUSBCardReaderEnabled" type="boolean" default="false"/>

    <attribute name="mediumAttachments" type="IMediumAttachment" readonly="yes" safearray="yes">
      <desc>Array of media attached to this machine.</desc>
    </attribute>

    <attribute name="USBController" type="IUSBController" readonly="yes">
      <desc>
        Associated USB controller object.

        <note>
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>
      </desc>
    </attribute>

    <attribute name="audioAdapter" type="IAudioAdapter" readonly="yes">
      <desc>Associated audio adapter, always present.</desc>
    </attribute>

    <attribute name="storageControllers" type="IStorageController" readonly="yes" safearray="yes">
      <desc>Array of storage controllers attached to this machine.</desc>
    </attribute>

    <attribute name="settingsFilePath" type="wstring" readonly="yes">
      <desc>
        Full name of the file containing machine settings data.
      </desc>
    </attribute>

    <attribute name="settingsModified" type="boolean" readonly="yes">
      <desc>
        Whether the settings of this machine have been modified
        (but neither yet saved nor discarded).
        <note>
          Reading this property is only valid on instances returned
          by <link to="ISession::machine"/> and on new machines
          created by <link to="IVirtualBox::createMachine"/> or opened
          by <link to="IVirtualBox::openMachine"/> but not
          yet registered, or on unregistered machines after calling
          <link to="IMachine::unregister"/>. For all other
          cases, the settings can never be modified.
        </note>
        <note>
          For newly created unregistered machines, the value of this
          property is always @c true until <link to="#saveSettings"/>
          is called (no matter if any machine settings have been
          changed after the creation or not). For opened machines
          the value is set to @c false (and then follows to normal rules).
        </note>
      </desc>
    </attribute>

    <attribute name="sessionState" type="SessionState" readonly="yes">
      <desc>Current session state for this machine.</desc>
    </attribute>

    <attribute name="sessionType" type="wstring" readonly="yes">
      <desc>
        Type of the session.  If <link to="#sessionState"/> is
        Spawning or Locked, this attribute contains the
        same value as passed to the
        <link to="IMachine::launchVMProcess"/> method in the
        @a type parameter. If the session was used with
        <link to="IMachine::lockMachine" />, or if
        <link to="#sessionState"/> is SessionClosed, the value of this
        attribute is an empty string.
      </desc>
    </attribute>

    <attribute name="sessionPID" type="unsigned long" readonly="yes">
      <desc>
        Identifier of the session process. This attribute contains the
        platform-dependent identifier of the process whose session was
        used with <link to="IMachine::lockMachine" /> call. The returned
        value is only valid if <link to="#sessionState"/> is Locked or
        Unlocking by the time this property is read.
      </desc>
    </attribute>

    <attribute name="state" type="MachineState" readonly="yes">
      <desc>Current execution state of this machine.</desc>
    </attribute>

    <attribute name="lastStateChange" type="long long" readonly="yes">
      <desc>
        Time stamp of the last execution state change,
        in milliseconds since 1970-01-01 UTC.
      </desc>
    </attribute>

    <attribute name="stateFilePath" type="wstring" readonly="yes">
      <desc>
        Full path to the file that stores the execution state of
        the machine when it is in the <link to="MachineState_Saved"/> state.
        <note>
          When the machine is not in the Saved state, this attribute is
          an empty string.
        </note>
      </desc>
    </attribute>

    <attribute name="logFolder" type="wstring" readonly="yes">
      <desc>
        Full path to the folder that stores a set of rotated log files
        recorded during machine execution. The most recent log file is
        named <tt>VBox.log</tt>, the previous log file is
        named <tt>VBox.log.1</tt> and so on (up to <tt>VBox.log.3</tt>
        in the current version).
      </desc>
    </attribute>

    <attribute name="currentSnapshot" type="ISnapshot" readonly="yes">
      <desc>
        Current snapshot of this machine. This is @c null if the machine
        currently has no snapshots. If it is not @c null, then it was
        set by one of <link to="IConsole::takeSnapshot" />,
        <link to="IConsole::deleteSnapshot" />
        or <link to="IConsole::restoreSnapshot" />, depending on which
        was called last. See <link to="ISnapshot"/> for details.
      </desc>
    </attribute>

    <attribute name="snapshotCount" type="unsigned long" readonly="yes">
      <desc>
        Number of snapshots taken on this machine. Zero means the
        machine doesn't have any snapshots.
      </desc>
    </attribute>

    <attribute name="currentStateModified" type="boolean" readonly="yes">
      <desc>
        Returns @c true if the current state of the machine is not
        identical to the state stored in the current snapshot.

        The current state is identical to the current snapshot only
        directly after one of the following calls are made:

        <ul>
          <li><link to="IConsole::restoreSnapshot"/>
          </li>
          <li><link to="IConsole::takeSnapshot"/> (issued on a
            "powered off" or "saved" machine, for which
            <link to="#settingsModified"/> returns @c false)
          </li>
        </ul>

        The current state remains identical until one of the following
        happens:
        <ul>
          <li>settings of the machine are changed</li>
          <li>the saved state is deleted</li>
          <li>the current snapshot is deleted</li>
          <li>an attempt to execute the machine is made</li>
        </ul>

        <note>
          For machines that don't have snapshots, this property is
          always @c false.
        </note>
      </desc>
    </attribute>

    <attribute name="sharedFolders" type="ISharedFolder" readonly="yes" safearray="yes">
      <desc>
        Collection of shared folders for this machine (permanent shared
        folders). These folders are shared automatically at machine startup
        and available only to the guest OS installed within this machine.

        New shared folders are added to the collection using
        <link to="#createSharedFolder"/>. Existing shared folders can be
        removed using <link to="#removeSharedFolder"/>.
      </desc>
    </attribute>

    <attribute name="clipboardMode" type="ClipboardMode">
      <desc>
        Synchronization mode between the host OS clipboard
        and the guest OS clipboard.
      </desc>
    </attribute>

    <attribute name="dragAndDropMode" type="DragAndDropMode">
      <desc>
        Which mode is allowed for drag'n'drop.
      </desc>
    </attribute>

    <attribute name="guestPropertyNotificationPatterns" type="wstring">
      <desc>
        A comma-separated list of simple glob patterns.  Changes to guest
        properties whose name matches one of the patterns will generate an
        <link to="IGuestPropertyChangedEvent"/> signal.
      </desc>
    </attribute>

    <attribute name="teleporterEnabled" type="boolean">
      <desc>
        When set to @a true, the virtual machine becomes a target teleporter
        the next time it is powered on.  This can only set to @a true when the
        VM is in the @a PoweredOff or @a Aborted state.

        <!-- This property is automatically set to @a false when the VM is powered
        on. (bird: This doesn't work yet ) -->
      </desc>
    </attribute>

    <attribute name="teleporterPort" type="unsigned long">
      <desc>
        The TCP port the target teleporter will listen for incoming
        teleportations on.

        0 means the port is automatically selected upon power on.  The actual
        value can be read from this property while the machine is waiting for
        incoming teleportations.
      </desc>
    </attribute>

    <attribute name="teleporterAddress" type="wstring">
      <desc>
        The address the target teleporter will listen on.  If set to an empty
        string, it will listen on all addresses.
      </desc>
    </attribute>

    <attribute name="teleporterPassword" type="wstring">
      <desc>
        The password to check for on the target teleporter. This is just a
        very basic measure to prevent simple hacks and operators accidentally
        beaming a virtual machine to the wrong place.

        Note that you SET a plain text password while reading back a HASHED
        password.  Setting a hashed password is currently not supported.
      </desc>
    </attribute>

    <attribute name="faultToleranceState" type="FaultToleranceState">
      <desc>
        Fault tolerance state; disabled, source or target.
        This property can be changed at any time. If you change it for a running
        VM, then the fault tolerance address and port must be set beforehand.
      </desc>
    </attribute>

    <attribute name="faultTolerancePort" type="unsigned long">
      <desc>
        The TCP port the fault tolerance source or target will use for
        communication.
      </desc>
    </attribute>

    <attribute name="faultToleranceAddress" type="wstring">
      <desc>
        The address the fault tolerance source or target.
      </desc>
    </attribute>

    <attribute name="faultTolerancePassword" type="wstring">
      <desc>
        The password to check for on the standby VM.  This is just a
        very basic measure to prevent simple hacks and operators accidentally
        choosing the wrong standby VM.
      </desc>
    </attribute>

    <attribute name="faultToleranceSyncInterval" type="unsigned long">
      <desc>
        The interval in ms used for syncing the state between source and target.
      </desc>
    </attribute>

    <attribute name="RTCUseUTC" type="boolean">
      <desc>
        When set to @a true, the RTC device of the virtual machine will run
        in UTC time, otherwise in local time. Especially Unix guests prefer
        the time in UTC.
      </desc>
    </attribute>

    <attribute name="IOCacheEnabled" type="boolean">
      <desc>
        When set to @a true, the builtin I/O cache of the virtual machine
        will be enabled.
      </desc>
    </attribute>

    <attribute name="IOCacheSize" type="unsigned long">
      <desc>
        Maximum size of the I/O cache in MB.
      </desc>
    </attribute>

    <attribute name="PCIDeviceAssignments" type="IPCIDeviceAttachment" readonly="yes" safearray="yes">
      <desc>Array of PCI devices assigned to this machine, to get list of all
        PCI devices attached to the machine use
        <link to="IConsole::attachedPCIDevices"/> attribute, as this attribute
        is intended to list only devices additional to what described in
        virtual hardware config. Usually, this list keeps host's physical
        devices assigned to the particular machine.
      </desc>
    </attribute>

    <attribute name="bandwidthControl" type="IBandwidthControl" readonly="yes">
      <desc>
        Bandwidth control manager.
      </desc>
    </attribute>

    <attribute name="tracingEnabled" type="boolean">
      <desc>
        Enables the tracing facility in the VMM (including PDM devices +
        drivers).  The VMM will consume about 0.5MB of more memory when
        enabled and there may be some extra overhead from tracepoints that are
        always enabled.
      </desc>
    </attribute>

    <attribute name="tracingConfig" type="wstring">
      <desc>
        Tracepoint configuration to apply at startup when
        <link to="IMachine::tracingEnabled" /> is true.  The string specifies
        a space separated of tracepoint group names to enable.  The special
        group 'all' enables all tracepoints.  Check DBGFR3TracingConfig for
        more details on available tracepoint groups and such.

        Note that on hosts supporting DTrace (or similar), a lot of the
        tracepoints may be implemented exclusivly as DTrace probes.  So, the
        effect of the same config may differ between Solaris and Windows for
        example.
      </desc>
    </attribute>

    <attribute name="allowTracingToAccessVM" type="boolean">
      <desc>
        Enables tracepoints in PDM devices and drivers to use the VMCPU or VM
        structures when firing off trace points.  This is especially useful
        with DTrace tracepoints, as it allows you to use the VMCPU or VM
        pointer to obtain useful information such as guest register state.

        This is disabled by default because devices and drivers normally has no
        business accessing the VMCPU or VM structures, and are therefore unable
        to get any pointers to these.
      </desc>
    </attribute>

    <attribute name="autostartEnabled" type="boolean">
      <desc>
        Enables autostart of the VM during system boot.
      </desc>
    </attribute>

    <attribute name="autostartDelay" type="unsigned long">
      <desc>
        Number of seconds to wait until the VM should be started during system boot.
      </desc>
    </attribute>

    <attribute name="autostopType" type="AutostopType">
      <desc>
        Action type to do when the system is shutting down.
      </desc>
    </attribute>

    <method name="lockMachine">
      <desc>
        Locks the machine for the given session to enable the caller
        to make changes to the machine or start the VM or control
        VM execution.

        There are two ways to lock a machine for such uses:

        <ul>
          <li>If you want to make changes to the machine settings,
            you must obtain an exclusive write lock on the machine
            by setting @a lockType to @c Write.

            This will only succeed if no other process has locked
            the machine to prevent conflicting changes. Only after
            an exclusive write lock has been obtained using this method, one
            can change all VM settings or execute the VM in the process
            space of the session object. (Note that the latter is only of
            interest if you actually want to write a new front-end for
            virtual machines; but this API gets called internally by
            the existing front-ends such as VBoxHeadless and the VirtualBox
            GUI to acquire a write lock on the machine that they are running.)

            On success, write-locking the machine for a session creates
            a second copy of the IMachine object. It is this second object
            upon which changes can be made; in VirtualBox terminology, the
            second copy is "mutable". It is only this second, mutable machine
            object upon which you can call methods that change the
            machine state. After having called this method, you can
            obtain this second, mutable machine object using the
            <link to="ISession::machine" /> attribute.
          </li>
          <li>If you only want to check the machine state or control
            machine execution without actually changing machine
            settings (e.g. to get access to VM statistics or take
            a snapshot or save the machine state), then set the
            @a lockType argument to @c Shared.

            If no other session has obtained a lock, you will obtain an
            exclusive write lock as described above. However, if another
            session has already obtained such a lock, then a link to that
            existing session will be established which allows you
            to control that existing session.

            To find out which type of lock was obtained, you can
            inspect <link to="ISession::type" />, which will have been
            set to either @c WriteLock or @c Shared.
          </li>
        </ul>

        In either case, you can get access to the <link to="IConsole" />
        object which controls VM execution.

        Also in all of the above cases, one must always call
        <link to="ISession::unlockMachine" /> to release the lock on the machine, or
        the machine's state will eventually be set to "Aborted".

        To change settings on a machine, the following sequence is typically
        performed:

        <ol>
          <li>Call this method to obtain an exclusive write lock for the current session.</li>

          <li>Obtain a mutable IMachine object from <link to="ISession::machine" />.</li>

          <li>Change the settings of the machine by invoking IMachine methods.</li>

          <li>Call <link to="IMachine::saveSettings" />.</li>

          <li>Release the write lock by calling <link to="ISession::unlockMachine"/>.</li>
        </ol>

        <result name="E_UNEXPECTED">
          Virtual machine not registered.
        </result>
        <result name="E_ACCESSDENIED">
          Process not started by OpenRemoteSession.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session already open or being opened.
        </result>
        <result name="VBOX_E_VM_ERROR">
          Failed to assign machine to session.
        </result>
      </desc>
      <param name="session" type="ISession" dir="in">
        <desc>
          Session object for which the machine will be locked.
        </desc>
      </param>
      <param name="lockType" type="LockType" dir="in">
        <desc>
          If set to @c Write, then attempt to acquire an exclusive write lock or fail.
          If set to @c Shared, then either acquire an exclusive write lock or establish
          a link to an existing session.
        </desc>
      </param>
    </method>

    <method name="launchVMProcess">
      <desc>
        Spawns a new process that will execute the virtual machine and obtains a shared
        lock on the machine for the calling session.

        If launching the VM succeeds, the new VM process will create its own session
        and write-lock the machine for it, preventing conflicting changes from other
        processes. If the machine is already locked (because it is already running or
        because another session has a write lock), launching the VM process will therefore
        fail. Reversely, future attempts to obtain a write lock will also fail while the
        machine is running.

        The caller's session object remains separate from the session opened by the new
        VM process. It receives its own <link to="IConsole" /> object which can be used
        to control machine execution, but it cannot be used to change all VM settings
        which would be available after a <link to="#lockMachine" /> call.

        The caller must eventually release the session's shared lock by calling
        <link to="ISession::unlockMachine" /> on the local session object once this call
        has returned. However, the session's state (see <link to="ISession::state" />)
        will not return to "Unlocked" until the remote session has also unlocked
        the machine (i.e. the machine has stopped running).

        Launching a VM process can take some time (a new VM is started in a new process,
        for which memory and other resources need to be set up). Because of this,
        an <link to="IProgress" /> object is returned to allow the caller to wait
        for this asynchronous operation to be completed. Until then, the caller's
        session object remains in the "Unlocked" state, and its <link to="ISession::machine" />
        and <link to="ISession::console" /> attributes cannot be accessed.
        It is recommended to use <link to="IProgress::waitForCompletion" /> or
        similar calls to wait for completion. Completion is signalled when the VM
        is powered on. If launching the VM fails, error messages can be queried
        via the progress object, if available.

        The progress object will have at least 2 sub-operations. The first
        operation covers the period up to the new VM process calls powerUp.
        The subsequent operations mirror the <link to="IConsole::powerUp"/>
        progress object. Because <link to="IConsole::powerUp"/> may require
        some extra sub-operations, the <link to="IProgress::operationCount"/>
        may change at the completion of operation.

        For details on the teleportation progress operation, see
        <link to="IConsole::powerUp"/>.

        The @a environment argument is a string containing definitions of
        environment variables in the following format:
        <pre>
        NAME[=VALUE]\n
        NAME[=VALUE]\n
        ...
        </pre>
        where <tt>\\n</tt> is the new line character. These environment
        variables will be appended to the environment of the VirtualBox server
        process. If an environment variable exists both in the server process
        and in this list, the value from this list takes precedence over the
        server's variable. If the value of the environment variable is
        omitted, this variable will be removed from the resulting environment.
        If the environment string is @c null or empty, the server environment
        is inherited by the started process as is.

        <result name="E_UNEXPECTED">
          Virtual machine not registered.
        </result>
        <result name="E_INVALIDARG">
          Invalid session type @a type.
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No machine matching @a machineId found.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session already open or being opened.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Launching process for machine failed.
        </result>
        <result name="VBOX_E_VM_ERROR">
          Failed to assign machine to session.
        </result>
      </desc>
      <param name="session" type="ISession" dir="in">
        <desc>
          Client session object to which the VM process will be connected (this
          must be in "Unlocked" state).
        </desc>
      </param>
      <param name="type" type="wstring" dir="in">
        <desc>
          Front-end to use for the new VM process. The following are currently supported:
          <ul>
            <li><tt>"gui"</tt>: VirtualBox Qt GUI front-end</li>
            <li><tt>"headless"</tt>: VBoxHeadless (VRDE Server) front-end</li>
            <li><tt>"sdl"</tt>: VirtualBox SDL front-end</li>
            <li><tt>"emergencystop"</tt>: reserved value, used for aborting
              the currently running VM or session owner. In this case the
              @a session parameter may be @c null (if it is non-null it isn't
              used in any way), and the @a progress return value will be always
              @c null. The operation completes immediately.</li>
          </ul>
        </desc>
      </param>
      <param name="environment" type="wstring" dir="in">
        <desc>
          Environment to pass to the VM process.
        </desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="setBootOrder">
      <desc>
        Puts the given device to the specified position in
        the boot order.

        To indicate that no device is associated with the given position,
        <link to="DeviceType_Null"/> should be used.

        @todo setHardDiskBootOrder(), setNetworkBootOrder()

        <result name="E_INVALIDARG">
          Boot @a position out of range.
        </result>
        <result name="E_NOTIMPL">
          Booting from USB @a device currently not supported.
        </result>

      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>
          Position in the boot order (@c 1 to the total number of
          devices the machine can boot from, as returned by
          <link to="ISystemProperties::maxBootPosition"/>).
        </desc>
      </param>
      <param name="device" type="DeviceType" dir="in">
        <desc>
          The type of the device used to boot at the given position.
        </desc>
      </param>
    </method>

    <method name="getBootOrder" const="yes">
      <desc>
        Returns the device type that occupies the specified
        position in the boot order.

        @todo [remove?]
        If the machine can have more than one device of the returned type
        (such as hard disks), then a separate method should be used to
        retrieve the individual device that occupies the given position.

        If here are no devices at the given position, then
        <link to="DeviceType_Null"/> is returned.

        @todo getHardDiskBootOrder(), getNetworkBootOrder()

        <result name="E_INVALIDARG">
          Boot @a position out of range.
        </result>

      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>
          Position in the boot order (@c 1 to the total number of
          devices the machine can boot from, as returned by
          <link to="ISystemProperties::maxBootPosition"/>).
        </desc>
      </param>
      <param name="device" type="DeviceType" dir="return">
        <desc>
          Device at the given position.
        </desc>
      </param>
    </method>

    <method name="attachDevice">
      <desc>
        Attaches a device and optionally mounts a medium to the given storage
        controller (<link to="IStorageController" />, identified by @a name),
        at the indicated port and device.

        This method is intended for managing storage devices in general while a
        machine is powered off. It can be used to attach and detach fixed
        and removable media. The following kind of media can be attached
        to a machine:

        <ul>
          <li>For fixed and removable media, you can pass in a medium that was
            previously opened using <link to="IVirtualBox::openMedium" />.
          </li>

          <li>Only for storage devices supporting removable media (such as
            DVDs and floppies), you can also specify a null pointer to
            indicate an empty drive or one of the medium objects listed
            in the <link to="IHost::DVDDrives" /> and <link to="IHost::floppyDrives"/>
            arrays to indicate a host drive.
            For removable devices, you can also use <link to="IMachine::mountMedium"/>
            to change the media while the machine is running.
          </li>
        </ul>

        In a VM's default configuration of virtual machines, the secondary
        master of the IDE controller is used for a CD/DVD drive.

        After calling this returns successfully, a new instance of
        <link to="IMediumAttachment"/> will appear in the machine's list of medium
        attachments (see <link to="IMachine::mediumAttachments"/>).

        See <link to="IMedium"/> and <link to="IMediumAttachment"/> for more
        information about attaching media.

        The specified device slot must not have a device attached to it,
        or this method will fail.

        <note>
          You cannot attach a device to a newly created machine until
          this machine's settings are saved to disk using
          <link to="#saveSettings"/>.
        </note>
        <note>
          If the medium is being attached indirectly, a new differencing medium
          will implicitly be created for it and attached instead. If the
          changes made to the machine settings (including this indirect
          attachment) are later cancelled using <link to="#discardSettings"/>,
          this implicitly created differencing medium will implicitly
          be deleted.
        </note>

        <result name="E_INVALIDARG">
          SATA device, SATA port, IDE port or IDE slot out of range, or
          file or UUID not found.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Machine must be registered before media can be attached.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Invalid machine state.
        </result>
        <result name="VBOX_E_OBJECT_IN_USE">
          A medium is already attached to this or another virtual machine.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the storage controller to attach the device to.</desc>
      </param>
      <param name="controllerPort" type="long" dir="in">
        <desc>Port to attach the device to. For an IDE controller, 0 specifies
        the primary controller and 1 specifies the secondary controller.
        For a SCSI controller, this must range from 0 to 15; for a SATA controller,
        from 0 to 29; for an SAS controller, from 0 to 7.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>Device slot in the given port to attach the device to. This is only
        relevant for IDE controllers, for which 0 specifies the master device and
        1 specifies the slave device. For all other controller types, this must
        be 0.</desc>
      </param>
      <param name="type" type="DeviceType" dir="in">
        <desc>Device type of the attached device. For media opened by
        <link to="IVirtualBox::openMedium" />, this must match the device type
        specified there.</desc>
      </param>
      <param name="medium" type="IMedium" dir="in">
        <desc>Medium to mount or @c null for an empty drive.</desc>
      </param>
    </method>

  <method name="attachDeviceWithoutMedium">
      <desc>
      Attaches a device and optionally mounts a medium to the given storage
      controller (<link to="IStorageController" />, identified by @a name),
      at the indicated port and device.

      This method is intended for managing storage devices in general while a
      machine is powered off. It can be used to attach and detach fixed
      and removable media. The following kind of media can be attached
      to a machine:
      <ul>
      <li>
      For fixed and removable media, you can pass in a medium that was
      previously opened using <link to="IVirtualBox::openMedium" />.
      </li>

      <li>Only for storage devices supporting removable media (such as
      DVDs and floppies) with an empty drive or one of the medium objects listed
      in the <link to="IHost::DVDDrives" /> and <link to="IHost::floppyDrives"/>
      arrays to indicate a host drive.
      For removable devices, you can also use <link to="IMachine::mountMedium"/>
      to change the media while the machine is running.
      </li>
      </ul>

      In a VM's default configuration of virtual machines, the secondary
      master of the IDE controller is used for a CD/DVD drive.
      <link to="IMediumAttachment"/> will appear in the machine's list of medium
      attachments (see <link to="IMachine::mediumAttachments"/>).

      See <link to="IMedium"/> and <link to="IMediumAttachment"/> for more
      information about attaching media.

      The specified device slot must not have a device attached to it,
      or this method will fail.
      <note>
      You cannot attach a device to a newly created machine until
      this machine's settings are saved to disk using
      <link to="#saveSettings"/>.
      </note>
      <note>
      If the medium is being attached indirectly, a new differencing medium
      will implicitly be created for it and attached instead. If the
      changes made to the machine settings (including this indirect
      attachment) are later cancelled using <link to="#discardSettings"/>,
      this implicitly created differencing medium will implicitly
      be deleted.
      </note>

      <result name="E_INVALIDARG">
        SATA device, SATA port, IDE port or IDE slot out of range, or
            file or UUID not found.
      </result>
      <result name="VBOX_E_INVALID_OBJECT_STATE">
        Machine must be registered before media can be attached.
      </result>
      <result name="VBOX_E_INVALID_VM_STATE">
      Invalid machine state.
      </result>
      <result name="VBOX_E_OBJECT_IN_USE">
      A medium is already attached to this or another virtual machine.
      </result>
      </desc>
      <param name="name" type="wstring" dir="in">
      <desc>Name of the storage controller to attach the device to.</desc>
      </param>
      <param name="controllerPort" type="long" dir="in">
      <desc>Port to attach the device to. For an IDE controller, 0 specifies
      the primary controller and 1 specifies the secondary controller.
      For a SCSI controller, this must range from 0 to 15; for a SATA controller,
      from 0 to 29; for an SAS controller, from 0 to 7.</desc>
      </param>
      <param name="device" type="long" dir="in">
      <desc>Device slot in the given port to attach the device to. This is only
      relevant for IDE controllers, for which 0 specifies the master device and
      1 specifies the slave device. For all other controller types, this must
      be 0.</desc>
      </param>
      <param name="type" type="DeviceType" dir="in">
      <desc>Device type of the attached device. For media opened by
      <link to="IVirtualBox::openMedium" />, this must match the device type
      specified there.</desc>
      </param>
    </method>

    <method name="detachDevice">
      <desc>
        Detaches the device attached to a device slot of the specified bus.

        Detaching the device from the virtual machine is deferred. This means
        that the medium remains associated with the machine when this method
        returns and gets actually de-associated only after a successful
        <link to="#saveSettings"/> call. See <link to="IMedium"/>
        for more detailed information about attaching media.

        <note>
          You cannot detach a device from a running machine.
        </note>
        <note>
          Detaching differencing media implicitly created by <link
          to="#attachDevice"/> for the indirect attachment using this
          method will <b>not</b> implicitly delete them. The
          <link to="IMedium::deleteStorage"/> operation should be
          explicitly performed by the caller after the medium is successfully
          detached and the settings are saved with
          <link to="#saveSettings"/>, if it is the desired action.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Attempt to detach medium from a running virtual machine.
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No medium attached to given slot/bus.
        </result>
        <result name="VBOX_E_NOT_SUPPORTED">
          Medium format does not support storage deletion (only for implicitly
          created differencing media, should not happen).
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the storage controller to detach the medium from.</desc>
      </param>
      <param name="controllerPort" type="long" dir="in">
        <desc>Port number to detach the medium from.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>Device slot number to detach the medium from.</desc>
      </param>
    </method>

    <method name="passthroughDevice">
      <desc>
        Sets the passthrough mode of an existing DVD device. Changing the
        setting while the VM is running is forbidden. The setting is only used
        if at VM start the device is configured as a host DVD drive, in all
        other cases it is ignored. The device must already exist; see
        <link to="IMachine::attachDevice"/> for how to attach a new device.

        The @a controllerPort and @a device parameters specify the device slot and
        have have the same meaning as with <link to="IMachine::attachDevice" />.

        <result name="E_INVALIDARG">
          SATA device, SATA port, IDE port or IDE slot out of range.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Attempt to modify an unregistered virtual machine.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Invalid machine state.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the storage controller.</desc>
      </param>
      <param name="controllerPort" type="long" dir="in">
        <desc>Storage controller port.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>Device slot in the given port.</desc>
      </param>
      <param name="passthrough" type="boolean" dir="in">
        <desc>New value for the passthrough setting.</desc>
      </param>
    </method>

    <method name="temporaryEjectDevice">
      <desc>
        Sets the behavior for guest-triggered medium eject. In some situations
        it is desirable that such ejects update the VM configuration, and in
        others the eject should keep the VM configuration. The device must
        already exist; see <link to="IMachine::attachDevice"/> for how to
        attach a new device.

        The @a controllerPort and @a device parameters specify the device slot and
        have have the same meaning as with <link to="IMachine::attachDevice" />.

        <result name="E_INVALIDARG">
          SATA device, SATA port, IDE port or IDE slot out of range.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Attempt to modify an unregistered virtual machine.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Invalid machine state.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the storage controller.</desc>
      </param>
      <param name="controllerPort" type="long" dir="in">
        <desc>Storage controller port.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>Device slot in the given port.</desc>
      </param>
      <param name="temporaryEject" type="boolean" dir="in">
        <desc>New value for the eject behavior.</desc>
      </param>
    </method>

    <method name="nonRotationalDevice">
      <desc>
        Sets a flag in the device information which indicates that the medium
        is not based on rotational technology, i.e. that the access times are
        more or less independent of the position on the medium. This may or may
        not be supported by a particular drive, and is silently ignored in the
        latter case. At the moment only hard disks (which is a misnomer in this
        context) accept this setting. Changing the setting while the VM is
        running is forbidden. The device must already exist; see
        <link to="IMachine::attachDevice"/> for how to attach a new device.

        The @a controllerPort and @a device parameters specify the device slot and
        have have the same meaning as with <link to="IMachine::attachDevice" />.

        <result name="E_INVALIDARG">
          SATA device, SATA port, IDE port or IDE slot out of range.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Attempt to modify an unregistered virtual machine.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Invalid machine state.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the storage controller.</desc>
      </param>
      <param name="controllerPort" type="long" dir="in">
        <desc>Storage controller port.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>Device slot in the given port.</desc>
      </param>
      <param name="nonRotational" type="boolean" dir="in">
        <desc>New value for the non-rotational device flag.</desc>
      </param>
    </method>

    <method name="setAutoDiscardForDevice">
      <desc>
        Sets a flag in the device information which indicates that the medium
        supports discarding unsused blocks (called trimming for SATA or unmap
        for SCSI devices) .This may or may not be supported by a particular drive,
        and is silently ignored in the latter case. At the moment only hard disks
        (which is a misnomer in this context) accept this setting. Changing the
        setting while the VM is running is forbidden. The device must already
        exist; see <link to="IMachine::attachDevice"/> for how to attach a new
        device.

        The @a controllerPort and @a device parameters specify the device slot and
        have have the same meaning as with <link to="IMachine::attachDevice" />.

        <result name="E_INVALIDARG">
          SATA device, SATA port, SCSI port out of range.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Attempt to modify an unregistered virtual machine.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Invalid machine state.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the storage controller.</desc>
      </param>
      <param name="controllerPort" type="long" dir="in">
        <desc>Storage controller port.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>Device slot in the given port.</desc>
      </param>
      <param name="discard" type="boolean" dir="in">
        <desc>New value for the discard device flag.</desc>
      </param>
    </method>

    <method name="setBandwidthGroupForDevice">
      <desc>
        Sets the bandwidth group of an existing storage device.
        The device must already exist; see <link to="IMachine::attachDevice"/>
        for how to attach a new device.

        The @a controllerPort and @a device parameters specify the device slot and
        have have the same meaning as with <link to="IMachine::attachDevice" />.

        <result name="E_INVALIDARG">
          SATA device, SATA port, IDE port or IDE slot out of range.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Attempt to modify an unregistered virtual machine.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Invalid machine state.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the storage controller.</desc>
      </param>
      <param name="controllerPort" type="long" dir="in">
        <desc>Storage controller port.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>Device slot in the given port.</desc>
      </param>
      <param name="bandwidthGroup" type="IBandwidthGroup" dir="in">
        <desc>New value for the bandwidth group or @c null for no group.</desc>
      </param>
    </method>

    <method name="setNoBandwidthGroupForDevice">
      <desc>
      Sets no bandwidth group for an existing storage device.
      The device must already exist; see <link to="IMachine::attachDevice"/>
      for how to attach a new device.
      The @a controllerPort and @a device parameters specify the device slot and
      have have the same meaning as with <link to="IMachine::attachDevice" />.
      <result name="E_INVALIDARG">
      SATA device, SATA port, IDE port or IDE slot out of range.
      </result>
      <result name="VBOX_E_INVALID_OBJECT_STATE">
      Attempt to modify an unregistered virtual machine.
      </result>
      <result name="VBOX_E_INVALID_VM_STATE">
      Invalid machine state.
      </result>

       </desc>
      <param name="name" type="wstring" dir="in">
      <desc>Name of the storage controller.</desc>
      </param>
      <param name="controllerPort" type="long" dir="in">
      <desc>Storage controller port.</desc>
      </param>
      <param name="device" type="long" dir="in">
      <desc>Device slot in the given port.</desc>
      </param>
    </method>


    <method name="unmountMedium">
          <desc>
            Unmounts any currently mounted medium (<link to="IMedium" />,
            identified by the given UUID @a id) to the given storage controller
            (<link to="IStorageController" />, identified by @a name),
            at the indicated port and device. The device must already exist;

            This method is intended only for managing removable media, where the
            device is fixed but media is changeable at runtime (such as DVDs
            and floppies). It cannot be used for fixed media such as hard disks.

            The @a controllerPort and @a device parameters specify the device slot
            and have have the same meaning as with
            <link to="IMachine::attachDevice" />.

            The specified device slot must have a medium mounted, which will be
            unmounted. If there is no mounted medium it will do nothing.
            See <link to="IMedium"/> for more detailed information about
            attaching/unmounting media.

            <result name="E_INVALIDARG">
            SATA device, SATA port, IDE port or IDE slot out of range.
            </result>
            <result name="VBOX_E_INVALID_OBJECT_STATE">
            Attempt to unmount medium that is not removeable - not dvd or floppy.
            </result>
            <result name="VBOX_E_INVALID_VM_STATE">
            Invalid machine state.
            </result>
            <result name="VBOX_E_OBJECT_IN_USE">
            Medium already attached to this or another virtual machine.
            </result>
            <result name="VBOX_E_OBJECT_NOT_FOUND">
            Medium not attached to specified port, device, controller.
            </result>

            </desc>
              <param name="name" type="wstring" dir="in">
              <desc>Name of the storage controller to unmount the medium from.</desc>
              </param>
              <param name="controllerPort" type="long" dir="in">
              <desc>Port to unmount the medium from.</desc>
              </param>
              <param name="device" type="long" dir="in">
              <desc>Device slot in the given port to unmount the medium from.</desc>
              </param>
              <param name="force" type="boolean" dir="in">
              <desc>Allows to force unmount of a medium which is locked by
              the device slot in the given port medium is attached to.</desc>
              </param>
          </method>

    <method name="mountMedium">
      <desc>
        Mounts a medium (<link to="IMedium" />, identified
        by the given UUID @a id) to the given storage controller
        (<link to="IStorageController" />, identified by @a name),
        at the indicated port and device. The device must already exist;
        see <link to="IMachine::attachDevice"/> for how to attach a new device.

        This method is intended only for managing removable media, where the
        device is fixed but media is changeable at runtime (such as DVDs
        and floppies). It cannot be used for fixed media such as hard disks.

        The @a controllerPort and @a device parameters specify the device slot and
        have have the same meaning as with <link to="IMachine::attachDevice" />.

        The specified device slot can have a medium mounted, which will be
        unmounted first. Specifying a zero UUID (or an empty string) for
        @a medium does just an unmount.

        See <link to="IMedium"/> for more detailed information about
        attaching media.

        <result name="E_INVALIDARG">
          SATA device, SATA port, IDE port or IDE slot out of range.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Attempt to attach medium to an unregistered virtual machine.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Invalid machine state.
        </result>
        <result name="VBOX_E_OBJECT_IN_USE">
          Medium already attached to this or another virtual machine.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the storage controller to attach the medium to.</desc>
      </param>
      <param name="controllerPort" type="long" dir="in">
        <desc>Port to attach the medium to.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>Device slot in the given port to attach the medium to.</desc>
      </param>
      <param name="medium" type="IMedium" dir="in">
        <desc>Medium to mount or @c null for an empty drive.</desc>
      </param>
      <param name="force" type="boolean" dir="in">
        <desc>Allows to force unmount/mount of a medium which is locked by
          the device slot in the given port to attach the medium to.</desc>
      </param>
    </method>

    <method name="getMedium" const="yes">
      <desc>
        Returns the virtual medium attached to a device slot of the specified
        bus.

        Note that if the medium was indirectly attached by
        <link to="#mountMedium"/> to the given device slot then this
        method will return not the same object as passed to the
        <link to="#mountMedium"/> call. See <link to="IMedium"/> for
        more detailed information about mounting a medium.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No medium attached to given slot/bus.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the storage controller the medium is attached to.</desc>
      </param>
      <param name="controllerPort" type="long" dir="in">
        <desc>Port to query.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>Device slot in the given port to query.</desc>
      </param>
      <param name="medium" type="IMedium" dir="return">
        <desc>Attached medium object.</desc>
      </param>
    </method>

    <method name="getMediumAttachmentsOfController" const="yes">
      <desc>
        Returns an array of medium attachments which are attached to the
        the controller with the given name.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          A storage controller with given name doesn't exist.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in"/>
      <param name="mediumAttachments" type="IMediumAttachment" safearray="yes" dir="return"/>
    </method>

    <method name="getMediumAttachment" const="yes">
      <desc>
        Returns a medium attachment which corresponds to the controller with
        the given name, on the given port and device slot.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No attachment exists for the given controller/port/device combination.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in"/>
      <param name="controllerPort" type="long" dir="in"/>
      <param name="device" type="long" dir="in"/>
      <param name="attachment" type="IMediumAttachment" dir="return"/>
    </method>

    <method name="attachHostPCIDevice">
      <desc>
        Attaches host PCI device with the given (host) PCI address to the
        PCI bus of the virtual machine. Please note, that this operation
        is two phase, as real attachment will happen when VM will start,
        and most information will be delivered as IHostPCIDevicePlugEvent
        on IVirtualBox event source.

        <see><link to="IHostPCIDevicePlugEvent"/></see>

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine state is not stopped (PCI hotplug not yet implemented).
        </result>
        <result name="VBOX_E_PDM_ERROR">
          Virtual machine does not have a PCI controller allowing attachment of physical devices.
        </result>
        <result name="VBOX_E_NOT_SUPPORTED">
          Hardware or host OS doesn't allow PCI device passthrought.
        </result>
      </desc>
      <param name="hostAddress" type="long" dir="in">
        <desc>Address of the host PCI device.</desc>
      </param>
      <param name="desiredGuestAddress" type="long" dir="in">
        <desc>Desired position of this device on guest PCI bus.</desc>
      </param>
      <param name="tryToUnbind" type="boolean" dir="in">
        <desc>If VMM shall try to unbind existing drivers from the
        device before attaching it to the guest.</desc>
      </param>
    </method>

    <method name="detachHostPCIDevice">
      <desc>
        Detach host PCI device from the virtual machine.
        Also HostPCIDevicePlugEvent on IVirtualBox event source
        will be delivered. As currently we don't support hot device
        unplug, IHostPCIDevicePlugEvent event is delivered immediately.

        <see><link to="IHostPCIDevicePlugEvent"/></see>

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine state is not stopped (PCI hotplug not yet implemented).
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          This host device is not attached to this machine.
        </result>
        <result name="VBOX_E_PDM_ERROR">
          Virtual machine does not have a PCI controller allowing attachment of physical devices.
        </result>
        <result name="VBOX_E_NOT_SUPPORTED">
          Hardware or host OS doesn't allow PCI device passthrought.
        </result>
      </desc>
      <param name="hostAddress" type="long" dir="in">
        <desc>Address of the host PCI device.</desc>
      </param>
    </method>

    <method name="getNetworkAdapter" const="yes">
      <desc>
        Returns the network adapter associated with the given slot.
        Slots are numbered sequentially, starting with zero. The total
        number of adapters per machine is defined by the
        <link to="ISystemProperties::getMaxNetworkAdapters"/> property,
        so the maximum slot number is one less than that property's value.

        <result name="E_INVALIDARG">
          Invalid @a slot number.
        </result>

      </desc>
      <param name="slot" type="unsigned long" dir="in"/>
      <param name="adapter" type="INetworkAdapter" dir="return"/>
    </method>

    <method name="addStorageController">
      <desc>
        Adds a new storage controller (SCSI, SAS or SATA controller) to the
        machine and returns it as an instance of
        <link to="IStorageController" />.

        @a name identifies the controller for subsequent calls such as
        <link to="#getStorageControllerByName" />,
        <link to="#getStorageControllerByInstance" />,
        <link to="#removeStorageController" />,
        <link to="#attachDevice" /> or <link to="#mountMedium" />.

        After the controller has been added, you can set its exact
        type by setting the <link to="IStorageController::controllerType" />.

        <result name="VBOX_E_OBJECT_IN_USE">
          A storage controller with given name exists already.
        </result>
        <result name="E_INVALIDARG">
          Invalid @a controllerType.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in"/>
      <param name="connectionType" type="StorageBus" dir="in"/>
      <param name="controller" type="IStorageController" dir="return"/>
    </method>

    <method name="getStorageControllerByName" const="yes">
      <desc>
        Returns a storage controller with the given name.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          A storage controller with given name doesn't exist.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in"/>
      <param name="storageController" type="IStorageController" dir="return"/>
    </method>

    <method name="getStorageControllerByInstance" const="yes">
      <desc>
        Returns a storage controller with the given instance number.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          A storage controller with given instance number doesn't exist.
        </result>
      </desc>
      <param name="instance" type="unsigned long" dir="in"/>
      <param name="storageController" type="IStorageController" dir="return"/>
    </method>

    <method name="removeStorageController">
      <desc>
        Removes a storage controller from the machine with all devices attached to it.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          A storage controller with given name doesn't exist.
        </result>
        <result name="VBOX_E_NOT_SUPPORTED">
          Medium format does not support storage deletion (only for implicitly
          created differencing media, should not happen).
        </result>
      </desc>
      <param name="name" type="wstring" dir="in"/>
    </method>

    <method name="setStorageControllerBootable">
      <desc>
        Sets the bootable flag of the storage controller with the given name.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          A storage controller with given name doesn't exist.
        </result>
        <result name="VBOX_E_OBJECT_IN_USE">
          Another storage controller is marked as bootable already.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in"/>
      <param name="bootable" type="boolean" dir="in"/>
    </method>

    <method name="getSerialPort" const="yes">
      <desc>
        Returns the serial port associated with the given slot.
        Slots are numbered sequentially, starting with zero. The total
        number of serial ports per machine is defined by the
        <link to="ISystemProperties::serialPortCount"/> property,
        so the maximum slot number is one less than that property's value.

        <result name="E_INVALIDARG">
          Invalid @a slot number.
        </result>

      </desc>
      <param name="slot" type="unsigned long" dir="in"/>
      <param name="port" type="ISerialPort" dir="return"/>
    </method>

    <method name="getParallelPort" const="yes">
      <desc>
        Returns the parallel port associated with the given slot.
        Slots are numbered sequentially, starting with zero. The total
        number of parallel ports per machine is defined by the
        <link to="ISystemProperties::parallelPortCount"/> property,
        so the maximum slot number is one less than that property's value.

        <result name="E_INVALIDARG">
          Invalid @a slot number.
        </result>

      </desc>
      <param name="slot" type="unsigned long" dir="in"/>
      <param name="port" type="IParallelPort" dir="return"/>
    </method>

    <method name="getExtraDataKeys">
        <desc>
            Returns an array representing the machine-specific extra data keys
            which currently have values defined.
        </desc>
        <param name="value" type="wstring" dir="return" safearray="yes">
            <desc>Array of extra data keys.</desc>
        </param>
    </method>

    <method name="getExtraData">
      <desc>
        Returns associated machine-specific extra data.

        If the requested data @a key does not exist, this function will
        succeed and return an empty string in the @a value argument.

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>

      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to get.</desc>
      </param>
      <param name="value" type="wstring" dir="return">
        <desc>Value of the requested data key.</desc>
      </param>
    </method>

    <method name="setExtraData">
      <desc>
        Sets associated machine-specific extra data.

        If you pass @c null or an empty string as a key @a value, the given
        @a key will be deleted.

        <note>
          Before performing the actual data change, this method will ask all
          registered listeners using the
          <link to="IExtraDataCanChangeEvent"/>
          notification for a permission. If one of the listeners refuses the
          new value, the change will not be performed.
        </note>
        <note>
          On success, the
          <link to="IExtraDataChangedEvent"/> notification
          is called to inform all registered listeners about a successful data
          change.
        </note>
        <note>
          This method can be called outside the machine session and therefore
          it's a caller's responsibility to handle possible race conditions
          when several clients change the same key at the same time.
        </note>

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>

      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to set.</desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>Value to assign to the key.</desc>
      </param>
    </method>

    <method name="getCPUProperty" const="yes">
      <desc>
        Returns the virtual CPU boolean value of the specified property.

        <result name="E_INVALIDARG">
          Invalid property.
        </result>

      </desc>
      <param name="property" type="CPUPropertyType" dir="in">
        <desc>
          Property type to query.
        </desc>
      </param>
      <param name="value" type="boolean" dir="return">
        <desc>
          Property value.
        </desc>
      </param>
    </method>

    <method name="setCPUProperty">
      <desc>
        Sets the virtual CPU boolean value of the specified property.

        <result name="E_INVALIDARG">
          Invalid property.
        </result>

      </desc>
      <param name="property" type="CPUPropertyType" dir="in">
        <desc>
          Property type to query.
        </desc>
      </param>
      <param name="value" type="boolean" dir="in">
        <desc>
          Property value.
        </desc>
      </param>
    </method>

    <method name="getCPUIDLeaf" const="yes">
      <desc>
        Returns the virtual CPU cpuid information for the specified leaf.

        Currently supported index values for cpuid:
        Standard CPUID leafs: 0 - 0xA
        Extended CPUID leafs: 0x80000000 - 0x8000000A

        See the Intel and AMD programmer's manuals for detailed information
        about the cpuid instruction and its leafs.
        <result name="E_INVALIDARG">
          Invalid id.
        </result>

      </desc>
      <param name="id" type="unsigned long" dir="in">
        <desc>
          CPUID leaf index.
        </desc>
      </param>
      <param name="valEax" type="unsigned long" dir="out">
        <desc>
          CPUID leaf value for register eax.
        </desc>
      </param>
      <param name="valEbx" type="unsigned long" dir="out">
        <desc>
          CPUID leaf value for register ebx.
        </desc>
      </param>
      <param name="valEcx" type="unsigned long" dir="out">
        <desc>
          CPUID leaf value for register ecx.
        </desc>
      </param>
      <param name="valEdx" type="unsigned long" dir="out">
        <desc>
          CPUID leaf value for register edx.
        </desc>
      </param>
    </method>

    <method name="setCPUIDLeaf">
      <desc>
        Sets the virtual CPU cpuid information for the specified leaf. Note that these values
        are not passed unmodified. VirtualBox clears features that it doesn't support.

        Currently supported index values for cpuid:
        Standard CPUID leafs: 0 - 0xA
        Extended CPUID leafs: 0x80000000 - 0x8000000A

        See the Intel and AMD programmer's manuals for detailed information
        about the cpuid instruction and its leafs.

        Do not use this method unless you know exactly what you're doing. Misuse can lead to
        random crashes inside VMs.
        <result name="E_INVALIDARG">
          Invalid id.
        </result>

      </desc>
      <param name="id" type="unsigned long" dir="in">
        <desc>
          CPUID leaf index.
        </desc>
      </param>
      <param name="valEax" type="unsigned long" dir="in">
        <desc>
          CPUID leaf value for register eax.
        </desc>
      </param>
      <param name="valEbx" type="unsigned long" dir="in">
        <desc>
          CPUID leaf value for register ebx.
        </desc>
      </param>
      <param name="valEcx" type="unsigned long" dir="in">
        <desc>
          CPUID leaf value for register ecx.
        </desc>
      </param>
      <param name="valEdx" type="unsigned long" dir="in">
        <desc>
          CPUID leaf value for register edx.
        </desc>
      </param>
    </method>

    <method name="removeCPUIDLeaf">
      <desc>
        Removes the virtual CPU cpuid leaf for the specified index

        <result name="E_INVALIDARG">
          Invalid id.
        </result>

      </desc>
      <param name="id" type="unsigned long" dir="in">
        <desc>
          CPUID leaf index.
        </desc>
      </param>
    </method>

    <method name="removeAllCPUIDLeaves">
      <desc>
        Removes all the virtual CPU cpuid leaves
      </desc>
    </method>

    <method name="getHWVirtExProperty" const="yes">
      <desc>
        Returns the value of the specified hardware virtualization boolean property.

        <result name="E_INVALIDARG">
          Invalid property.
        </result>

      </desc>
      <param name="property" type="HWVirtExPropertyType" dir="in">
        <desc>
          Property type to query.
        </desc>
      </param>
      <param name="value" type="boolean" dir="return">
        <desc>
          Property value.
        </desc>
      </param>
    </method>

    <method name="setHWVirtExProperty">
      <desc>
        Sets a new value for the specified hardware virtualization boolean property.

        <result name="E_INVALIDARG">
          Invalid property.
        </result>

      </desc>
      <param name="property" type="HWVirtExPropertyType" dir="in">
        <desc>
          Property type to set.
        </desc>
      </param>
      <param name="value" type="boolean" dir="in">
        <desc>
          New property value.
        </desc>
      </param>
    </method>

    <method name="saveSettings">
      <desc>
        Saves any changes to machine settings made since the session
        has been opened or a new machine has been created, or since the
        last call to <link to="#saveSettings"/> or <link to="#discardSettings"/>.
        For registered machines, new settings become visible to all
        other VirtualBox clients after successful invocation of this
        method.
        <note>
          The method sends <link to="IMachineDataChangedEvent"/>
          notification event after the configuration has been successfully
          saved (only for registered machines).
        </note>
        <note>
          Calling this method is only valid on instances returned
          by <link to="ISession::machine"/> and on new machines
          created by <link to="IVirtualBox::createMachine"/> but not
          yet registered, or on unregistered machines after calling
          <link to="IMachine::unregister"/>.
        </note>

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>
        <result name="E_ACCESSDENIED">
          Modification request refused.
        </result>

      </desc>
    </method>

    <method name="discardSettings">
      <desc>
        Discards any changes to the machine settings made since the session
        has been opened or since the last call to <link to="#saveSettings"/>
        or <link to="#discardSettings"/>.
        <note>
          Calling this method is only valid on instances returned
          by <link to="ISession::machine"/> and on new machines
          created by <link to="IVirtualBox::createMachine"/> or
          opened by <link to="IVirtualBox::openMachine"/> but not
          yet registered, or on unregistered machines after calling
          <link to="IMachine::unregister"/>.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable.
        </result>

      </desc>
    </method>

    <method name="unregister">
      <desc>
        Unregisters a machine previously registered with
        <link to="IVirtualBox::registerMachine"/> and optionally do additional
        cleanup before the machine is unregistered.

        This method does not delete any files. It only changes the machine configuration and
        the list of registered machines in the VirtualBox object. To delete the files which
        belonged to the machine, including the XML file of the machine itself, call
        <link to="#delete"/>, optionally with the array of IMedium objects which was returned
        from this method.

        How thoroughly this method cleans up the machine configuration before unregistering
        the machine depends on the @a cleanupMode argument.

        <ul>
          <li>With "UnregisterOnly", the machine will only be unregistered, but no additional
            cleanup will be performed. The call will fail if the machine is in "Saved" state
            or has any snapshots or any media attached (see <link to="IMediumAttachment" />).
            It is the responsibility of the caller to delete all such configuration in this mode.
            In this mode, the API behaves like the former @c IVirtualBox::unregisterMachine() API
            which it replaces.</li>
          <li>With "DetachAllReturnNone", the call will succeed even if the machine is in "Saved"
            state or if it has snapshots or media attached. All media attached to the current machine
            state or in snapshots will be detached. No medium objects will be returned;
            all of the machine's media will remain open.</li>
          <li>With "DetachAllReturnHardDisksOnly", the call will behave like with "DetachAllReturnNone",
            except that all the hard disk medium objects which were detached from the machine will
            be returned as an array. This allows for quickly passing them to the <link to="#delete" />
            API for closing and deletion.</li>
          <li>With "Full", the call will behave like with "DetachAllReturnHardDisksOnly", except
            that all media will be returned in the array, including removable media like DVDs and
            floppies. This might be useful if the user wants to inspect in detail which media were
            attached to the machine. Be careful when passing the media array to <link to="#delete" />
            in that case because users will typically want to preserve ISO and RAW image files.</li>
        </ul>

        A typical implementation will use "DetachAllReturnHardDisksOnly" and then pass the
        resulting IMedium array to <link to="#delete"/>. This way, the machine is completely
        deleted with all its saved states and hard disk images, but images for removable
        drives (such as ISO and RAW files) will remain on disk.

        This API does not verify whether the media files returned in the array are still
        attached to other machines (i.e. shared between several machines). If such a shared
        image is passed to <link to="#delete" /> however, closing the image will fail there
        and the image will be silently skipped.

        This API may, however, move media from this machine's media registry to other media
        registries (see <link to="IMedium" /> for details on media registries). For machines
        created with VirtualBox 4.0 or later, if media from this machine's media registry
        are also attached to another machine (shared attachments), each such medium will be
        moved to another machine's registry. This is because without this machine's media
        registry, the other machine cannot find its media any more and would become inaccessible.

        This API implicitly calls <link to="#saveSettings"/> to save all current machine settings
        before unregistering it. It may also silently call <link to="#saveSettings"/> on other machines
        if media are moved to other machines' media registries.

        After successful method invocation, the <link to="IMachineRegisteredEvent"/> event
        is fired.

        The call will fail if the machine is currently locked (see <link to="ISession" />).

        <note>
          If the given machine is inaccessible (see <link to="#accessible"/>), it
          will be unregistered and fully uninitialized right afterwards. As a result,
          the returned machine object will be unusable and an attempt to call
          <b>any</b> method will return the "Object not ready" error.
        </note>

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Machine is currently locked for a session.
        </result>
      </desc>

      <param name="cleanupMode" type="CleanupMode" dir="in">
        <desc>How to clean up after the machine has been unregistered.</desc>
      </param>
      <param name="aMedia" type="IMedium" safearray="yes" dir="return">
        <desc>List of media detached from the machine, depending on the @a cleanupMode parameter.</desc>
      </param>
    </method>

    <method name="delete">
      <desc>
        Deletes the files associated with this machine from disk. If medium objects are passed
        in with the @a aMedia argument, they are closed and, if closing was successful, their
        storage files are deleted as well. For convenience, this array of media files can be
        the same as the one returned from a previous <link to="#unregister" /> call.

        This method must only be called on machines which are either write-locked (i.e. on instances
        returned by <link to="ISession::machine"/>) or on unregistered machines (i.e. not yet
        registered machines created by <link to="IVirtualBox::createMachine"/> or opened by
        <link to="IVirtualBox::openMachine"/>, or after having called <link to="#unregister"/>).

        The following files will be deleted by this method:
        <ul>
          <li>If <link to="#unregister" /> had been previously called with a @a cleanupMode
            argument other than "UnregisterOnly", this will delete all saved state files that
            the machine had in use; possibly one if the machine was in "Saved" state and one
            for each online snapshot that the machine had.</li>
          <li>On each medium object passed in the @a aMedia array, this will call
            <link to="IMedium::close" />. If that succeeds, this will attempt to delete the
            medium's storage on disk. Since the <link to="IMedium::close"/> call will fail if the medium is still
            in use, e.g. because it is still attached to a second machine; in that case the
            storage will not be deleted.</li>
          <li>Finally, the machine's own XML file will be deleted.</li>
        </ul>

        Since deleting large disk image files can be a time-consuming I/O operation, this
        method operates asynchronously and returns an IProgress object to allow the caller
        to monitor the progress. There will be one sub-operation for each file that is
        being deleted (saved state or medium storage file).

        <note>
          <link to="#settingsModified"/> will return @c true after this
          method successfully returns.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine is registered but not write-locked.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not delete the settings file.
        </result>
      </desc>
      <param name="aMedia" type="IMedium" safearray="yes" dir="in">
        <desc>List of media to be closed and whose storage files will be deleted.</desc>
      </param>
      <param name="aProgress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="export">
      <desc>Exports the machine to an OVF appliance. See <link to="IAppliance" /> for the
            steps required to export VirtualBox machines to OVF.
      </desc>

      <param name="aAppliance" type="IAppliance" dir="in">
        <desc>Appliance to export this machine to.</desc>
      </param>
      <param name="location" type="wstring" dir="in">
        <desc>The target location.</desc>
      </param>
      <param name="aDescription" type="IVirtualSystemDescription" dir="return">
        <desc>VirtualSystemDescription object which is created for this machine.</desc>
      </param>
    </method >

    <method name="findSnapshot">
      <desc>
        Returns a snapshot of this machine with the given name or UUID.

        Returns a snapshot of this machine with the given UUID.
        A @c null argument can be used to obtain the first snapshot
        taken on this machine. To traverse the whole tree of snapshots
        starting from the root, inspect the root snapshot's
        <link to="ISnapshot::children" /> attribute and recurse over those children.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Virtual machine has no snapshots or snapshot not found.
        </result>

      </desc>
      <param name="nameOrId" type="wstring" dir="in">
        <desc>What to search for. Name or UUID of the snapshot to find</desc>
      </param>
      <param name="snapshot" type="ISnapshot" dir="return">
        <desc>Snapshot object with the given name.</desc>
      </param>
    </method>

    <method name="createSharedFolder">
      <desc>
        Creates a new permanent shared folder by associating the given logical
        name with the given host path, adds it to the collection of shared
        folders and starts sharing it. Refer to the description of
        <link to="ISharedFolder"/> to read more about logical names.

        <result name="VBOX_E_OBJECT_IN_USE">
          Shared folder already exists.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Shared folder @a hostPath not accessible.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Unique logical name of the shared folder.</desc>
      </param>
      <param name="hostPath" type="wstring" dir="in">
        <desc>Full path to the shared folder in the host file system.</desc>
      </param>
      <param name="writable" type="boolean" dir="in">
        <desc>Whether the share is writable or readonly.</desc>
      </param>
      <param name="automount" type="boolean" dir="in">
        <desc>Whether the share gets automatically mounted by the guest
          or not.</desc>
      </param>
    </method>

    <method name="removeSharedFolder">
      <desc>
        Removes the permanent shared folder with the given name previously
        created by <link to="#createSharedFolder"/> from the collection of
        shared folders and stops sharing it.

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable.
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Shared folder @a name does not exist.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Logical name of the shared folder to remove.</desc>
      </param>
    </method>

    <method name="canShowConsoleWindow">
      <desc>
        Returns @c true if the VM console process can activate the
        console window and bring it to foreground on the desktop of
        the host PC.
        <note>
          This method will fail if a session for this machine is not
          currently open.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>

      </desc>
      <param name="canShow" type="boolean" dir="return">
        <desc>
          @c true if the console window can be shown and @c false otherwise.
        </desc>
      </param>
    </method>

    <method name="showConsoleWindow">
      <desc>
        Activates the console window and brings it to foreground on
        the desktop of the host PC. Many modern window managers on
        many platforms implement some sort of focus stealing
        prevention logic, so that it may be impossible to activate
        a window without the help of the currently active
        application. In this case, this method will return a non-zero
        identifier that represents the top-level window of the VM
        console process. The caller, if it represents a currently
        active process, is responsible to use this identifier (in a
        platform-dependent manner) to perform actual window
        activation.
        <note>
          This method will fail if a session for this machine is not
          currently open.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>

      </desc>
      <param name="winId" type="long long" dir="return">
        <desc>
          Platform-dependent identifier of the top-level VM console
          window, or zero if this method has performed all actions
          necessary to implement the <i>show window</i> semantics for
          the given platform and/or VirtualBox front-end.
        </desc>
      </param>
    </method>

    <method name="getGuestProperty" const="yes">
      <desc>
        Reads an entry from the machine's guest property store.

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          The name of the property to read.
        </desc>
      </param>
      <param name="value" type="wstring" dir="out">
        <desc>
          The value of the property.  If the property does not exist then this
          will be empty.
        </desc>
      </param>
      <param name="timestamp" type="long long" dir="out">
        <desc>
          The time at which the property was last modified, as seen by the
          server process.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="out">
        <desc>
          Additional property parameters, passed as a comma-separated list of
          "name=value" type entries.
        </desc>
      </param>
    </method>

    <method name="getGuestPropertyValue" const="yes">
      <desc>
        Reads a value from the machine's guest property store.

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>

      </desc>
      <param name="property" type="wstring" dir="in">
        <desc>
          The name of the property to read.
        </desc>
      </param>
      <param name="value" type="wstring" dir="return">
        <desc>
          The value of the property.  If the property does not exist then this
          will be empty.
        </desc>
      </param>
    </method>

    <method name="getGuestPropertyTimestamp" const="yes">
      <desc>
        Reads a property timestamp from the machine's guest property store.

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>

      </desc>
      <param name="property" type="wstring" dir="in">
        <desc>
          The name of the property to read.
        </desc>
      </param>
      <param name="value" type="long long" dir="return">
        <desc>
          The timestamp.  If the property does not exist then this will be
          empty.
        </desc>
      </param>
    </method>

    <method name="setGuestProperty">
      <desc>
        Sets, changes or deletes an entry in the machine's guest property
        store.

        <result name="E_ACCESSDENIED">
          Property cannot be changed.
        </result>
        <result name="E_INVALIDARG">
          Invalid @a flags.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable or session not open.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Cannot set transient property when machine not running.
        </result>

      </desc>
      <param name="property" type="wstring" dir="in">
        <desc>
          The name of the property to set, change or delete.
        </desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>
          The new value of the property to set, change or delete.  If the
          property does not yet exist and value is non-empty, it will be
          created.  If the value is @c null or empty, the property will be
          deleted if it exists.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="in">
        <desc>
          Additional property parameters, passed as a comma-separated list of
          "name=value" type entries.
        </desc>
      </param>
    </method>

    <method name="setGuestPropertyValue">
      <desc>
        Sets, changes or deletes a value in the machine's guest property
        store.  The flags field will be left unchanged or created empty for a
        new property.

        <result name="E_ACCESSDENIED">
          Property cannot be changed.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable or session not open.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Cannot set transient property when machine not running.
        </result>
      </desc>

      <param name="property" type="wstring" dir="in">
        <desc>
          The name of the property to set, change or delete.
        </desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>
          The new value of the property to set, change or delete.  If the
          property does not yet exist and value is non-empty, it will be
          created.  If the value is @c null or empty, the property will be
          deleted if it exists.
        </desc>
      </param>
    </method>

    <method name="deleteGuestProperty" const="yes">
      <desc>
        Deletes an entry from the machine's guest property store.

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          The name of the property to delete.
        </desc>
      </param>
    </method>

    <method name="enumerateGuestProperties" const="yes">
      <desc>
        Return a list of the guest properties matching a set of patterns along
        with their values, time stamps and flags.
      </desc>
      <param name="patterns" type="wstring" dir="in">
        <desc>
          The patterns to match the properties against, separated by '|'
          characters.  If this is empty or @c null, all properties will match.
        </desc>
      </param>
      <param name="name" type="wstring" dir="out" safearray="yes">
        <desc>
          The names of the properties returned.
        </desc>
      </param>
      <param name="value" type="wstring" dir="out" safearray="yes">
        <desc>
          The values of the properties returned.  The array entries match the
          corresponding entries in the @a name array.
        </desc>
      </param>
      <param name="timestamp" type="long long" dir="out" safearray="yes">
        <desc>
          The time stamps of the properties returned.  The array entries match
          the corresponding entries in the @a name array.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="out" safearray="yes">
        <desc>
          The flags of the properties returned.  The array entries match the
          corresponding entries in the @a name array.
        </desc>
      </param>
    </method>

    <method name="querySavedGuestScreenInfo" const="yes">
      <desc>
        Returns the guest dimensions from the saved state.
      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Saved guest screen to query info from.
        </desc>
      </param>
      <param name="originX" type="unsigned long" dir="out">
        <desc>
          The X position of the guest monitor top left corner.
        </desc>
      </param>
      <param name="originY" type="unsigned long" dir="out">
        <desc>
          The Y position of the guest monitor top left corner.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="out">
        <desc>
          Guest width at the time of the saved state was taken.
        </desc>
      </param>
      <param name="height" type="unsigned long" dir="out">
        <desc>
          Guest height at the time of the saved state was taken.
        </desc>
      </param>
      <param name="enabled" type="boolean" dir="out">
        <desc>
          Whether the monitor is enabled in the guest.
        </desc>
      </param>
    </method>

    <method name="querySavedThumbnailSize">
      <desc>
        Returns size in bytes and dimensions in pixels of a saved thumbnail bitmap from saved state.
      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Saved guest screen to query info from.
        </desc>
      </param>
      <param name="size" type="unsigned long" dir="out">
        <desc>
          Size of buffer required to store the bitmap.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="out">
        <desc>
          Bitmap width.
        </desc>
      </param>
      <param name="height" type="unsigned long" dir="out">
        <desc>
          Bitmap height.
        </desc>
      </param>
    </method>

    <method name="readSavedThumbnailToArray">
      <desc>
        Thumbnail is retrieved to an array of bytes in uncompressed 32-bit BGRA or RGBA format.
      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Saved guest screen to read from.
        </desc>
      </param>
      <param name="BGR" type="boolean" dir="in">
        <desc>
          How to order bytes in the pixel. A pixel consists of 4 bytes. If this parameter is true, then
          bytes order is: B, G, R, 0xFF. If this parameter is false, then bytes order is: R, G, B, 0xFF.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="out">
        <desc>
          Bitmap width.
        </desc>
      </param>
      <param name="height" type="unsigned long" dir="out">
        <desc>
          Bitmap height.
        </desc>
      </param>
      <param name="data" type="octet" safearray="yes" dir="return">
        <desc>
          Array with resulting bitmap data.
        </desc>
      </param>
    </method>

    <method name="readSavedThumbnailPNGToArray">
      <desc>
        Thumbnail in PNG format is retrieved to an array of bytes.
      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Saved guest screen to read from.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="out">
        <desc>
          Image width.
        </desc>
      </param>
      <param name="height" type="unsigned long" dir="out">
        <desc>
          Image height.
        </desc>
      </param>
      <param name="data" type="octet" dir="return" safearray="yes">
        <desc>
          Array with resulting PNG data.
        </desc>
      </param>
    </method>

    <method name="querySavedScreenshotPNGSize">
      <desc>
        Returns size in bytes and dimensions of a saved PNG image of screenshot from saved state.
      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Saved guest screen to query info from.
        </desc>
      </param>
      <param name="size" type="unsigned long" dir="out">
        <desc>
          Size of buffer required to store the PNG binary data.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="out">
        <desc>
          Image width.
        </desc>
      </param>
      <param name="height" type="unsigned long" dir="out">
        <desc>
          Image height.
        </desc>
      </param>
    </method>

    <method name="readSavedScreenshotPNGToArray">
      <desc>
        Screenshot in PNG format is retrieved to an array of bytes.
      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Saved guest screen to read from.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="out">
        <desc>
          Image width.
        </desc>
      </param>
      <param name="height" type="unsigned long" dir="out">
        <desc>
          Image height.
        </desc>
      </param>
      <param name="data" type="octet" dir="return" safearray="yes">
        <desc>
          Array with resulting PNG data.
        </desc>
      </param>
    </method>

    <method name="hotPlugCPU">
      <desc>
        Plugs a CPU into the machine.
      </desc>
      <param name="cpu" type="unsigned long" dir="in">
        <desc>
          The CPU id to insert.
        </desc>
      </param>
    </method>

    <method name="hotUnplugCPU">
      <desc>
        Removes a CPU from the machine.
      </desc>
      <param name="cpu" type="unsigned long" dir="in">
        <desc>
          The CPU id to remove.
        </desc>
      </param>
    </method>

    <method name="getCPUStatus">
      <desc>
        Returns the current status of the given CPU.
      </desc>
      <param name="cpu" type="unsigned long" dir="in">
        <desc>
          The CPU id to check for.
        </desc>
      </param>
      <param name="attached" type="boolean" dir="return">
        <desc>
          Status of the CPU.
        </desc>
      </param>
    </method>

    <method name="queryLogFilename">
      <desc>
        Queries for the VM log file name of an given index. Returns an empty
        string if a log file with that index doesn't exists.
      </desc>
      <param name="idx" type="unsigned long" dir="in">
        <desc>
          Which log file name to query. 0=current log file.
        </desc>
      </param>
      <param name="filename" type="wstring" dir="return">
        <desc>
          On return the full path to the log file or an empty string on error.
        </desc>
      </param>
    </method>

    <method name="readLog">
      <desc>
        Reads the VM log file. The chunk size is limited, so even if you
        ask for a big piece there might be less data returned.
      </desc>
      <param name="idx" type="unsigned long" dir="in">
        <desc>
          Which log file to read. 0=current log file.
        </desc>
      </param>
      <param name="offset" type="long long" dir="in">
        <desc>
          Offset in the log file.
        </desc>
      </param>
      <param name="size" type="long long" dir="in">
        <desc>
          Chunk size to read in the log file.
        </desc>
      </param>
      <param name="data" type="octet" dir="return" safearray="yes">
        <desc>
          Data read from the log file. A data size of 0 means end of file
          if the requested chunk size was not 0. This is the unprocessed
          file data, i.e. the line ending style depends on the platform of
          the system the server is running on.
        </desc>
      </param>
    </method>

    <method name="cloneTo">
      <desc>
        Creates a clone of this machine, either as a full clone (which means
        creating independent copies of the hard disk media, save states and so
        on), or as a linked clone (which uses its own differencing media,
        sharing the parent media with the source machine).

        The target machine object must have been created previously with <link
          to="IVirtualBox::createMachine"/>, and all the settings will be
        transferred except the VM name and the hardware UUID. You can set the
        VM name and the new hardware UUID when creating the target machine. The
        network MAC addresses are newly created for all newtwork adapters. You
        can change that behaviour with the options parameter. The operation is
        performed asynchronously, so the machine object will be not be usable
        until the @a progress object signals completion.

        <result name="E_INVALIDARG">
          @a target is @c null.
        </result>
      </desc>

      <param name="target" type="IMachine" dir="in">
        <desc>Target machine object.</desc>
      </param>
      <param name="mode" type="CloneMode" dir="in">
        <desc>Which states should be cloned.</desc>
      </param>
      <param name="options" type="CloneOptions" dir="in" safearray="yes">
        <desc>Options for the cloning operation.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

  </interface>

  <!--
  // IConsole
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IVRDEServerInfo" extends="$unknown"
    uuid="714434a1-58c3-4aab-9049-7652c5df113b"
    wsmap="struct"
    >
    <desc>
      Contains information about the remote desktop (VRDE) server capabilities and status.
      This is used in the <link to="IConsole::VRDEServerInfo" /> attribute.
    </desc>

    <attribute name="active" type="boolean" readonly="yes">
      <desc>
        Whether the remote desktop connection is active.
      </desc>
    </attribute>

    <attribute name="port" type="long" readonly="yes">
      <desc>
        VRDE server port number. If this property is equal to <tt>0</tt>, then
        the VRDE server failed to start, usually because there are no free IP
        ports to bind to. If this property is equal to <tt>-1</tt>, then the VRDE
        server has not yet been started.
      </desc>
    </attribute>

    <attribute name="numberOfClients" type="unsigned long" readonly="yes">
      <desc>
        How many times a client connected.
      </desc>
    </attribute>

    <attribute name="beginTime" type="long long" readonly="yes">
      <desc>
        When the last connection was established, in milliseconds since 1970-01-01 UTC.
      </desc>
    </attribute>

    <attribute name="endTime" type="long long" readonly="yes">
      <desc>
        When the last connection was terminated or the current time, if
        connection is still active, in milliseconds since 1970-01-01 UTC.
      </desc>
    </attribute>

    <attribute name="bytesSent" type="long long" readonly="yes">
      <desc>
        How many bytes were sent in last or current, if still active, connection.
      </desc>
    </attribute>

    <attribute name="bytesSentTotal" type="long long" readonly="yes">
      <desc>
        How many bytes were sent in all connections.
      </desc>
    </attribute>

    <attribute name="bytesReceived" type="long long" readonly="yes">
      <desc>
        How many bytes were received in last or current, if still active, connection.
      </desc>
    </attribute>

    <attribute name="bytesReceivedTotal" type="long long" readonly="yes">
      <desc>
        How many bytes were received in all connections.
      </desc>
    </attribute>

    <attribute name="user" type="wstring" readonly="yes">
      <desc>
        Login user name supplied by the client.
      </desc>
    </attribute>

    <attribute name="domain" type="wstring" readonly="yes">
      <desc>
        Login domain name supplied by the client.
      </desc>
    </attribute>

    <attribute name="clientName" type="wstring" readonly="yes">
      <desc>
        The client name supplied by the client.
      </desc>
    </attribute>

    <attribute name="clientIP" type="wstring" readonly="yes">
      <desc>
        The IP address of the client.
      </desc>
    </attribute>

    <attribute name="clientVersion" type="unsigned long" readonly="yes">
      <desc>
        The client software version number.
      </desc>
    </attribute>

    <attribute name="encryptionStyle" type="unsigned long" readonly="yes">
      <desc>
        Public key exchange method used when connection was established.
        Values: 0 - RDP4 public key exchange scheme.
        1 - X509 certificates were sent to client.
      </desc>
    </attribute>

  </interface>

  <interface
    name="IConsole" extends="$unknown"
    uuid="db7ab4ca-2a3f-4183-9243-c1208da92392"
    wsmap="managed"
    >
    <desc>
      The IConsole interface represents an interface to control virtual
      machine execution.

      A console object gets created when a machine has been locked for a
      particular session (client process) using <link to="IMachine::lockMachine" />
      or <link to="IMachine::launchVMProcess"/>. The console object can
      then be found in the session's <link to="ISession::console" /> attribute.

      Methods of the IConsole interface allow the caller to query the current
      virtual machine execution state, pause the machine or power it down, save
      the machine state or take a snapshot, attach and detach removable media
      and so on.

      <see><link to="ISession"/></see>
    </desc>

    <attribute name="machine" type="IMachine" readonly="yes">
      <desc>
        Machine object for this console session.
        <note>
          This is a convenience property, it has the same value as
          <link to="ISession::machine"/> of the corresponding session
          object.
        </note>
      </desc>
    </attribute>

    <attribute name="state" type="MachineState" readonly="yes">
      <desc>
        Current execution state of the machine.
        <note>
          This property always returns the same value as the corresponding
          property of the IMachine object for this console session.
          For the process that owns (executes) the VM, this is the
          preferable way of querying the VM state, because no IPC
          calls are made.
        </note>
      </desc>
    </attribute>

    <attribute name="guest" type="IGuest" readonly="yes">
      <desc>Guest object.</desc>
    </attribute>

    <attribute name="keyboard" type="IKeyboard" readonly="yes">
      <desc>
        Virtual keyboard object.
        <note>
          If the machine is not running, any attempt to use
          the returned object will result in an error.
        </note>
      </desc>
    </attribute>

    <attribute name="mouse" type="IMouse" readonly="yes">
      <desc>
        Virtual mouse object.
        <note>
          If the machine is not running, any attempt to use
          the returned object will result in an error.
        </note>
      </desc>
    </attribute>

    <attribute name="display" type="IDisplay" readonly="yes">
      <desc>Virtual display object.
        <note>
          If the machine is not running, any attempt to use
          the returned object will result in an error.
        </note>
      </desc>
    </attribute>

    <attribute name="debugger" type="IMachineDebugger" readonly="yes">
      <desc>Debugging interface.</desc>
    </attribute>

    <attribute name="USBDevices" type="IUSBDevice" readonly="yes" safearray="yes">
      <desc>
        Collection of USB devices currently attached to the virtual
        USB controller.
        <note>
          The collection is empty if the machine is not running.
        </note>
      </desc>
    </attribute>

    <attribute name="remoteUSBDevices" type="IHostUSBDevice" readonly="yes" safearray="yes">
      <desc>
        List of USB devices currently attached to the remote VRDE client.
        Once a new device is physically attached to the remote host computer,
        it appears in this list and remains there until detached.
      </desc>
    </attribute>

    <attribute name="sharedFolders" type="ISharedFolder" readonly="yes" safearray="yes">
      <desc>
        Collection of shared folders for the current session.  These folders
        are called transient shared folders because they are available to the
        guest OS running inside the associated virtual machine only for the
        duration of the session (as opposed to
        <link to="IMachine::sharedFolders"/> which represent permanent shared
        folders). When the session is closed (e.g. the machine is powered down),
        these folders are automatically discarded.

        New shared folders are added to the collection using
        <link to="#createSharedFolder"/>. Existing shared folders can be
        removed using <link to="#removeSharedFolder"/>.
      </desc>
    </attribute>

    <attribute name="VRDEServerInfo" type="IVRDEServerInfo" readonly="yes">
      <desc>
        Interface that provides information on Remote Desktop Extension (VRDE) connection.
      </desc>
    </attribute>

    <attribute name="eventSource" type="IEventSource" readonly="yes">
      <desc>
        Event source for console events.
      </desc>
    </attribute>

    <attribute name="attachedPCIDevices" type="IPCIDeviceAttachment" readonly="yes" safearray="yes">
      <desc>Array of PCI devices attached to this machine.</desc>
    </attribute>

    <attribute name="useHostClipboard" type="boolean">
      <desc>
        Whether the guest clipboard should be connected to the host one or
        whether it should only be allowed access to the VRDE clipboard.  This
        setting may not affect existing guest clipboard connections which
        are already connected to the host clipboard.
      </desc>
    </attribute>

    <method name="powerUp">
      <desc>
        Starts the virtual machine execution using the current machine
        state (that is, its current execution state, current settings and
        current storage devices).

        <note>
          This method is only useful for front-ends that want to actually
          execute virtual machines in their own process (like the VirtualBox
          or VBoxSDL front-ends). Unless you are intending to write such a
          front-end, do not call this method.  If you simply want to
          start virtual machine execution using one of the existing front-ends
          (for example the VirtualBox GUI or headless server), use
          <link to="IMachine::launchVMProcess"/> instead; these
          front-ends will power up the machine automatically for you.
        </note>

        If the machine is powered off or aborted, the execution will
        start from the beginning (as if the real hardware were just
        powered on).

        If the machine is in the <link to="MachineState_Saved"/> state,
        it will continue its execution the point where the state has
        been saved.

        If the machine <link to="IMachine::teleporterEnabled"/> property is
        enabled on the machine being powered up, the machine will wait for an
        incoming teleportation in the <link to="MachineState_TeleportingIn"/>
        state. The returned progress object will have at least three
        operations where the last three are defined as: (1) powering up and
        starting TCP server, (2) waiting for incoming teleportations, and
        (3) perform teleportation. These operations will be reflected as the
        last three operations of the progress objected returned by
        <link to="IMachine::launchVMProcess"/> as well.

        <see><link to="#saveState"/></see>

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine already running.
        </result>
        <result name="VBOX_E_HOST_ERROR">
          Host interface does not exist or name not set.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Invalid saved state file.
        </result>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="powerUpPaused">
      <desc>
        Identical to powerUp except that the VM will enter the
        <link to="MachineState_Paused"/> state, instead of
        <link to="MachineState_Running"/>.

        <see><link to="#powerUp"/></see>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine already running.
        </result>
        <result name="VBOX_E_HOST_ERROR">
          Host interface does not exist or name not set.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Invalid saved state file.
        </result>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="powerDown">
      <desc>
        Initiates the power down procedure to stop the virtual machine
        execution.

        The completion of the power down procedure is tracked using the returned
        IProgress object. After the operation is complete, the machine will go
        to the PoweredOff state.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine must be Running, Paused or Stuck to be powered down.
        </result>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="reset">
      <desc>Resets the virtual machine.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in Running state.
        </result>
        <result name="VBOX_E_VM_ERROR">
          Virtual machine error in reset operation.
        </result>
      </desc>
    </method>

    <method name="pause">
      <desc>Pauses the virtual machine execution.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in Running state.
        </result>
        <result name="VBOX_E_VM_ERROR">
          Virtual machine error in suspend operation.
        </result>
      </desc>
    </method>

    <method name="resume">
      <desc>Resumes the virtual machine execution.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in Paused state.
        </result>
        <result name="VBOX_E_VM_ERROR">
          Virtual machine error in resume operation.
        </result>
      </desc>
    </method>

    <method name="powerButton">
      <desc>Sends the ACPI power button event to the guest.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in Running state.
        </result>
        <result name="VBOX_E_PDM_ERROR">
          Controlled power off failed.
        </result>
      </desc>
    </method>

    <method name="sleepButton">
      <desc>Sends the ACPI sleep button event to the guest.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in Running state.
        </result>
        <result name="VBOX_E_PDM_ERROR">
          Sending sleep button event failed.
        </result>
      </desc>
    </method>

    <method name="getPowerButtonHandled">
      <desc>Checks if the last power button event was handled by guest.
        <result name="VBOX_E_PDM_ERROR">
          Checking if the event was handled by the guest OS failed.
        </result>
      </desc>
      <param name="handled" type="boolean" dir="return"/>
    </method>

    <method name="getGuestEnteredACPIMode">
      <desc>Checks if the guest entered the ACPI mode G0 (working) or
        G1 (sleeping). If this method returns @c false, the guest will
        most likely not respond to external ACPI events.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in Running state.
        </result>
      </desc>
      <param name="entered" type="boolean" dir="return"/>
    </method>

    <method name="saveState">
      <desc>
        Saves the current execution state of a running virtual machine
        and stops its execution.

        After this operation completes, the machine will go to the
        Saved state. Next time it is powered up, this state will
        be restored and the machine will continue its execution from
        the place where it was saved.

        This operation differs from taking a snapshot to the effect
        that it doesn't create new differencing media. Also, once
        the machine is powered up from the state saved using this method,
        the saved state is deleted, so it will be impossible to return
        to this state later.

        <note>
          On success, this method implicitly calls
          <link to="IMachine::saveSettings"/> to save all current machine
          settings (including runtime changes to the DVD medium, etc.).
          Together with the impossibility to change any VM settings when it is
          in the Saved state, this guarantees adequate hardware
          configuration of the machine when it is restored from the saved
          state file.
        </note>

        <note>
          The machine must be in the Running or Paused state, otherwise
          the operation will fail.
        </note>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine state neither Running nor Paused.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Failed to create directory for saved state file.
        </result>

        <see><link to="#takeSnapshot"/></see>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="adoptSavedState">
      <desc>
        Associates the given saved state file to the virtual machine.

        On success, the machine will go to the Saved state. Next time it is
        powered up, it will be restored from the adopted saved state and
        continue execution from the place where the saved state file was
        created.

        The specified saved state file path may be absolute or relative to the
        folder the VM normally saves the state to (usually,
        <link to="IMachine::snapshotFolder"/>).

        <note>
          It's a caller's responsibility to make sure the given saved state
          file is compatible with the settings of this virtual machine that
          represent its virtual hardware (memory size, storage disk configuration
          etc.). If there is a mismatch, the behavior of the virtual machine
          is undefined.
        </note>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine state neither PoweredOff nor Aborted.
        </result>
      </desc>
      <param name="savedStateFile" type="wstring" dir="in">
        <desc>Path to the saved state file to adopt.</desc>
      </param>
    </method>

    <method name="discardSavedState">
      <desc>
        Forcibly resets the machine to "Powered Off" state if it is
        currently in the "Saved" state (previously created by <link to="#saveState"/>).
        Next time the machine is powered up, a clean boot will occur.
        <note>
          This operation is equivalent to resetting or powering off
          the machine without doing a proper shutdown of the guest
          operating system; as with resetting a running phyiscal
          computer, it can can lead to data loss.
        </note>
        If @a fRemoveFile is @c true, the file in the machine directory
        into which the machine state was saved is also deleted. If
        this is @c false, then the state can be recovered and later
        re-inserted into a machine using <link to="#adoptSavedState" />.
        The location of the file can be found in the
        <link to="IMachine::stateFilePath" /> attribute.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in state Saved.
        </result>
      </desc>
      <param name="fRemoveFile" type="boolean" dir="in" >
        <desc>Whether to also remove the saved state file.</desc>
      </param>
    </method>

    <method name="getDeviceActivity">
      <desc>
        Gets the current activity type of a given device or device group.
        <result name="E_INVALIDARG">
          Invalid device type.
        </result>
      </desc>
      <param name="type" type="DeviceType" dir="in"/>
      <param name="activity" type="DeviceActivity" dir="return"/>
    </method>

    <method name="attachUSBDevice">
      <desc>
        Attaches a host USB device with the given UUID to the
        USB controller of the virtual machine.

        The device needs to be in one of the following states:
        <link to="USBDeviceState_Busy"/>,
        <link to="USBDeviceState_Available"/> or
        <link to="USBDeviceState_Held"/>,
        otherwise an error is immediately returned.

        When the device state is
        <link to="USBDeviceState_Busy">Busy</link>, an error may also
        be returned if the host computer refuses to release it for some reason.

        <see><link to="IUSBController::deviceFilters"/>,
          <link to="USBDeviceState"/></see>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine state neither Running nor Paused.
        </result>
        <result name="VBOX_E_PDM_ERROR">
          Virtual machine does not have a USB controller.
        </result>
      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the host USB device to attach.</desc>
      </param>
    </method>

    <method name="detachUSBDevice">
      <desc>
        Detaches an USB device with the given UUID from the USB controller
        of the virtual machine.

        After this method succeeds, the VirtualBox server re-initiates
        all USB filters as if the device were just physically attached
        to the host, but filters of this machine are ignored to avoid
        a possible automatic re-attachment.

        <see><link to="IUSBController::deviceFilters"/>,
          <link to="USBDeviceState"/></see>

        <result name="VBOX_E_PDM_ERROR">
          Virtual machine does not have a USB controller.
        </result>
        <result name="E_INVALIDARG">
          USB device not attached to this virtual machine.
        </result>
      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the USB device to detach.</desc>
      </param>
      <param name="device" type="IUSBDevice" dir="return">
        <desc>Detached USB device.</desc>
      </param>
    </method>

    <method name="findUSBDeviceByAddress">
      <desc>
        Searches for a USB device with the given host address.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Given @c name does not correspond to any USB device.
        </result>

        <see><link to="IUSBDevice::address"/></see>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          Address of the USB device (as assigned by the host) to
          search for.
        </desc>
      </param>
      <param name="device" type="IUSBDevice" dir="return">
        <desc>Found USB device object.</desc>
      </param>
    </method>

    <method name="findUSBDeviceById">
      <desc>
        Searches for a USB device with the given UUID.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Given @c id does not correspond to any USB device.
        </result>

        <see><link to="IUSBDevice::id"/></see>
      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the USB device to search for.</desc>
      </param>
      <param name="device" type="IUSBDevice" dir="return">
        <desc>Found USB device object.</desc>
      </param>
    </method>

    <method name="createSharedFolder">
      <desc>
        Creates a transient new shared folder by associating the given logical
        name with the given host path, adds it to the collection of shared
        folders and starts sharing it. Refer to the description of
        <link to="ISharedFolder"/> to read more about logical names.

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine in Saved state or currently changing state.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Shared folder already exists or not accessible.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Unique logical name of the shared folder.</desc>
      </param>
      <param name="hostPath" type="wstring" dir="in">
        <desc>Full path to the shared folder in the host file system.</desc>
      </param>
      <param name="writable" type="boolean" dir="in">
        <desc>Whether the share is writable or readonly</desc>
      </param>
      <param name="automount" type="boolean" dir="in">
        <desc>Whether the share gets automatically mounted by the guest
          or not.</desc>
      </param>
    </method>

    <method name="removeSharedFolder">
      <desc>
        Removes a transient shared folder with the given name previously
        created by <link to="#createSharedFolder"/> from the collection of
        shared folders and stops sharing it.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine in Saved state or currently changing state.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Shared folder does not exists.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Logical name of the shared folder to remove.</desc>
      </param>
    </method>

    <method name="takeSnapshot">
      <desc>
        Saves the current execution state
        and all settings of the machine and creates differencing images
        for all normal (non-independent) media.
        See <link to="ISnapshot" /> for an introduction to snapshots.

        This method can be called for a PoweredOff, Saved (see
        <link to="#saveState"/>), Running or
        Paused virtual machine. When the machine is PoweredOff, an
        offline snapshot is created. When the machine is Running a live
        snapshot is created, and an online snapshot is created when Paused.

        The taken snapshot is always based on the
        <link to="IMachine::currentSnapshot">current snapshot</link>
        of the associated virtual machine and becomes a new current snapshot.

        <note>
          This method implicitly calls <link to="IMachine::saveSettings"/> to
          save all current machine settings before taking an offline snapshot.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine currently changing state.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Short name for the snapshot.</desc>
      </param>
      <param name="description" type="wstring" dir="in">
        <desc>Optional description of the snapshot.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="deleteSnapshot">
      <desc>
        Starts deleting the specified snapshot asynchronously.
        See <link to="ISnapshot" /> for an introduction to snapshots.

        The execution state and settings of the associated machine stored in
        the snapshot will be deleted. The contents of all differencing media of
        this snapshot will be merged with the contents of their dependent child
        media to keep the medium chain valid (in other words, all changes
        represented by media being deleted will be propagated to their child
        medium). After that, this snapshot's differencing medium will be
        deleted. The parent of this snapshot will become a new parent for all
        its child snapshots.

        If the deleted snapshot is the current one, its parent snapshot will
        become a new current snapshot. The current machine state is not directly
        affected in this case, except that currently attached differencing
        media based on media of the deleted snapshot will be also merged as
        described above.

        If the deleted snapshot is the first or current snapshot, then the
        respective IMachine attributes will be adjusted. Deleting the current
        snapshot will also implicitly call <link to="IMachine::saveSettings"/>
        to make all current machine settings permanent.

        Deleting a snapshot has the following preconditions:

        <ul>
          <li>Child media of all normal media of the deleted snapshot
          must be accessible (see <link to="IMedium::state"/>) for this
          operation to succeed. If only one running VM refers to all images
          which participates in merging the operation can be performed while
          the VM is running. Otherwise all virtual machines whose media are
          directly or indirectly based on the media of deleted snapshot must
          be powered off. In any case, online snapshot deleting usually is
          slower than the same operation without any running VM.</li>

          <li>You cannot delete the snapshot if a medium attached to it has
          more than one child medium (differencing images) because otherwise
          merging would be impossible. This might be the case if there is
          more than one child snapshot or differencing images were created
          for other reason (e.g. implicitly because of multiple machine
          attachments).</li>
        </ul>

        The virtual machine's <link to="IMachine::state">state</link> is
        changed to "DeletingSnapshot", "DeletingSnapshotOnline" or
        "DeletingSnapshotPaused" while this operation is in progress.

        <note>
          Merging medium contents can be very time and disk space
          consuming, if these media are big in size and have many
          children. However, if the snapshot being deleted is the last
          (head) snapshot on the branch, the operation will be rather
          quick.
        </note>
        <result name="VBOX_E_INVALID_VM_STATE">
          The running virtual machine prevents deleting this snapshot. This
          happens only in very specific situations, usually snapshots can be
          deleted without trouble while a VM is running. The error message
          text explains the reason for the failure.
        </result>
      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the snapshot to delete.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="deleteSnapshotAndAllChildren">
      <desc>
        Starts deleting the specified snapshot and all its children
        asynchronously. See <link to="ISnapshot" /> for an introduction to
        snapshots. The conditions and many details are the same as with
        <link to="#deleteSnapshot"/>.

        This operation is very fast if the snapshot subtree does not include
        the current state. It is still significantly faster than deleting the
        snapshots one by one if the current state is in the subtree and there
        are more than one snapshots from current state to the snapshot which
        marks the subtree, since it eliminates the incremental image merging.

        <note>This API method is right now not implemented!</note>

        <result name="VBOX_E_INVALID_VM_STATE">
          The running virtual machine prevents deleting this snapshot. This
          happens only in very specific situations, usually snapshots can be
          deleted without trouble while a VM is running. The error message
          text explains the reason for the failure.
        </result>
        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the snapshot to delete, including all its children.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="deleteSnapshotRange">
      <desc>
        Starts deleting the specified snapshot range. This is limited to
        linear snapshot lists, which means there may not be any other child
        snapshots other than the direct sequence between the start and end
        snapshot. If the start and end snapshot point to the same snapshot this
        method is completely equivalent to <link to="#deleteSnapshot"/>. See
        <link to="ISnapshot" /> for an introduction to snapshots. The
        conditions and many details are the same as with
        <link to="#deleteSnapshot"/>.

        This operation is generally faster than deleting snapshots one by one
        and often also needs less extra disk space before freeing up disk space
        by deleting the removed disk images corresponding to the snapshot.

        <note>This API method is right now not implemented!</note>

        <result name="VBOX_E_INVALID_VM_STATE">
          The running virtual machine prevents deleting this snapshot. This
          happens only in very specific situations, usually snapshots can be
          deleted without trouble while a VM is running. The error message
          text explains the reason for the failure.
        </result>
        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="startId" type="uuid" mod="string" dir="in">
        <desc>UUID of the first snapshot to delete.</desc>
      </param>
      <param name="endId" type="uuid" mod="string" dir="in">
        <desc>UUID of the last snapshot to delete.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="restoreSnapshot">
      <desc>
        Starts resetting the machine's current state to the state contained
        in the given snapshot, asynchronously. All current settings of the
        machine will be reset and changes stored in differencing media
        will be lost.
        See <link to="ISnapshot" /> for an introduction to snapshots.

        After this operation is successfully completed, new empty differencing
        media are created for all normal media of the machine.

        If the given snapshot is an online snapshot, the machine will go to
        the <link to="MachineState_Saved"> saved state</link>, so that the
        next time it is powered on, the execution state will be restored
        from the state of the snapshot.

        <note>
          The machine must not be running, otherwise the operation will fail.
        </note>

        <note>
          If the machine state is <link to="MachineState_Saved">Saved</link>
          prior to this operation, the saved state file will be implicitly
          deleted (as if <link to="IConsole::discardSavedState"/> were
          called).
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is running.
        </result>
      </desc>
      <param name="snapshot" type="ISnapshot" dir="in">
        <desc>The snapshot to restore the VM state from.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="teleport">
      <desc>
        Teleport the VM to a different host machine or process.

        TODO explain the details.

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not running or paused.
        </result>
      </desc>
      <param name="hostname" type="wstring" dir="in">
        <desc>The name or IP of the host to teleport to.</desc>
      </param>
      <param name="tcpport" type="unsigned long" dir="in">
        <desc>The TCP port to connect to (1..65535).</desc>
      </param>
      <param name="password" type="wstring" dir="in">
        <desc>The password.</desc>
      </param>
      <param name="maxDowntime" type="unsigned long" dir="in">
        <desc>
          The maximum allowed downtime given as milliseconds.  0 is not a valid
          value.  Recommended value: 250 ms.

          The higher the value is, the greater the chance for a successful
          teleportation.  A small value may easily result in the teleportation
          process taking hours and eventually fail.

          <note>
            The current implementation treats this a guideline, not as an
            absolute rule.
          </note>
        </desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

  </interface>

  <!--
  // IHost
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="HostNetworkInterfaceMediumType"
    uuid="1aa54aaf-2497-45a2-bfb1-8eb225e93d5b"
    >
    <desc>
      Type of encapsulation. Ethernet encapsulation includes both wired and
      wireless Ethernet connections.
      <see><link to="IHostNetworkInterface"/></see>
    </desc>

    <const name="Unknown" value="0">
      <desc>
        The type of interface cannot be determined.
      </desc>
    </const>
    <const name="Ethernet" value="1">
      <desc>
        Ethernet frame encapsulation.
      </desc>
    </const>
    <const name="PPP" value="2">
      <desc>
        Point-to-point protocol encapsulation.
      </desc>
    </const>
    <const name="SLIP" value="3">
      <desc>
        Serial line IP encapsulation.
      </desc>
    </const>
  </enum>

  <enum
    name="HostNetworkInterfaceStatus"
    uuid="CC474A69-2710-434B-8D99-C38E5D5A6F41"
    >
    <desc>
      Current status of the interface.
      <see><link to="IHostNetworkInterface"/></see>
    </desc>

    <const name="Unknown" value="0">
      <desc>
        The state of interface cannot be determined.
      </desc>
    </const>
    <const name="Up" value="1">
      <desc>
        The interface is fully operational.
      </desc>
    </const>
    <const name="Down" value="2">
      <desc>
        The interface is not functioning.
      </desc>
    </const>
  </enum>

  <enum
    name="HostNetworkInterfaceType"
    uuid="67431b00-9946-48a2-bc02-b25c5919f4f3"
    >
    <desc>
      Network interface type.
    </desc>
    <const name="Bridged"               value="1"/>
    <const name="HostOnly"              value="2"/>
  </enum>

  <interface
    name="IHostNetworkInterface" extends="$unknown"
    uuid="87a4153d-6889-4dd6-9654-2e9ff0ae8dec"
    wsmap="managed"
    >
    <desc>
      Represents one of host's network interfaces. IP V6 address and network
      mask are strings of 32 hexdecimal digits grouped by four. Groups are
      separated by colons.
      For example, fe80:0000:0000:0000:021e:c2ff:fed2:b030.
    </desc>
    <attribute name="name" type="wstring" readonly="yes">
      <desc>Returns the host network interface name.</desc>
    </attribute>

    <attribute name="id" type="uuid" mod="string" readonly="yes">
      <desc>Returns the interface UUID.</desc>
    </attribute>

    <attribute name="networkName" type="wstring" readonly="yes">
      <desc>Returns the name of a virtual network the interface gets attached to.</desc>
    </attribute>

    <attribute name="DHCPEnabled" type="boolean" readonly="yes">
      <desc>Specifies whether the DHCP is enabled for the interface.</desc>
    </attribute>

    <attribute name="IPAddress" type="wstring" readonly="yes">
      <desc>Returns the IP V4 address of the interface.</desc>
    </attribute>

    <attribute name="networkMask" type="wstring" readonly="yes">
      <desc>Returns the network mask of the interface.</desc>
    </attribute>

    <attribute name="IPV6Supported" type="boolean" readonly="yes">
      <desc>Specifies whether the IP V6 is supported/enabled for the interface.</desc>
    </attribute>

    <attribute name="IPV6Address" type="wstring" readonly="yes">
      <desc>Returns the IP V6 address of the interface.</desc>
    </attribute>

    <attribute name="IPV6NetworkMaskPrefixLength" type="unsigned long" readonly="yes">
      <desc>Returns the length IP V6 network mask prefix of the interface.</desc>
    </attribute>

    <attribute name="hardwareAddress" type="wstring" readonly="yes">
      <desc>Returns the hardware address. For Ethernet it is MAC address.</desc>
    </attribute>

    <attribute name="mediumType" type="HostNetworkInterfaceMediumType" readonly="yes">
      <desc>Type of protocol encapsulation used.</desc>
    </attribute>

    <attribute name="status" type="HostNetworkInterfaceStatus" readonly="yes">
      <desc>Status of the interface.</desc>
    </attribute>

    <attribute name="interfaceType" type="HostNetworkInterfaceType" readonly="yes">
      <desc>specifies the host interface type.</desc>
    </attribute>

    <method name="enableStaticIPConfig">
      <desc>sets and enables the static IP V4 configuration for the given interface.</desc>
      <param name="IPAddress" type="wstring" dir="in">
        <desc>
          IP address.
        </desc>
      </param>
      <param name="networkMask" type="wstring" dir="in">
        <desc>
          network mask.
        </desc>
      </param>
    </method>

    <method name="enableStaticIPConfigV6">
      <desc>sets and enables the static IP V6 configuration for the given interface.</desc>
      <param name="IPV6Address" type="wstring" dir="in">
        <desc>
          IP address.
        </desc>
      </param>
      <param name="IPV6NetworkMaskPrefixLength" type="unsigned long" dir="in">
        <desc>
          network mask.
        </desc>
      </param>
    </method>

    <method name="enableDynamicIPConfig">
      <desc>enables the dynamic IP configuration.</desc>
    </method>

    <method name="DHCPRediscover">
      <desc>refreshes the IP configuration for DHCP-enabled interface.</desc>
    </method>

  </interface>

  <interface
    name="IHost" extends="$unknown"
    uuid="30678943-32df-4830-b413-931b25ac86a0"
    wsmap="managed"
    >
    <desc>
      The IHost interface represents the physical machine that this VirtualBox
      installation runs on.

      An object implementing this interface is returned by the
      <link to="IVirtualBox::host" /> attribute. This interface contains
      read-only information about the host's physical hardware (such as what
      processors and disks are available, what the host operating system is,
      and so on) and also allows for manipulating some of the host's hardware,
      such as global USB device filters and host interface networking.

    </desc>
    <attribute name="DVDDrives" type="IMedium" readonly="yes" safearray="yes">
      <desc>List of DVD drives available on the host.</desc>
    </attribute>

    <attribute name="floppyDrives" type="IMedium" readonly="yes" safearray="yes">
      <desc>List of floppy drives available on the host.</desc>
    </attribute>

    <attribute name="USBDevices" type="IHostUSBDevice" readonly="yes" safearray="yes">
      <desc>
        List of USB devices currently attached to the host.
        Once a new device is physically attached to the host computer,
        it appears in this list and remains there until detached.

        <note>
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>
      </desc>
    </attribute>

    <attribute name="USBDeviceFilters" type="IHostUSBDeviceFilter" readonly="yes" safearray="yes">
      <desc>
        List of USB device filters in action.
        When a new device is physically attached to the host computer,
        filters from this list are applied to it (in order they are stored
        in the list). The first matched filter will determine the
        <link to="IHostUSBDeviceFilter::action">action</link>
        performed on the device.

        Unless the device is ignored by these filters, filters of all
        currently running virtual machines
        (<link to="IUSBController::deviceFilters"/>) are applied to it.

        <note>
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>

        <see><link to="IHostUSBDeviceFilter"/>,
          <link to="USBDeviceState"/></see>
      </desc>
    </attribute>

    <attribute name="networkInterfaces" type="IHostNetworkInterface" safearray="yes" readonly="yes">
      <desc>List of host network interfaces currently defined on the host.</desc>
    </attribute>

    <attribute name="processorCount" type="unsigned long" readonly="yes">
      <desc>Number of (logical) CPUs installed in the host system.</desc>
    </attribute>

    <attribute name="processorOnlineCount" type="unsigned long" readonly="yes">
      <desc>Number of (logical) CPUs online in the host system.</desc>
    </attribute>

    <attribute name="processorCoreCount" type="unsigned long" readonly="yes">
      <desc>Number of physical processor cores installed in the host system.</desc>
    </attribute>

    <method name="getProcessorSpeed">
      <desc>Query the (approximate) maximum speed of a specified host CPU in
        Megahertz.
      </desc>
      <param name="cpuId" type="unsigned long" dir="in">
        <desc>
          Identifier of the CPU.
        </desc>
      </param>
      <param name="speed" type="unsigned long" dir="return">
        <desc>
          Speed value. 0 is returned if value is not known or @a cpuId is
          invalid.
        </desc>
      </param>
    </method>

    <method name="getProcessorFeature">
      <desc>Query whether a CPU feature is supported or not.</desc>
      <param name="feature" type="ProcessorFeature" dir="in">
        <desc>
          CPU Feature identifier.
        </desc>
      </param>
      <param name="supported" type="boolean" dir="return">
        <desc>
          Feature is supported or not.
        </desc>
      </param>
    </method>

    <method name="getProcessorDescription">
      <desc>Query the model string of a specified host CPU.
      </desc>
      <param name="cpuId" type="unsigned long" dir="in">
        <desc>
          Identifier of the CPU.
          <note>
            The current implementation might not necessarily return the
            description for this exact CPU.
          </note>
        </desc>
      </param>
      <param name="description" type="wstring" dir="return">
        <desc>
          Model string. An empty string is returned if value is not known or
          @a cpuId is invalid.
        </desc>
      </param>
    </method>

    <method name="getProcessorCPUIDLeaf">
      <desc>
        Returns the CPU cpuid information for the specified leaf.
      </desc>
      <param name="cpuId" type="unsigned long" dir="in">
        <desc>
          Identifier of the CPU.  The CPU most be online.
          <note>
            The current implementation might not necessarily return the
            description for this exact CPU.
          </note>
        </desc>
      </param>
      <param name="leaf" type="unsigned long" dir="in">
        <desc>
          CPUID leaf index (eax).
        </desc>
      </param>
      <param name="subLeaf" type="unsigned long" dir="in">
        <desc>
          CPUID leaf sub index (ecx).  This currently only applies to cache
          information on Intel CPUs.  Use 0 if retrieving values for
          <link to="IMachine::setCPUIDLeaf"/>.
        </desc>
      </param>
      <param name="valEax" type="unsigned long" dir="out">
        <desc>
          CPUID leaf value for register eax.
        </desc>
      </param>
      <param name="valEbx" type="unsigned long" dir="out">
        <desc>
          CPUID leaf value for register ebx.
        </desc>
      </param>
      <param name="valEcx" type="unsigned long" dir="out">
        <desc>
          CPUID leaf value for register ecx.
        </desc>
      </param>
      <param name="valEdx" type="unsigned long" dir="out">
        <desc>
          CPUID leaf value for register edx.
        </desc>
      </param>
    </method>

    <attribute name="memorySize" type="unsigned long" readonly="yes">
      <desc>Amount of system memory in megabytes installed in the host system.</desc>
    </attribute>

    <attribute name="memoryAvailable" type="unsigned long" readonly="yes">
      <desc>Available system memory in the host system.</desc>
    </attribute>

    <attribute name="operatingSystem" type="wstring" readonly="yes">
      <desc>Name of the host system's operating system.</desc>
    </attribute>

    <attribute name="OSVersion" type="wstring" readonly="yes">
      <desc>Host operating system's version string.</desc>
    </attribute>

    <attribute name="UTCTime" type="long long" readonly="yes">
      <desc>Returns the current host time in milliseconds since 1970-01-01 UTC.</desc>
    </attribute>

    <attribute name="acceleration3DAvailable" type="boolean" readonly="yes">
      <desc>Returns @c true when the host supports 3D hardware acceleration.</desc>
    </attribute>

    <method name="createHostOnlyNetworkInterface">
      <desc>
        Creates a new adapter for Host Only Networking.
        <result name="E_INVALIDARG">
          Host network interface @a name already exists.
        </result>
      </desc>
      <param name="hostInterface" type="IHostNetworkInterface" dir="out">
        <desc>
          Created host interface object.
        </desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>
          Progress object to track the operation completion.
        </desc>
      </param>
    </method>

    <method name="removeHostOnlyNetworkInterface">
      <desc>
        Removes the given Host Only Networking interface.
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No host network interface matching @a id found.
        </result>
      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>
          Adapter GUID.
        </desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>
          Progress object to track the operation completion.
        </desc>
      </param>
    </method>

    <method name="createUSBDeviceFilter">
      <desc>
        Creates a new USB device filter. All attributes except
        the filter name are set to empty (any match),
        <i>active</i> is @c false (the filter is not active).

        The created filter can be added to the list of filters using
        <link to="#insertUSBDeviceFilter"/>.

        <see><link to="#USBDeviceFilters"/></see>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          Filter name. See <link to="IUSBDeviceFilter::name"/> for more information.
        </desc>
      </param>
      <param name="filter" type="IHostUSBDeviceFilter" dir="return">
        <desc>Created filter object.</desc>
      </param>
    </method>

    <method name="insertUSBDeviceFilter">
      <desc>
        Inserts the given USB device to the specified position
        in the list of filters.

        Positions are numbered starting from @c 0. If the specified
        position is equal to or greater than the number of elements in
        the list, the filter is added at the end of the collection.

        <note>
          Duplicates are not allowed, so an attempt to insert a
          filter already in the list is an error.
        </note>
        <note>
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>

        <see><link to="#USBDeviceFilters"/></see>

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          USB device filter is not created within this VirtualBox instance.
        </result>
        <result name="E_INVALIDARG">
          USB device filter already in list.
        </result>

      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>Position to insert the filter to.</desc>
      </param>
      <param name="filter" type="IHostUSBDeviceFilter" dir="in">
        <desc>USB device filter to insert.</desc>
      </param>
    </method>

    <method name="removeUSBDeviceFilter">
      <desc>
        Removes a USB device filter from the specified position in the
        list of filters.

        Positions are numbered starting from @c 0. Specifying a
        position equal to or greater than the number of elements in
        the list will produce an error.

        <note>
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>

        <see><link to="#USBDeviceFilters"/></see>

        <result name="E_INVALIDARG">
          USB device filter list empty or invalid @a position.
        </result>

      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>Position to remove the filter from.</desc>
      </param>
    </method>

    <method name="findHostDVDDrive">
      <desc>
        Searches for a host DVD drive with the given @c name.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Given @c name does not correspond to any host drive.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the host drive to search for</desc>
      </param>
      <param name="drive" type="IMedium" dir="return">
        <desc>Found host drive object</desc>
      </param>
    </method>

    <method name="findHostFloppyDrive">
      <desc>
        Searches for a host floppy drive with the given @c name.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Given @c name does not correspond to any host floppy drive.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the host floppy drive to search for</desc>
      </param>
      <param name="drive" type="IMedium" dir="return">
        <desc>Found host floppy drive object</desc>
      </param>
    </method>

    <method name="findHostNetworkInterfaceByName">
      <desc>
        Searches through all host network interfaces for an interface with
        the given @c name.
        <note>
          The method returns an error if the given @c name does not
          correspond to any host network interface.
        </note>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the host network interface to search for.</desc>
      </param>
      <param name="networkInterface" type="IHostNetworkInterface" dir="return">
        <desc>Found host network interface object.</desc>
      </param>
    </method>
    <method name="findHostNetworkInterfaceById">
      <desc>
        Searches through all host network interfaces for an interface with
        the given GUID.
        <note>
          The method returns an error if the given GUID does not
          correspond to any host network interface.
        </note>
      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>GUID of the host network interface to search for.</desc>
      </param>
      <param name="networkInterface" type="IHostNetworkInterface" dir="return">
        <desc>Found host network interface object.</desc>
      </param>
    </method>
    <method name="findHostNetworkInterfacesOfType">
      <desc>
        Searches through all host network interfaces and returns a list of interfaces of the specified type
      </desc>
      <param name="type" type="HostNetworkInterfaceType" dir="in">
        <desc>type of the host network interfaces to search for.</desc>
      </param>
      <param name="networkInterfaces" type="IHostNetworkInterface" safearray="yes" dir="return">
        <desc>Found host network interface objects.</desc>
      </param>
    </method>

    <method name="findUSBDeviceById">
      <desc>
        Searches for a USB device with the given UUID.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Given @c id does not correspond to any USB device.
        </result>

        <see><link to="IUSBDevice::id"/></see>
      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the USB device to search for.</desc>
      </param>
      <param name="device" type="IHostUSBDevice" dir="return">
        <desc>Found USB device object.</desc>
      </param>
    </method>

    <method name="findUSBDeviceByAddress">
      <desc>
        Searches for a USB device with the given host address.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Given @c name does not correspond to any USB device.
        </result>

        <see><link to="IUSBDevice::address"/></see>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          Address of the USB device (as assigned by the host) to
          search for.
        </desc>
      </param>
      <param name="device" type="IHostUSBDevice" dir="return">
        <desc>Found USB device object.</desc>
      </param>
    </method>

    <method name="generateMACAddress">
      <desc>
        Generates a valid Ethernet MAC address, 12 hexadecimal characters.
      </desc>
      <param name="address" type="wstring" dir="return">
        <desc>New Ethernet MAC address.</desc>
      </param>
    </method>

  </interface>

  <!--
  // ISystemProperties
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="ISystemProperties"
    extends="$unknown"
    uuid="1d7aca29-97f0-4287-9874-a60ec4f80ea6"
    wsmap="managed"
    >
    <desc>
      The ISystemProperties interface represents global properties of the given
      VirtualBox installation.

      These properties define limits and default values for various attributes
      and parameters. Most of the properties are read-only, but some can be
      changed by a user.
    </desc>

    <attribute name="minGuestRAM" type="unsigned long" readonly="yes">
      <desc>Minimum guest system memory in Megabytes.</desc>
    </attribute>

    <attribute name="maxGuestRAM" type="unsigned long" readonly="yes">
      <desc>Maximum guest system memory in Megabytes.</desc>
    </attribute>

    <attribute name="minGuestVRAM" type="unsigned long" readonly="yes">
      <desc>Minimum guest video memory in Megabytes.</desc>
    </attribute>

    <attribute name="maxGuestVRAM" type="unsigned long" readonly="yes">
      <desc>Maximum guest video memory in Megabytes.</desc>
    </attribute>

    <attribute name="minGuestCPUCount" type="unsigned long" readonly="yes">
      <desc>Minimum CPU count.</desc>
    </attribute>

    <attribute name="maxGuestCPUCount" type="unsigned long" readonly="yes">
      <desc>Maximum CPU count.</desc>
    </attribute>

    <attribute name="maxGuestMonitors" type="unsigned long" readonly="yes">
      <desc>Maximum of monitors which could be connected.</desc>
    </attribute>

    <attribute name="infoVDSize" type="long long" readonly="yes">
      <desc>Maximum size of a virtual disk image in bytes. Informational value,
      does not reflect the limits of any virtual disk image format.</desc>
    </attribute>

    <attribute name="serialPortCount" type="unsigned long" readonly="yes">
      <desc>
        Maximum number of serial ports associated with every
        <link to="IMachine"/> instance.
      </desc>
    </attribute>

    <attribute name="parallelPortCount" type="unsigned long" readonly="yes">
      <desc>
        Maximum number of parallel ports associated with every
        <link to="IMachine"/> instance.
      </desc>
    </attribute>

    <attribute name="maxBootPosition" type="unsigned long" readonly="yes">
      <desc>
        Maximum device position in the boot order. This value corresponds
        to the total number of devices a machine can boot from, to make it
        possible to include all possible devices to the boot list.
        <see><link to="IMachine::setBootOrder"/></see>
      </desc>
    </attribute>

    <attribute name="defaultMachineFolder" type="wstring">
      <desc>
        Full path to the default directory used to create new or open
        existing machines when a machine settings file name contains no
        path.

        Starting with VirtualBox 4.0, by default, this attribute contains
        the full path of folder named "VirtualBox VMs" in the user's
        home directory, which depends on the host platform.

        When setting this attribute, a full path must be specified.
        Setting this property to @c null or an empty string or the
        special value "Machines" (for compatibility reasons) will restore
        that default value.

        If the folder specified herein does not exist, it will be created
        automatically as needed.

        <see>
          <link to="IVirtualBox::createMachine"/>,
          <link to="IVirtualBox::openMachine"/>
        </see>
      </desc>
    </attribute>

    <attribute name="mediumFormats" type="IMediumFormat" safearray="yes" readonly="yes">
      <desc>
        List of all medium storage formats supported by this VirtualBox
        installation.

        Keep in mind that the medium format identifier
        (<link to="IMediumFormat::id"/>) used in other API calls like
        <link to="IVirtualBox::createHardDisk"/> to refer to a particular
        medium format is a case-insensitive string. This means that, for
        example, all of the following strings:
        <pre>
          "VDI"
          "vdi"
          "VdI"</pre>
        refer to the same medium format.

        Note that the virtual medium framework is backend-based, therefore
        the list of supported formats depends on what backends are currently
        installed.

        <see><link to="IMediumFormat"/></see>
      </desc>
    </attribute>

    <attribute name="defaultHardDiskFormat" type="wstring">
      <desc>
        Identifier of the default medium format used by VirtualBox.

        The medium format set by this attribute is used by VirtualBox
        when the medium format was not specified explicitly. One example is
        <link to="IVirtualBox::createHardDisk"/> with the empty
        format argument. A more complex example is implicit creation of
        differencing media when taking a snapshot of a virtual machine:
        this operation will try to use a format of the parent medium first
        and if this format does not support differencing media the default
        format specified by this argument will be used.

        The list of supported medium formats may be obtained by the
        <link  to="#mediumFormats"/> call. Note that the default medium
        format must have a capability to create differencing media;
        otherwise operations that create media implicitly may fail
        unexpectedly.

        The initial value of this property is <tt>"VDI"</tt> in the current
        version of the VirtualBox product, but may change in the future.

        <note>
          Setting this property to @c null or empty string will restore the
          initial value.
        </note>

        <see>
          <link to="#mediumFormats"/>,
          <link to="IMediumFormat::id"/>,
          <link to="IVirtualBox::createHardDisk"/>
        </see>
      </desc>
    </attribute>

    <attribute name="freeDiskSpaceWarning" type="long long">
      <desc>Issue a warning if the free disk space is below (or in some disk
      intensive operation is expected to go below) the given size in
      bytes.</desc>
    </attribute>

    <attribute name="freeDiskSpacePercentWarning" type="unsigned long">
      <desc>Issue a warning if the free disk space is below (or in some disk
      intensive operation is expected to go below) the given percentage.</desc>
    </attribute>

    <attribute name="freeDiskSpaceError" type="long long">
      <desc>Issue an error if the free disk space is below (or in some disk
      intensive operation is expected to go below) the given size in
      bytes.</desc>
    </attribute>

    <attribute name="freeDiskSpacePercentError" type="unsigned long">
      <desc>Issue an error if the free disk space is below (or in some disk
      intensive operation is expected to go below) the given percentage.</desc>
    </attribute>

    <attribute name="VRDEAuthLibrary" type="wstring">
      <desc>
        Library that provides authentication for Remote Desktop clients. The library
        is used if a virtual machine's authentication type is set to "external"
        in the VM RemoteDisplay configuration.

        The system library extension (".DLL" or ".so") must be omitted.
        A full path can be specified; if not, then the library must reside on the
        system's default library path.

        The default value of this property is <tt>"VBoxAuth"</tt>. There is a library
        of that name in one of the default VirtualBox library directories.

        For details about VirtualBox authentication libraries and how to implement
        them, please refer to the VirtualBox manual.

        <note>
          Setting this property to @c null or empty string will restore the
          initial value.
        </note>
      </desc>
    </attribute>

    <attribute name="webServiceAuthLibrary" type="wstring">
      <desc>
        Library that provides authentication for webservice clients. The library
        is used if a virtual machine's authentication type is set to "external"
        in the VM RemoteDisplay configuration and will be called from
        within the <link to="IWebsessionManager::logon" /> implementation.

        As opposed to <link to="ISystemProperties::VRDEAuthLibrary" />,
        there is no per-VM setting for this, as the webservice is a global
        resource (if it is running). Only for this setting (for the webservice),
        setting this value to a literal <tt>"null"</tt> string disables authentication,
        meaning that <link to="IWebsessionManager::logon" /> will always succeed,
        no matter what user name and password are supplied.

        The initial value of this property is <tt>"VBoxAuth"</tt>,
        meaning that the webservice will use the same authentication
        library that is used by default for VRDE (again, see
        <link to="ISystemProperties::VRDEAuthLibrary" />).
        The format and calling convention of authentication libraries
        is the same for the webservice as it is for VRDE.

        <note>
          Setting this property to @c null or empty string will restore the
          initial value.
        </note>
      </desc>
    </attribute>

    <attribute name="defaultVRDEExtPack" type="wstring">
      <desc>
        The name of the extension pack providing the default VRDE.

        This attribute is for choosing between multiple extension packs
        providing VRDE.  If only one is installed, it will automatically be the
        default one.  The attribute value can be empty if no VRDE extension
        pack is installed.

        For details about VirtualBox Remote Desktop Extension and how to
        implement one, please refer to the VirtualBox SDK.
      </desc>
    </attribute>

    <attribute name="logHistoryCount" type="unsigned long">
      <desc>
        This value specifies how many old release log files are kept.
      </desc>
    </attribute>

    <attribute name="defaultAudioDriver" type="AudioDriverType" readonly="yes">
      <desc>This value hold the default audio driver for the current
      system.</desc>
    </attribute>

    <attribute name="autostartDatabasePath" type="wstring">
      <desc>
        The path to the autostart database. Depending on the host this might
        be a filesystem path or something else.
      </desc>
    </attribute>

    <attribute name="defaultAdditionsISO" type="wstring">
      <desc>
        The path to the default Guest Additions ISO image. Can be empty if
        the location is not known in this installation.
      </desc>
    </attribute>

    <method name="getMaxNetworkAdapters">
      <desc>
        Maximum total number of network adapters associated with every
        <link to="IMachine"/> instance.
      </desc>

      <param name="chipset" type="ChipsetType" dir="in">
        <desc>The chipset type to get the value for.</desc>
      </param>


      <param name="maxNetworkAdapters" type="unsigned long" dir="return">
        <desc>The maximum total number of network adapters allowed.</desc>
      </param>

    </method>

    <method name="getMaxNetworkAdaptersOfType">
      <desc>
        Maximum number of network adapters of a given attachment type,
        associated with every <link to="IMachine"/> instance.
      </desc>

      <param name="chipset" type="ChipsetType" dir="in">
        <desc>The chipset type to get the value for.</desc>
      </param>

      <param name="type" type="NetworkAttachmentType" dir="in">
        <desc>Type of attachment.</desc>
      </param>

      <param name="maxNetworkAdapters" type="unsigned long" dir="return">
        <desc>The maximum number of network adapters allowed for
          particular chipset and attachment  type.</desc>
      </param>

    </method>


    <method name="getMaxDevicesPerPortForStorageBus">
      <desc>Returns the maximum number of devices which can be attached to a port
      for the given storage bus.</desc>

      <param name="bus" type="StorageBus" dir="in">
        <desc>The storage bus type to get the value for.</desc>
      </param>

      <param name="maxDevicesPerPort" type="unsigned long" dir="return">
        <desc>The maximum number of devices which can be attached to the port for the given
        storage bus.</desc>
      </param>
    </method>

    <method name="getMinPortCountForStorageBus">
      <desc>Returns the minimum number of ports the given storage bus supports.</desc>

      <param name="bus" type="StorageBus" dir="in">
        <desc>The storage bus type to get the value for.</desc>
      </param>

      <param name="minPortCount" type="unsigned long" dir="return">
        <desc>The minimum number of ports for the given storage bus.</desc>
      </param>
    </method>

    <method name="getMaxPortCountForStorageBus">
      <desc>Returns the maximum number of ports the given storage bus supports.</desc>

      <param name="bus" type="StorageBus" dir="in">
        <desc>The storage bus type to get the value for.</desc>
      </param>

      <param name="maxPortCount" type="unsigned long" dir="return">
        <desc>The maximum number of ports for the given storage bus.</desc>
      </param>
    </method>

    <method name="getMaxInstancesOfStorageBus">
      <desc>Returns the maximum number of storage bus instances which
        can be configured for each VM. This corresponds to the number of
        storage controllers one can have. Value may depend on chipset type
        used.</desc>

      <param name="chipset" type="ChipsetType" dir="in">
        <desc>The chipset type to get the value for.</desc>
      </param>

      <param name="bus" type="StorageBus" dir="in">
        <desc>The storage bus type to get the value for.</desc>
      </param>

      <param name="maxInstances" type="unsigned long" dir="return">
        <desc>The maximum number of instances for the given storage bus.</desc>
      </param>
    </method>

    <method name="getDeviceTypesForStorageBus">
      <desc>Returns list of all the supported device types
        (<link to="DeviceType"/>) for the given type of storage
        bus.</desc>

      <param name="bus" type="StorageBus" dir="in">
        <desc>The storage bus type to get the value for.</desc>
      </param>

      <param name="deviceTypes" type="DeviceType" safearray="yes" dir="return">
        <desc>The list of all supported device types for the given storage bus.</desc>
      </param>
    </method>

    <method name="getDefaultIoCacheSettingForStorageController">
      <desc>Returns the default I/O cache setting for the
        given storage controller</desc>

      <param name="controllerType" type="StorageControllerType" dir="in">
        <desc>The storage controller to the setting for.</desc>
      </param>

      <param name="enabled" type="boolean" dir="return">
        <desc>Returned flag indicating the default value</desc>
      </param>
    </method>
  </interface>

  <!--
  // IGuest
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IGuestOSType" extends="$unknown"
    uuid="6d968f9a-858b-4c50-bf17-241f069e94c2"
    wsmap="struct"
    >
    <desc>
    </desc>

    <attribute name="familyId" type="wstring" readonly="yes">
      <desc>Guest OS family identifier string.</desc>
    </attribute>

    <attribute name="familyDescription" type="wstring" readonly="yes">
      <desc>Human readable description of the guest OS family.</desc>
    </attribute>

    <attribute name="id" type="wstring" readonly="yes">
      <desc>Guest OS identifier string.</desc>
    </attribute>

    <attribute name="description" type="wstring" readonly="yes">
      <desc>Human readable description of the guest OS.</desc>
    </attribute>

    <attribute name="is64Bit" type="boolean" readonly="yes">
      <desc>Returns @c true if the given OS is 64-bit</desc>
    </attribute>

    <attribute name="recommendedIOAPIC" type="boolean" readonly="yes">
      <desc>Returns @c true if IO APIC recommended for this OS type.</desc>
    </attribute>

    <attribute name="recommendedVirtEx" type="boolean" readonly="yes">
      <desc>Returns @c true if VT-x or AMD-V recommended for this OS type.</desc>
    </attribute>

    <attribute name="recommendedRAM" type="unsigned long" readonly="yes">
      <desc>Recommended RAM size in Megabytes.</desc>
    </attribute>

    <attribute name="recommendedVRAM" type="unsigned long" readonly="yes">
      <desc>Recommended video RAM size in Megabytes.</desc>
    </attribute>

    <attribute name="recommended2DVideoAcceleration" type="boolean" readonly="yes">
      <desc>Returns @c true if 2D video acceleration is recommended for this OS type.</desc>
    </attribute>

    <attribute name="recommended3DAcceleration" type="boolean" readonly="yes">
      <desc>Returns @c true if 3D acceleration is recommended for this OS type.</desc>
    </attribute>

    <attribute name="recommendedHDD" type="long long" readonly="yes">
      <desc>Recommended hard disk size in bytes.</desc>
    </attribute>

    <attribute name="adapterType" type="NetworkAdapterType" readonly="yes">
      <desc>Returns recommended network adapter for this OS type.</desc>
    </attribute>

    <attribute name="recommendedPAE" type="boolean" readonly="yes">
      <desc>Returns @c true if using PAE is recommended for this OS type.</desc>
    </attribute>

    <attribute name="recommendedDVDStorageController" type="StorageControllerType" readonly="yes">
      <desc>Recommended storage controller type for DVD/CD drives.</desc>
    </attribute>

    <attribute name="recommendedDVDStorageBus" type="StorageBus" readonly="yes">
      <desc>Recommended storage bus type for DVD/CD drives.</desc>
    </attribute>

    <attribute name="recommendedHDStorageController" type="StorageControllerType" readonly="yes">
      <desc>Recommended storage controller type for HD drives.</desc>
    </attribute>

    <attribute name="recommendedHDStorageBus" type="StorageBus" readonly="yes">
      <desc>Recommended storage bus type for HD drives.</desc>
    </attribute>

    <attribute name="recommendedFirmware" type="FirmwareType" readonly="yes">
      <desc>Recommended firmware type.</desc>
    </attribute>

    <attribute name="recommendedUSBHID" type="boolean" readonly="yes">
      <desc>Returns @c true if using USB Human Interface Devices, such as keyboard and mouse recommended.</desc>
    </attribute>

    <attribute name="recommendedHPET" type="boolean" readonly="yes">
      <desc>Returns @c true if using HPET is recommended for this OS type.</desc>
    </attribute>

    <attribute name="recommendedUSBTablet" type="boolean" readonly="yes">
      <desc>Returns @c true if using a USB Tablet is recommended.</desc>
    </attribute>

    <attribute name="recommendedRTCUseUTC" type="boolean" readonly="yes">
      <desc>Returns @c true if the RTC of this VM should be set to UTC</desc>
    </attribute>

    <attribute name="recommendedChipset" type="ChipsetType" readonly="yes">
      <desc>Recommended chipset type.</desc>
    </attribute>

    <attribute name="recommendedAudioController" type="AudioControllerType" readonly="yes">
      <desc>Recommended audio type.</desc>
    </attribute>

    <attribute name="recommendedFloppy" type="boolean" readonly="yes">
      <desc>Returns @c true a floppy drive is recommended for this OS type.</desc>
    </attribute>

    <attribute name="recommendedUSB" type="boolean" readonly="yes">
      <desc>Returns @c true a USB controller is recommended for this OS type.</desc>
    </attribute>

  </interface>

  <enum
    name="AdditionsFacilityType"
    uuid="98f7f957-89fb-49b6-a3b1-31e3285eb1d8"
    >
    <desc>
      Guest Additions facility IDs.
    </desc>

    <const name="None"                    value="0">
      <desc>No/invalid facility.</desc>
    </const>
    <const name="VBoxGuestDriver"         value="20">
      <desc>VirtualBox base driver (VBoxGuest).</desc>
    </const>
    <const name="AutoLogon"               value="90">
      <desc>Auto-logon modules (VBoxGINA, VBoxCredProv, pam_vbox).</desc>
    </const>
    <const name="VBoxService"             value="100">
      <desc>VirtualBox system service (VBoxService).</desc>
    </const>
    <const name="VBoxTrayClient"          value="101">
      <desc>VirtualBox desktop integration (VBoxTray on Windows, VBoxClient on non-Windows).</desc>
    </const>
    <const name="Seamless"                value="1000">
      <desc>Seamless guest desktop integration.</desc>
    </const>
    <const name="Graphics"                value="1100">
      <desc>Guest graphics mode. If not enabled, seamless rendering will not work, resize hints
        are not immediately acted on and guest display resizes are probably not initiated by
        the guest additions.
      </desc>
    </const>
    <const name="All"                     value="2147483646">
      <desc>All facilities selected.</desc>
    </const>
  </enum>

  <enum
    name="AdditionsFacilityClass"
    uuid="446451b2-c88d-4e5d-84c9-91bc7f533f5f"
    >
    <desc>
      Guest Additions facility classes.
    </desc>

    <const name="None"                    value="0">
      <desc>No/invalid class.</desc>
    </const>
    <const name="Driver"                  value="10">
      <desc>Driver.</desc>
    </const>
    <const name="Service"                 value="30">
      <desc>System service.</desc>
    </const>
    <const name="Program"                 value="50">
      <desc>Program.</desc>
    </const>
    <const name="Feature"                 value="100">
      <desc>Feature.</desc>
    </const>
    <const name="ThirdParty"              value="999">
      <desc>Third party.</desc>
    </const>
    <const name="All"                     value="2147483646">
      <desc>All facility classes selected.</desc>
    </const>
  </enum>

  <enum
    name="AdditionsFacilityStatus"
    uuid="ce06f9e1-394e-4fe9-9368-5a88c567dbde"
    >
    <desc>
      Guest Additions facility states.
    </desc>

    <const name="Inactive"                value="0">
      <desc>Facility is not active.</desc>
    </const>
    <const name="Paused"                  value="1">
      <desc>Facility has been paused.</desc>
    </const>
    <const name="PreInit"                 value="20">
      <desc>Facility is preparing to initialize.</desc>
    </const>
    <const name="Init"                    value="30">
      <desc>Facility is initializing.</desc>
    </const>
    <const name="Active"                  value="50">
      <desc>Facility is up and running.</desc>
    </const>
    <const name="Terminating"             value="100">
      <desc>Facility is shutting down.</desc>
    </const>
    <const name="Terminated"              value="101">
      <desc>Facility successfully shut down.</desc>
    </const>
    <const name="Failed"                  value="800">
      <desc>Facility failed to start.</desc>
    </const>
    <const name="Unknown"                 value="999">
      <desc>Facility status is unknown.</desc>
    </const>
  </enum>

  <interface
    name="IAdditionsFacility" extends="$unknown"
    uuid="54992946-6af1-4e49-98ec-58b558b7291e"
    wsmap="struct"
    >
    <desc>
      Structure representing a Guest Additions facility.
    </desc>

    <attribute name="classType" type="AdditionsFacilityClass" readonly="yes">
      <desc>The class this facility is part of.</desc>
    </attribute>

    <attribute name="lastUpdated" type="long long" readonly="yes">
      <desc>
        Time stamp of the last status update,
        in milliseconds since 1970-01-01 UTC.
      </desc>
    </attribute>

    <attribute name="name" type="wstring" readonly="yes">
      <desc>The facility's friendly name.</desc>
    </attribute>

    <attribute name="status" type="AdditionsFacilityStatus" readonly="yes">
      <desc>The current status.</desc>
    </attribute>

    <attribute name="type" type="AdditionsFacilityType" readonly="yes">
      <desc>The facility's type ID.</desc>
    </attribute>
  </interface>

  <enum
    name="AdditionsRunLevelType"
    uuid="a25417ee-a9dd-4f5b-b0dc-377860087754"
    >
    <desc>
      Guest Additions run level type.
    </desc>

    <const name="None"                    value="0">
      <desc>Guest Additions are not loaded.</desc>
    </const>
    <const name="System"                  value="1">
      <desc>Guest drivers are loaded.</desc>
    </const>
    <const name="Userland"                value="2">
      <desc>Common components (such as application services) are loaded.</desc>
    </const>
    <const name="Desktop"                 value="3">
      <desc>Per-user desktop components are loaded.</desc>
    </const>
  </enum>

  <enum
    name="AdditionsUpdateFlag"
    uuid="726a818d-18d6-4389-94e8-3e9e6826171a"
  >
    <desc>
      Guest Additions update flags.
    </desc>

    <const name="None"                    value="0">
      <desc>No flag set.</desc>
    </const>
    <const name="WaitForUpdateStartOnly"  value="1">
      <desc>Starts the regular updating process and waits until the
        actual Guest Additions update inside the guest was started.
        This can be necessary due to needed interaction with the guest
        OS during the installation phase.</desc>
    </const>
  </enum>

  <enum
    name="FileSeekType"
    uuid="1b73f4f3-3515-4073-a506-76878d9e2541"
    >
    <desc>
      File seeking types.
    </desc>

    <const name="Set"                     value="0">
      <desc>Seek from the start of the file.</desc>
    </const>
    <const name="Current"                 value="1">
      <desc>Seek from the current file position.</desc>
    </const>
  </enum>

  <enum
    name="ProcessInputFlag"
    uuid="5d38c1dd-2604-4ddf-92e5-0c0cdd3bdbd5"
    >
    <desc>
      Guest process input flags.
    </desc>
    <const name="None"                    value="0">
      <desc>No flag set.</desc>
    </const>
    <const name="EndOfFile"               value="1">
      <desc>End of file (input) reached.</desc>
    </const>
  </enum>

  <enum
    name="ProcessOutputFlag"
    uuid="9979e85a-52bb-40b7-870c-57115e27e0f1"
    >
    <desc>
      Guest process output flags for specifying which
      type of output to retrieve.
    </desc>
    <const name="None"                     value="0">
      <desc>No flags set. Get output from stdout.</desc>
    </const>
    <const name="StdErr"                   value="1">
      <desc>Get output from stderr.</desc>
    </const>
  </enum>

  <enum
    name="ProcessWaitForFlag"
    uuid="23b550c7-78e1-437e-98f0-65fd9757bcd2"
    >
    <desc>
      Process waiting flags. Multiple flags can be combined.
    </desc>

    <const name="None"                    value="0">
      <desc>No waiting flags specified. Do not use this.</desc>
    </const>
    <const name="Start"                   value="1">
      <desc>Wait for the process being started.</desc>
    </const>
    <const name="Terminate"               value="2">
      <desc>Wait for the process being terminated.</desc>
    </const>
    <const name="StdIn"                   value="4">
      <desc>Wait for stdin becoming available.</desc>
    </const>
    <const name="StdOut"                  value="8">
      <desc>Wait for data becoming available on stdout.</desc>
    </const>
    <const name="StdErr"                  value="16">
      <desc>Wait for data becoming available on stderr.</desc>
    </const>
  </enum>

  <enum
    name="ProcessWaitResult"
    uuid="40719cbe-f192-4fe9-a231-6697b3c8e2b4"
    >
    <desc>
      Process waiting results. Depending on the process waiting flags (for
      more information see <link to="ProcessWaitForFlag"/>) the waiting result
      can vary based on the processes' current status.

      To wait for a gust process to terminate after it has been
      created by <link to="IGuestSession::processCreate"/> or <link to="IGuestSession::processCreateEx"/>
      one would specify ProcessWaitResult_Terminate.

      If a guest process has been started with ProcessCreateFlag_WaitForStdOut
      a client can wait with ProcessWaitResult_StdOut for new data to arrive on
      stdout; same applies for ProcessCreateFlag_WaitForStdErr and
      ProcessWaitResult_StdErr.
    </desc>

    <const name="None"                    value="0">
      <desc>No result was returned. Not being used.</desc>
    </const>
    <const name="Start"                   value="1">
      <desc>The process has been started.</desc>
    </const>
    <const name="Terminate"               value="2">
      <desc>The process has been terminated.</desc>
    </const>
    <const name="Status"                  value="3">
      <desc>
        The process has changed its status. The status then can
        be retrieved via <link to="IProcess::status"/>.
      </desc>
    </const>
    <const name="Error"                   value="4">
      <desc>Error while executing the process.</desc>
    </const>
    <const name="Timeout"                 value="5">
      <desc>
        The waiting operation timed out. This also will happen
        when no event has been occured matching the
        current waiting flags in a <link to="IProcess::waitFor"/> call.
      </desc>
    </const>
    <const name="StdIn"                   value="6">
      <desc>
        The process signalled that stdin became available for writing
        and that the process awaits input now.</desc>
    </const>
    <const name="StdOut"                  value="7">
      <desc>Data on stdout became available for reading.</desc>
    </const>
    <const name="StdErr"                  value="8">
      <desc>Data on stderr became available for reading.</desc>
    </const>
    <const name="WaitFlagNotSupported"    value="9">
      <desc>
        A waiting flag specified in the <link to="IProcess::waitFor"/> call
        is not supported by the guest.
      </desc>
    </const>
  </enum>

  <enum
    name="CopyFileFlag"
    uuid="23f79fdf-738a-493d-b80b-42d607c9b916"
    >
    <desc>
      File copying flags.
    </desc>
    <const name="None"                    value="0">
      <desc>No flag set.</desc>
    </const>
    <const name="Recursive"               value="1">
      <desc>Copy directories recursively.</desc>
    </const>
    <const name="Update"                  value="2">
      <desc>Only copy when the source file is newer than the destination file or when the destination file is missing.</desc>
    </const>
    <const name="FollowLinks"             value="4">
      <desc>Follow symbolic links.</desc>
    </const>
  </enum>

  <enum
    name="DirectoryCreateFlag"
    uuid="bd721b0e-ced5-4f79-b368-249897c32a36"
    >
    <desc>
      Directory creation flags.
    </desc>
    <const name="None"                    value="0">
      <desc>No flag set.</desc>
    </const>
    <const name="Parents"                 value="1">
      <desc>No error if existing, make parent directories as needed.</desc>
    </const>
  </enum>

  <enum
    name="DirectoryRemoveRecFlag"
    uuid="455aabf0-7692-48f6-9061-f21579b65769"
    >
    <desc>
      Directory recursive removement flags.
    </desc>

    <const name="None"                    value="0">
      <desc>No flag set.</desc>
    </const>
    <const name="ContentAndDir"           value="1">
      <desc>Delete the content of the directory and the directory itself.</desc>
    </const>
    <const name="ContentOnly"             value="2">
      <desc>Only delete the content of the directory, omit the directory it self.</desc>
    </const>
  </enum>

  <enum
    name="PathRenameFlag"
    uuid="f3baa09f-c758-453d-b91c-c7787d76351d"
    >
    <desc>
      Path renaming flags.
    </desc>

    <const name="None"                    value="0">
      <desc>No flag set.</desc>
    </const>
    <const name="NoReplace"               value="1">
      <desc>Do not replace anything.</desc>
    </const>
    <const name="Replace"                 value="2">
      <desc>This will replace attempt any target which isn't a directory.</desc>
    </const>
    <const name="NoSymlinks"              value="4">
      <desc>Don't allow symbolic links as part of the path.</desc>
    </const>
  </enum>

  <enum
    name="ProcessCreateFlag"
    uuid="35192799-bfde-405d-9bea-c735ab9998e4"
    >
    <desc>
      Guest process execution flags.
    </desc>

    <const name="None"                    value="0">
      <desc>No flag set.</desc>
    </const>
    <const name="WaitForProcessStartOnly" value="1">
      <desc>Only use the specified timeout value to wait for starting the guest process - the guest
        process itself then uses an infinite timeout.</desc>
    </const>
    <const name="IgnoreOrphanedProcesses" value="2">
      <desc>Do not report an error when executed processes are still alive when VBoxService or the guest OS is shutting down.</desc>
    </const>
    <const name="Hidden"                  value="4">
      <desc>Do not show the started process according to the guest OS guidelines.</desc>
    </const>
    <const name="NoProfile"               value="8">
      <desc>Do not use the user's profile data when exeuting a process. Only available for Windows guests.</desc>
    </const>
    <const name="WaitForStdOut"           value="16">
      <desc>The guest process waits until all data from stdout is read out.</desc>
    </const>
    <const name="WaitForStdErr"           value="32">
      <desc>The guest process waits until all data from stderr is read out.</desc>
    </const>
    <const name="ExpandArguments"         value="64">
      <desc>Expands environment variables in process arguments.</desc>
    </const>
  </enum>

  <enum
    name="ProcessPriority"
    uuid="ee8cac50-e232-49fe-806b-d1214d9c2e49"
    >
    <desc>
      Process priorities.
    </desc>

    <const name="Invalid"                 value="0">
      <desc>Invalid priority, do not use.</desc>
    </const>
    <const name="Default"                 value="1">
      <desc>Default process priority determined by the OS.</desc>
    </const>
  </enum>

  <enum
    name="SymlinkType"
    uuid="37794668-f8f1-4714-98a5-6f8fa2ed0118"
    >
    <desc>
      Symbolic link types.
    </desc>

    <const name="Unknown"                 value="0">
      <desc>It is not known what is being targeted.</desc>
    </const>
    <const name="Directory"               value="1">
      <desc>The link targets a directory.</desc>
    </const>
    <const name="File"                    value="2">
      <desc>The link targets a file (or whatever else).</desc>
    </const>
  </enum>

  <enum
    name="SymlinkReadFlag"
    uuid="b7fe2b9d-790e-4b25-8adf-1ca33026931f"
    >
    <desc>
      Symbolic link reading flags.
    </desc>

    <const name="None"                    value="0">
      <desc>No flags set.</desc>
    </const>
    <const name="NoSymlinks"              value="1">
      <desc>Don't allow symbolic links as part of the path.</desc>
    </const>
  </enum>

  <enum
    name="ProcessStatus"
    uuid="4d52368f-5b48-4bfe-b486-acf89139b52f"
    >
    <desc>
      Process execution statuses.
    </desc>
    <const name="Undefined"               value="0">
      <desc>Process is in an undefined state.</desc>
    </const>

    <const name="Starting"                value="10">
      <desc>Process is being started.</desc>
    </const>
    <const name="Started"                 value="100">
      <desc>Process has been started.</desc>
    </const>
    <const name="Paused"                  value="110">
      <desc>Process has been paused.</desc>
    </const>
    <const name="Terminating"             value="480">
      <desc>Process is being terminated.</desc>
    </const>
    <const name="TerminatedNormally"      value="500">
      <desc>Process terminated normally.</desc>
    </const>
    <const name="TerminatedSignal"        value="510">
      <desc>Process terminated via signal.</desc>
    </const>
    <const name="TerminatedAbnormally"    value="511">
      <desc>Process terminated abnormally.</desc>
    </const>
     <const name="TimedOutKilled"         value="512">
      <desc>Process timed out and was killed.</desc>
    </const>
    <const name="TimedOutAbnormally"      value="513">
      <desc>Process timed out and was not killed successfully.</desc>
    </const>
    <const name="Down"                    value="600">
      <desc>Service/OS is stopping, process was killed.</desc>
    </const>
    <const name="Error"                   value="800">
      <desc>Something went wrong.</desc>
    </const>
  </enum>

  <enum
    name="FsObjType"
    uuid="a1ed437c-b3c3-4ca2-b19c-4239d658d5e8"
    >
    <desc>
      File system object type.
    </desc>

    <const name="Undefined"               value="0">
      <desc>Type is undefined / unknown.</desc>
    </const>
    <const name="FIFO"                    value="1">
      <desc>Named pipe.</desc>
    </const>
    <const name="DevChar"                 value="10">
      <desc>Character device.</desc>
    </const>
    <const name="DevBlock"                value="11">
      <desc>Block device.</desc>
    </const>
    <const name="Directory"               value="50">
      <desc>Directory.</desc>
    </const>
    <const name="File"                    value="80">
      <desc>File.</desc>
    </const>
    <const name="Symlink"                 value="100">
      <desc>Symlink.</desc>
    </const>
    <const name="Socket"                  value="200">
      <desc>Socket.</desc>
    </const>
    <const name="Whiteout"                value="400">
      <desc>Whiteout.</desc>
    </const>
  </enum>

  <enum
    name="DragAndDropAction"
    uuid="47f3b162-c107-4fcd-bfa7-54b8135c441e"
  >
    <desc>
      Possible actions within an Drag and Drop operation.
    </desc>

    <const name="Ignore"               value="0">
      <desc>Do nothing.</desc>
    </const>

    <const name="Copy"                 value="1">
      <desc>Copy the item to the target.</desc>
    </const>

    <const name="Move"                 value="2">
      <desc>Move the item to the target.</desc>
    </const>

    <const name="Link"                 value="3">
      <desc>Link the item from within the target.</desc>
    </const>
  </enum>

  <enum
    name="DirectoryOpenFlag"
    uuid="5138837a-8fd2-4194-a1b0-08f7bc3949d0"
    >
    <desc>
      Directory open flags.
    </desc>
    <const name="None"                    value="0">
      <desc>No flag set.</desc>
    </const>
    <const name="NoSymlinks"              value="1">
      <desc>Don't allow symbolic links as part of the path.</desc>
    </const>
  </enum>

  <interface
    name="IGuestSession" extends="$unknown"
    uuid="57eb82a8-822b-42c1-9d1c-5c54bc3d3250"
    wsmap="managed"
    >
    <desc>
      A guest session represents one impersonated user account on the guest, so
      every operation will use the same credentials specified when creating
      the session object via <link to="IGuest::createSession"/>.

      There can be a maximum of 32 sessions at once per VM. Each session keeps
      track of its started guest processes, opened guest files or guest directories.
      To work on guest files or directories a guest session offers methods to open
      or create such objects (see <link to="IGuestSession::fileOpen"/> or
      <link to="IGuestSession::directoryOpen"/> for example).

      When done with either of these objects, including the guest session itself,
      use the appropriate close() method to let the object do its cleanup work.

      Every guest session has its own environment variable block which gets
      automatically applied when starting a new guest process via
      <link to="IGuestSession::processCreate"/> or <link to="IGuestSession::processCreateEx"/>.
      To override (or unset) certain environment variables already set by the
      guest session, one can specify a per-process environment block when using
      one of the both above mentioned process creation calls.
    </desc>

    <attribute name="user" type="wstring" readonly="yes">
      <desc>Returns the user name used by this session to impersonate
        users on the guest.
      </desc>
    </attribute>

    <attribute name="domain" type="wstring" readonly="yes">
      <desc>Returns the domain name used by this session to impersonate
        users on the guest.
      </desc>
    </attribute>

    <attribute name="name" type="wstring" readonly="yes">
      <desc>Returns the session's friendly name.</desc>
    </attribute>

    <attribute name="id" type="unsigned long" readonly="yes">
      <desc>Returns the internal session ID.</desc>
    </attribute>

    <attribute name="timeout" type="unsigned long" readonly="no">
      <desc>
        Returns the session timeout (in ms).
        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
    </attribute>

    <attribute name="environment" type="wstring" safearray="yes">
      <desc>
        Returns the current session environment.
      </desc>
    </attribute>

    <attribute name="processes" type="IGuestProcess" readonly="yes" safearray="yes">
      <desc>
        Returns all current guest processes.
      </desc>
    </attribute>

    <attribute name="directories" type="IGuestDirectory" readonly="yes" safearray="yes">
      <desc>
        Returns all currently opened guest directories.
      </desc>
    </attribute>

    <attribute name="files" type="IGuestFile" readonly="yes" safearray="yes">
      <desc>
        Returns all currently opened guest files.
      </desc>
    </attribute>

    <method name="close">
      <desc>
        Closes this session. All opened guest directories, files and
        processes which are not referenced by clients anymore will be
        uninitialized.
      </desc>
    </method>

    <method name="copyFrom">
      <desc>
        Copies a file from guest to the host.

        <result name="VBOX_E_IPRT_ERROR">
          Error starting the copy operation.
        </result>
      </desc>
      <param name="source" type="wstring" dir="in">
        <desc>Source file on the guest to copy to the host.</desc>
      </param>
      <param name="dest" type="wstring" dir="in">
        <desc>Destination file name on the host.</desc>
      </param>
      <param name="flags" type="CopyFileFlag" dir="in" safearray="yes">
        <desc>Copy flags; see <link to="CopyFileFlag"/> for more information.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="copyTo">
      <desc>
        Copies a file from host to the guest.

        <result name="VBOX_E_IPRT_ERROR">
          Error starting the copy operation.
        </result>
      </desc>
      <param name="source" type="wstring" dir="in">
        <desc>Source file on the host to copy to the guest.</desc>
      </param>
      <param name="dest" type="wstring" dir="in">
        <desc>Destination file name on the guest.</desc>
      </param>
      <param name="flags" type="CopyFileFlag" dir="in" safearray="yes">
        <desc>Copy flags; see <link to="CopyFileFlag"/> for more information.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="directoryCreate">
      <desc>
        Create a directory on the guest.

        <result name="VBOX_E_IPRT_ERROR">
          Error while creating the directory.
        </result>
      </desc>
      <param name="path" type="wstring" dir="in">
        <desc>Full path of directory to create.</desc>
      </param>
      <param name="mode" type="unsigned long" dir="in">
        <desc>File creation mode.</desc>
      </param>
      <param name="flags" type="DirectoryCreateFlag" dir="in" safearray="yes">
        <desc>Creation flags; see <link to="DirectoryCreateFlag"/> for more information.</desc>
      </param>
    </method>

    <method name="directoryCreateTemp">
      <desc>
        Create a temporary directory on the guest.

        <result name="VBOX_E_NOT_SUPPORTED">
          The operation is not possible as requested on this particular
          guest type.
        </result>
        <result name="E_INVALIDARG">
          Invalid argument.  This includes an incorrectly formatted template,
          or a non-absolute path.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          The temporary directory could not be created.  Possible reasons
          include a non-existing path or an insecure path when the secure
          option was requested.
        </result>
      </desc>
      <param name="templateName" type="wstring" dir="in">
        <desc>Template for the name of the directory to create.  This must
          contain at least one 'X' character.  The first group of consecutive
          'X' characters in the template will be replaced by a random
          alphanumeric string to produce a unique name.</desc>
      </param>
      <param name="mode" type="unsigned long" dir="in">
        <desc>The mode of the directory to create.  Use 0700 unless there are
          reasons not to.  This parameter is ignored if "secure" is specified.
          </desc>
      </param>
      <param name="path" type="wstring" dir="in">
        <desc>The absolute path to create the temporary directory in.</desc>
      </param>
      <param name="secure" type="boolean" dir="in">
        <desc>Whether to fail if the directory can not be securely created.
          Currently this means that another unprivileged user cannot
          manipulate the path specified or remove the temporary directory
          after it has been created.  Also causes the mode specified to be
          ignored.  May not be supported on all guest types.</desc>
      </param>
      <param name="directory" type="wstring" dir="return">
        <desc>On success this will contain the name of the directory created
          with full path.</desc>
      </param>
    </method>

    <method name="directoryExists">
      <desc>
        Checks whether a directory exists on the guest or not.

        <result name="VBOX_E_IPRT_ERROR">
          Error while checking existence of the directory specified.
        </result>
      </desc>
      <param name="path" type="wstring" dir="in">
        <desc>Directory to check existence for.</desc>
      </param>
      <param name="exists" type="boolean" dir="return">
        <desc>Returns @c true if the directory exists, @c false if not.</desc>
      </param>
    </method>

    <method name="directoryOpen">
      <desc>
        Opens a directory and creates a <link to="IGuestDirectory"/> object that
        can be used for further operations.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Directory to open was not found.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Error while opening the directory.
        </result>
      </desc>
      <param name="path" type="wstring" dir="in">
        <desc>Full path to file to open.</desc>
      </param>
      <param name="filter" type="wstring" dir="in">
        <desc>Open filter to apply. This can include wildcards like ? and *.</desc>
      </param>
      <param name="flags" type="DirectoryOpenFlag" dir="in" safearray="yes">
        <desc>Open flags; see <link to="DirectoryOpenFlag"/> for more information.</desc>
      </param>
      <param name="directory" type="IGuestDirectory" dir="return">
        <desc><link to="IGuestDirectory"/> object containing the opened directory.</desc>
      </param>
    </method>

    <method name="directoryQueryInfo">
      <desc>
        Queries information of a directory on the guest.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Directory to query information for was not found.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Error querying information.
        </result>
      </desc>
      <param name="path" type="wstring" dir="in">
        <desc>Directory to query information for.</desc>
      </param>
      <param name="info" type="IGuestFsObjInfo" dir="return">
        <desc><link to="IGuestFsObjInfo"/> object containing the queried information.</desc>
      </param>
    </method>

    <method name="directoryRemove">
      <desc>
        Removes a guest directory if not empty.

        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="path" type="wstring" dir="in">
        <desc>Full path of directory to remove.</desc>
      </param>
    </method>

    <method name="directoryRemoveRecursive">
      <desc>
        Removes a guest directory recursively.

        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="path" type="wstring" dir="in">
        <desc>Full path of directory to remove recursively.</desc>
      </param>
      <param name="flags" type="DirectoryRemoveRecFlag" dir="in" safearray="yes">
        <desc>Remove flags; see <link to="DirectoryRemoveRecFlag"/> for more information.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="directoryRename">
      <desc>
        Renames a directory on the guest.

        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="source" type="wstring" dir="in">
        <desc>Source directory to rename.</desc>
      </param>
      <param name="dest" type="wstring" dir="in">
        <desc>Destination directory to rename the source to.</desc>
      </param>
      <param name="flags" type="PathRenameFlag" dir="in" safearray="yes">
        <desc>Rename flags; see <link to="PathRenameFlag"/> for more information.</desc>
      </param>
    </method>

    <method name="directorySetACL">
      <desc>
        Sets the ACL (Access Control List) of a guest directory.

        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="path" type="wstring" dir="in">
        <desc>Full path of directory to set the ACL for.</desc>
      </param>
      <param name="acl" type="wstring" dir="in">
        <desc>Actual ACL string to set. Must comply with the guest OS.</desc>
      </param>
    </method>

    <method name="environmentClear">
      <desc>
        Clears (deletes) all session environment variables.

        <result name="VBOX_E_IPRT_ERROR">
          Error while clearing the session environment variables.
        </result>
      </desc>
    </method>

    <method name="environmentGet">
      <desc>
        Gets the value of a session environment variable.

        <result name="VBOX_E_IPRT_ERROR">
          Error while getting the value of the session environment variable.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of session environment variable to get the value for.</desc>
      </param>
      <param name="value" type="wstring" dir="return">
        <desc>
          Value of the session environment variable specified. If this variable
          does not exist and empty value will be returned.
        </desc>
      </param>
    </method>

    <method name="environmentSet">
      <desc>
        Sets a session environment variable.

        <result name="VBOX_E_IPRT_ERROR">
          Error while setting the session environment variable.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of session environment variable to set.</desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>Value to set the session environment variable to.</desc>
      </param>
    </method>

    <method name="environmentUnset">
      <desc>
        Unsets session environment variable.

        <result name="VBOX_E_IPRT_ERROR">
          Error while unsetting the session environment variable.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of session environment variable to unset (clear).</desc>
      </param>
    </method>

    <method name="fileCreateTemp">
      <desc>
        Creates a temporary file on the guest.

        <result name="VBOX_E_NOT_SUPPORTED">
          The operation is not possible as requested on this particular
          guest type.
        </result>
        <result name="E_INVALIDARG">
          Invalid argument. This includes an incorrectly formatted template,
          or a non-absolute path.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          The temporary file could not be created. Possible reasons include
          a non-existing path or an insecure path when the secure
          option was requested.
        </result>
      </desc>
      <param name="templateName" type="wstring" dir="in">
        <desc>Template for the name of the file to create. This must contain
          at least one 'X' character.  The first group of consecutive 'X'
          characters in the template will be replaced by a random
          alphanumeric string to produce a unique name.
         </desc>
      </param>
      <param name="mode" type="unsigned long" dir="in">
        <desc>The mode of the file to create. Use 0700 unless there are
          reasons not to.  This parameter is ignored if "secure" is specified.
         </desc>
      </param>
      <param name="path" type="wstring" dir="in">
        <desc>The absolute path to create the temporary file in.</desc>
      </param>
      <param name="secure" type="boolean" dir="in">
        <desc>Whether to fail if the file can not be securely created.
          Currently this means that another unprivileged user cannot
          manipulate the path specified or remove the temporary file after
          it has been created.  Also causes the mode specified to be ignored.
          May not be supported on all guest types.</desc>
      </param>
      <param name="file" type="IGuestFile" dir="return">
        <desc>On success this will contain an open file object for the new
          temporary file.
        </desc>
      </param>
    </method>

    <method name="fileExists">
      <desc>
        Checks whether a file exists on the guest or not.

        <result name="VBOX_E_IPRT_ERROR">
          Error while checking existence of the file specified.
        </result>
      </desc>
      <param name="path" type="wstring" dir="in">
        <desc>File to check existence for.</desc>
      </param>
      <param name="exists" type="boolean" dir="return">
        <desc>Returns @c true if the file exists, @c false if not.</desc>
      </param>
    </method>

    <method name="fileRemove">
      <desc>
        Removes a single file on the guest.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          File to remove was not found.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Error while removing the file.
        </result>
      </desc>
      <param name="path" type="wstring" dir="in">
        <desc>Path to the file to remove.</desc>
      </param>
    </method>

    <method name="fileOpen">
      <desc>
        Opens a file and creates a <link to="IGuestFile"/> object that
        can be used for further operations.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          File to open was not found.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Error while opening the file.
        </result>
      </desc>
      <param name="path" type="wstring" dir="in">
        <desc>Full path to file to open.</desc>
      </param>
      <param name="openMode" type="wstring" dir="in">
        <desc>The file open mode.</desc>
      </param>
      <param name="disposition" type="wstring" dir="in">
        <desc>The file disposition.</desc>
      </param>
      <param name="creationMode" type="unsigned long" dir="in">
        <desc>The file creation mode.</desc>
      </param>
      <param name="offset" type="long long" dir="in">
        <desc>The initial read/write offset.</desc>
      </param>
      <param name="file" type="IGuestFile" dir="return">
        <desc><link to="IGuestFile"/> object representing the opened file.</desc>
      </param>
    </method>

    <method name="fileQueryInfo">
      <desc>
        Queries information of a file on the guest.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          File to query information for was not found.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Error querying information.
        </result>
      </desc>
      <param name="path" type="wstring" dir="in">
        <desc>File to query information for.</desc>
      </param>
      <param name="info" type="IGuestFsObjInfo" dir="return">
        <desc><link to="IGuestFsObjInfo"/> object containing the queried information.</desc>
      </param>
    </method>

    <method name="fileQuerySize">
      <desc>
        Queries the size of a file on the guest.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          File to rename was not found.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Error querying file size.
        </result>
      </desc>
      <param name="path" type="wstring" dir="in">
        <desc>File to query the size for.</desc>
      </param>
      <param name="size" type="long long" dir="return">
        <desc>Queried file size.</desc>
      </param>
    </method>

    <method name="fileRename">
      <desc>
        Renames a file on the guest.

        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="source" type="wstring" dir="in">
        <desc>Source file to rename.</desc>
      </param>
      <param name="dest" type="wstring" dir="in">
        <desc>Destination file to rename the source to.</desc>
      </param>
      <param name="flags" type="PathRenameFlag" dir="in" safearray="yes">
        <desc>Rename flags; see <link to="PathRenameFlag"/> for more information.</desc>
      </param>
    </method>

    <method name="fileSetACL">
      <desc>
        Sets the ACL (Access Control List) of a file on the guest.

        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="file" type="wstring" dir="in">
        <desc>Full path of file to set the ACL for.</desc>
      </param>
      <param name="acl" type="wstring" dir="in">
        <desc>Actual ACL string to set. Must comply with the guest OS.</desc>
      </param>
    </method>

    <method name="processCreate">
      <desc>
        Executes an existing program inside the guest VM.

        <note>
          Starting at VirtualBox 4.2 guest process execution by default is limited
          to serve up to 255 guest processes at a time. If all 255 guest processes
          are still active and running, starting a new guest process will result in an
          appropriate error message.

          If ProcessCreateFlag_WaitForStdOut and / or respectively ProcessCreateFlag_WaitForStdErr
          is / are set, the guest process will not exit until all data from the specified
          stream(s) is / are read out.

          To raise or lower the guest process execution limit, either the guest property
          "/VirtualBox/GuestAdd/VBoxService/--control-procs-max-kept" or VBoxService'
          command line by specifying "--control-procs-max-kept" needs to be modified.
          A restart of the guest OS is required afterwards. To serve unlimited guest
          processes, a value of "0" needs to be set (not recommended).
        </note>

        <result name="VBOX_E_IPRT_ERROR">
          Could not create process.
        </result>
      </desc>
      <param name="command" type="wstring" dir="in">
        <desc>
          Full path name of the command to execute on the guest; the
          commands has to exists in the guest VM in order to be executed.
        </desc>
      </param>
      <param name="arguments" type="wstring" dir="in" safearray="yes">
        <desc>Array of arguments passed to the execution command.</desc>
      </param>
      <param name="environment" type="wstring" dir="in" safearray="yes">
        <desc>
          Environment variables that can be set while the command is being
          executed, in form of "NAME=VALUE"; one pair per entry. To unset a
          variable just set its name ("NAME") without a value.

          This parameter can be used to override environment variables set by
          the guest session, which will be applied to the newly started process
          in any case.
        </desc>
      </param>
      <param name="flags" type="ProcessCreateFlag" dir="in" safearray="yes">
        <desc>
          Process creation flags;
          see <link to="ProcessCreateFlag"/> for more information.
        </desc>
      </param>
      <param name="timeoutMS" type="unsigned long" dir="in">
        <desc>
          Timeout (in ms) to wait for the operation to complete.
          Pass 0 for an infinite timeout.
        </desc>
      </param>
      <param name="guestProcess" type="IGuestProcess" dir="return">
        <desc>Guest process object of the newly created process.</desc>
      </param>
    </method>

    <method name="processCreateEx">
      <desc>
        Executes an existing program inside the guest VM. Extended version for
        also setting the process priority and affinity.

        <note>
          Starting at VirtualBox 4.2 guest process execution by default is limited
          to serve up to 255 guest processes at a time. If all 255 guest processes
          are still active and running, starting a new guest process will result in an
          appropriate error message.

          If ProcessCreateFlag_WaitForStdOut and / or respectively ProcessCreateFlag_WaitForStdErr
          is / are set, the guest process will not exit until all data from the specified
          stream(s) is / are read out.

          To raise or lower the guest process execution limit, either the guest property
          "/VirtualBox/GuestAdd/VBoxService/--control-procs-max-kept" or VBoxService'
          command line by specifying "--control-procs-max-kept" needs to be modified.
          A restart of the guest OS is required afterwards. To serve unlimited guest
          processes, a value of "0" needs to be set (not recommended).
        </note>

        <result name="VBOX_E_IPRT_ERROR">
          Could not create process.
        </result>
      </desc>
      <param name="command" type="wstring" dir="in">
        <desc>
          Full path name of the command to execute on the guest; the
          commands has to exists in the guest VM in order to be executed.
        </desc>
      </param>
      <param name="arguments" type="wstring" dir="in" safearray="yes">
        <desc>Array of arguments passed to the execution command.</desc>
      </param>
      <param name="environment" type="wstring" dir="in" safearray="yes">
        <desc>
          Environment variables that can be set while the command is being
          executed, in form of "NAME=VALUE"; one pair per entry. To unset a
          variable just set its name ("NAME") without a value.

          This parameter can be used to override environment variables set by
          the guest session, which will be applied to the newly started process
          in any case.
        </desc>
      </param>
      <param name="flags" type="ProcessCreateFlag" dir="in" safearray="yes">
        <desc>
          Process creation flags;
          see <link to="ProcessCreateFlag"/> for more information.
        </desc>
      </param>
      <param name="timeoutMS" type="unsigned long" dir="in">
        <desc>
          Timeout (in ms) to wait for the operation to complete.
          Pass 0 for an infinite timeout.
        </desc>
      </param>
      <param name="priority" type="ProcessPriority" dir="in">
        <desc>
          Process priority to use for execution;
          see see <link to="ProcessPriority"/> for more information.</desc>
      </param>
      <param name="affinity" type="long" dir="in" safearray="yes">
        <desc>
          Process affinity to use for execution. This parameter
          is not implemented yet.
        </desc>
      </param>
      <param name="guestProcess" type="IGuestProcess" dir="return">
        <desc>Guest process object of the newly created process.</desc>
      </param>
    </method>

    <method name="processGet">
      <desc>
        Gets a certain guest process by its process ID (PID).
      </desc>
      <param name="pid" type="unsigned long" dir="in">
        <desc>Process ID (PID) to get guest process for.</desc>
      </param>
      <param name="guestProcess" type="IGuestProcess" dir="return">
        <desc>Guest process of specified process ID (PID).</desc>
      </param>
    </method>

    <method name="symlinkCreate">
      <desc>
        Creates a symbolic link on the guest.

        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="source" type="wstring" dir="in">
        <desc>The name of the symbolic link.</desc>
      </param>
      <param name="target" type="wstring" dir="in">
        <desc>The path to the symbolic link target.</desc>
      </param>
      <param name="type" type="SymlinkType" dir="in">
        <desc>
          The symbolic link type;
          see <link to="SymlinkReadFlag"/> for more information.
        </desc>
      </param>
    </method>

    <method name="symlinkExists">
      <desc>
        Checks whether a symbolic link exists on the guest or not.

        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="symlink" type="wstring" dir="in">
        <desc>Symbolic link to check existence for.</desc>
      </param>
      <param name="exists" type="boolean" dir="return">
        <desc>Returns @c true if the symbolic link exists, @c false if not.</desc>
      </param>
    </method>

    <method name="symlinkRead">
      <desc>
        Reads a symbolic link on the guest.

        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="symlink" type="wstring" dir="in">
        <desc>Full path to symbolic link to read.</desc>
      </param>
      <param name="flags" type="SymlinkReadFlag" dir="in" safearray="yes">
        <desc>
          Read flags; see <link to="SymlinkReadFlag"/> for more information.
        </desc>
      </param>
      <param name="target" type="wstring" dir="return">
        <desc>
          Target of the symbolic link pointing to, if found.
        </desc>
      </param>
    </method>

    <method name="symlinkRemoveDirectory">
      <desc>
        Removes a symbolic link on the guest if it's a directory.

        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="path" type="wstring" dir="in">
        <desc>Symbolic link to remove.</desc>
      </param>
    </method>

    <method name="symlinkRemoveFile">
      <desc>
        Removes a symbolic link on the guest if it's a file.

        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="file" type="wstring" dir="in">
        <desc>Symbolic link to remove.</desc>
      </param>
    </method>

  </interface>

  <interface
    name="IProcess" extends="$unknown"
    uuid="08864d56-96ab-418b-adbc-5a679532aeb0"
    wsmap="managed"
    >
    <desc>
      Abstract parent interface for processes handled by VirtualBox.
    </desc>
    <attribute name="PID" type="unsigned long" readonly="yes">
      <desc>
        The process ID (PID).
      </desc>
    </attribute>
    <attribute name="status" type="ProcessStatus" readonly="yes">
      <desc>
        The current process status; see <link to="ProcessStatus"/>
        for more information.
      </desc>
    </attribute>
    <attribute name="exitCode" type="long" readonly="yes">
      <desc>
        The exit code. Only available when the process has been
        terminated normally.
      </desc>
    </attribute>
    <attribute name="environment" type="wstring" readonly="yes" safearray="yes">
      <desc>
        The environment block this process is using during execution.
      </desc>
    </attribute>
    <attribute name="arguments" type="wstring" readonly="yes" safearray="yes">
      <desc>
        The arguments this process is using for execution.
      </desc>
    </attribute>
    <attribute name="executablePath" type="wstring" readonly="yes">
      <desc>Full path of the actual executable image.</desc>
    </attribute>
    <attribute name="name" type="wstring" readonly="yes">
      <desc>The friendly name of this process.</desc>
    </attribute>

    <method name="waitFor">
      <desc>
        Waits for one more events to happen.
      </desc>
      <param name="waitFor" type="unsigned long" dir="in">
        <desc>
          Specifies what to wait for;
          see <link to="ProcessWaitForFlag"/> for more information.
        </desc>
      </param>
      <param name="timeoutMS" type="unsigned long" dir="in">
        <desc>
          Timeout (in ms) to wait for the operation to complete.
          Pass 0 for an infinite timeout.
        </desc>
      </param>
      <param name="reason" type="ProcessWaitResult" dir="return">
        <desc>
          The overall wait result;
          see <link to="ProcessWaitResult"/> for more information.
        </desc>
      </param>
    </method>

    <method name="waitForArray">
      <desc>
        Waits for one more events to happen.
        Scriptable version of <link to="#waitFor" />.
      </desc>
      <param name="waitFor" type="ProcessWaitForFlag" dir="in" safearray="yes">
        <desc>
          Specifies what to wait for;
          see <link to="ProcessWaitForFlag"/> for more information.
        </desc>
      </param>
      <param name="timeoutMS" type="unsigned long" dir="in">
        <desc>
          Timeout (in ms) to wait for the operation to complete.
          Pass 0 for an infinite timeout.
        </desc>
      </param>
      <param name="reason" type="ProcessWaitResult" dir="return">
        <desc>
          The overall wait result;
          see <link to="ProcessWaitResult"/> for more information.
        </desc>
      </param>
    </method>

    <method name="read">
      <desc>
        Reads data from a running process.
      </desc>
      <param name="handle" type="unsigned long" dir="in">
        <desc>Handle to read from. Usually 0 is stdin.</desc>
      </param>
      <param name="toRead" type="unsigned long" dir="in">
        <desc>Number of bytes to read.</desc>
      </param>
      <param name="timeoutMS" type="unsigned long" dir="in">
        <desc>
          Timeout (in ms) to wait for the operation to complete.
          Pass 0 for an infinite timeout.
        </desc>
      </param>
      <param name="data" type="octet" dir="return" safearray="yes">
        <desc>Array of data read.</desc>
      </param>
    </method>

    <method name="write">
      <desc>
        Writes data to a running process.
      </desc>
      <param name="handle" type="unsigned long" dir="in">
        <desc>Handle to write to. Usually 0 is stdin, 1 is stdout and 2 is stderr.</desc>
      </param>
      <param name="flags" type="unsigned long" dir="in">
        <desc>
          A combination of <link to="ProcessInputFlag"/> flags.
        </desc>
      </param>
      <param name="data" type="octet" dir="in" safearray="yes">
        <desc>
          Array of bytes to write. The size of the array also specifies
          how much to write.
        </desc>
      </param>
      <param name="timeoutMS" type="unsigned long" dir="in">
        <desc>
          Timeout (in ms) to wait for the operation to complete.
          Pass 0 for an infinite timeout.
        </desc>
      </param>
      <param name="written" type="unsigned long" dir="return">
        <desc>How much bytes were written.</desc>
      </param>
    </method>

    <method name="writeArray">
      <desc>
        Writes data to a running process.
        Scriptable version of <link to="#write" />.
      </desc>
      <param name="handle" type="unsigned long" dir="in">
        <desc>Handle to write to. Usually 0 is stdin, 1 is stdout and 2 is stderr.</desc>
      </param>
      <param name="flags" type="ProcessInputFlag" dir="in" safearray="yes">
        <desc>
          A combination of <link to="ProcessInputFlag"/> flags.
        </desc>
      </param>
      <param name="data" type="octet" dir="in" safearray="yes">
        <desc>
          Array of bytes to write. The size of the array also specifies
          how much to write.
        </desc>
      </param>
      <param name="timeoutMS" type="unsigned long" dir="in">
        <desc>
          Timeout (in ms) to wait for the operation to complete.
          Pass 0 for an infinite timeout.
        </desc>
      </param>
      <param name="written" type="unsigned long" dir="return">
        <desc>How much bytes were written.</desc>
      </param>
    </method>

    <method name="terminate">
      <desc>
        Terminates (kills) a running process.
      </desc>
    </method>
  </interface>

  <interface
    name="IGuestProcess" extends="IProcess"
    uuid="dfa39a36-5d43-4840-a025-67ea956b3111"
    wsmap="managed"
    >
    <desc>
      Implementation of the <link to="IProcess" /> object
      for processes on the guest.
    </desc>
  </interface>

  <interface
    name="IDirectory" extends="$unknown"
    uuid="1b70dd03-26d7-483a-8877-89bbb0f87b70"
    wsmap="managed"
    >
    <desc>
      Abstract parent interface for directories handled by VirtualBox.
    </desc>

    <attribute name="directoryName" type="wstring" readonly="yes">
      <desc>
        Full path of directory.
      </desc>
    </attribute>

    <attribute name="filter" type="wstring" readonly="yes">
      <desc>
        The open filter.
      </desc>
    </attribute>

    <method name="close">
      <desc>
        Closes this directory. After closing operations like reading the next
        directory entry will not be possible anymore.
      </desc>
    </method>

    <method name="read">
      <desc>
        Reads the next directory entry of this directory.
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No more directory entries to read.
        </result>
      </desc>
      <param name="objInfo" type="IFsObjInfo" dir="return">
        <desc>Object information of the current directory entry read. Also see  <link to="IFsObjInfo"/>.</desc>
      </param>
    </method>
  </interface>

  <interface
    name="IGuestDirectory" extends="IDirectory"
    uuid="af4a8ce0-0725-42b7-8826-46e3c7ba7357"
    wsmap="managed"
    >
    <desc>
      Implementation of the <link to="IDirectory" /> object
      for directories on the guest.
    </desc>
  </interface>

  <interface
    name="IFile" extends="$unknown"
    uuid="b702a560-6139-4a8e-a892-bbf14b97bf97"
    wsmap="managed"
    >
    <desc>
      Abstract parent interface for files handled by VirtualBox.
    </desc>
    <attribute name="creationMode" type="unsigned long" readonly="yes">
      <desc>
        The creation mode.
      </desc>
    </attribute>
    <attribute name="disposition" type="unsigned long" readonly="yes">
      <desc>
        The disposition mode.
      </desc>
    </attribute>
    <attribute name="fileName" type="wstring" readonly="yes">
      <desc>
        Full path of the actual file name of this file.
      </desc>
    </attribute>
    <attribute name="initialSize" type="long long" readonly="yes">
      <desc>
        The initial size in bytes when opened.
      </desc>
    </attribute>
    <attribute name="openMode" type="unsigned long" readonly="yes">
      <desc>
        The open mode.
      </desc>
    </attribute>
    <attribute name="offset" type="long long" readonly="yes">
      <desc>
        Current read/write offset in bytes.
      </desc>
    </attribute>

    <method name="close">
      <desc>
        Closes this file. After closing operations like reading data,
        writing data or querying information will not be possible anymore.
      </desc>
    </method>

    <method name="queryInfo">
      <desc>
        Queries information about this file.

        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="objInfo" type="IFsObjInfo" dir="return">
        <desc>Object information of this file. Also see  <link to="IFsObjInfo"/>.</desc>
      </param>
    </method>

    <method name="read">
      <desc>
        Reads data from this file.

        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="toRead" type="unsigned long" dir="in">
        <desc>Number of bytes to read.</desc>
      </param>
      <param name="timeoutMS" type="unsigned long" dir="in">
        <desc>
          Timeout (in ms) to wait for the operation to complete.
          Pass 0 for an infinite timeout.
        </desc>
      </param>
      <param name="data" type="octet" dir="return" safearray="yes">
        <desc>Array of data read.</desc>
      </param>
    </method>

    <method name="readAt">
      <desc>
        Reads data from an offset of this file.

        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="offset" type="long long" dir="in">
        <desc>Offset in bytes to start reading.</desc>
      </param>
      <param name="toRead" type="unsigned long" dir="in">
        <desc>Number of bytes to read.</desc>
      </param>
      <param name="timeoutMS" type="unsigned long" dir="in">
        <desc>
          Timeout (in ms) to wait for the operation to complete.
          Pass 0 for an infinite timeout.
        </desc>
      </param>
      <param name="data" type="octet" dir="return" safearray="yes">
        <desc>Array of data read.</desc>
      </param>
    </method>

    <method name="seek">
      <desc>
        Changes the read and write position of this file.

        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="offset" type="long long" dir="in">
        <desc>Offset to seek.</desc>
      </param>
      <param name="whence" type="FileSeekType" dir="in">
        <desc>
          Seek mode; see <link to="FileSeekType"/> for more information.
        </desc>
      </param>
    </method>

    <method name="setACL">
      <desc>
        Sets the ACL of this file.

        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="acl" type="wstring" dir="in">
        <desc>ACL string to set.</desc>
      </param>
    </method>

    <method name="write">
      <desc>
        Writes bytes to this file.
      </desc>
      <param name="data" type="octet" dir="in" safearray="yes">
        <desc>
          Array of bytes to write. The size of the array also specifies
          how much to write.
        </desc>
      </param>
      <param name="timeoutMS" type="unsigned long" dir="in">
        <desc>
          Timeout (in ms) to wait for the operation to complete.
          Pass 0 for an infinite timeout.
        </desc>
      </param>
      <param name="written" type="unsigned long" dir="return">
        <desc>How much bytes were written.</desc>
      </param>
    </method>

    <method name="writeAt">
      <desc>
        Writes bytes at a certain offset to this file.

        <result name="E_NOTIMPL">
          The method is not implemented yet.
        </result>
      </desc>
      <param name="offset" type="long long" dir="in">
        <desc>Offset in bytes to start writing.</desc>
      </param>
      <param name="data" type="octet" dir="in" safearray="yes">
        <desc>
          Array of bytes to write. The size of the array also specifies
          how much to write.
        </desc>
      </param>
      <param name="timeoutMS" type="unsigned long" dir="in">
        <desc>
          Timeout (in ms) to wait for the operation to complete.
          Pass 0 for an infinite timeout.
        </desc>
      </param>
      <param name="written" type="unsigned long" dir="return">
        <desc>How much bytes were written.</desc>
      </param>
    </method>

  </interface>

  <interface
    name="IGuestFile" extends="IFile"
    uuid="60661aec-145f-4d11-b80e-8ea151598093"
    wsmap="managed"
    >
    <desc>
      Implementation of the <link to="IFile" /> object
      for files on the guest.
    </desc>
  </interface>

  <interface
    name="IFsObjInfo" extends="$unknown"
    uuid="4047ba30-7006-4966-ae86-94164e5e20eb"
    wsmap="managed"
    >
    <desc>
      Abstract parent interface for VirtualBox file system object information.
      This can be information about a file or a directory, for example.
    </desc>

    <attribute name="accessTime" type="long long" readonly="yes">
      <desc>
        Time of last access (st_atime).
      </desc>
    </attribute>
    <attribute name="allocatedSize" type="long long" readonly="yes">
      <desc>
        Disk allocation size (st_blocks * DEV_BSIZE).
      </desc>
    </attribute>
    <attribute name="birthTime" type="long long" readonly="yes">
      <desc>
        Time of file birth (st_birthtime).
      </desc>
    </attribute>
        <attribute name="changeTime" type="long long" readonly="yes">
      <desc>
        Time of last status change (st_ctime).
      </desc>
    </attribute>
    <attribute name="deviceNumber" type="unsigned long" readonly="yes">
      <desc>
        The device number of a character or block device type object (st_rdev).
      </desc>
    </attribute>
    <attribute name="fileAttributes" type="wstring" readonly="yes">
      <desc>
        File attributes. Not implemented yet.
      </desc>
    </attribute>
    <attribute name="generationId" type="unsigned long" readonly="yes">
      <desc>
        The current generation number (st_gen).
      </desc>
    </attribute>
    <attribute name="GID" type="unsigned long" readonly="yes">
      <desc>
        The group the filesystem object is assigned (st_gid).
      </desc>
    </attribute>
    <attribute name="groupName" type="wstring" readonly="yes">
      <desc>
        The group name.
      </desc>
    </attribute>
    <attribute name="hardLinks" type="unsigned long" readonly="yes">
      <desc>
        Number of hard links to this filesystem object (st_nlink).
      </desc>
    </attribute>
    <attribute name="modificationTime" type="long long" readonly="yes">
      <desc>
        Time of last data modification (st_mtime).
      </desc>
    </attribute>
    <attribute name="name" type="wstring" readonly="yes">
      <desc>
        The object's name.
      </desc>
    </attribute>
    <attribute name="nodeId" type="long long" readonly="yes">
      <desc>
        The unique identifier (within the filesystem) of this filesystem object (st_ino).
      </desc>
    </attribute>
    <attribute name="nodeIdDevice" type="unsigned long" readonly="yes">
      <desc>
        The device number of the device which this filesystem object resides on (st_dev).
      </desc>
    </attribute>
    <attribute name="objectSize" type="long long" readonly="yes">
      <desc>
        The logical size (st_size). For normal files this is the size of the file.
        For symbolic links, this is the length of the path name contained in the
        symbolic link. For other objects this fields needs to be specified.
      </desc>
    </attribute>
    <attribute name="type" type="FsObjType" readonly="yes">
      <desc>
        The object type. See <link to="FsObjType" /> for more.
      </desc>
    </attribute>
    <attribute name="UID" type="unsigned long" readonly="yes">
      <desc>
        The user owning the filesystem object (st_uid).
      </desc>
    </attribute>
    <attribute name="userFlags" type="unsigned long" readonly="yes">
      <desc>
        User flags (st_flags).
      </desc>
    </attribute>
    <attribute name="userName" type="wstring" readonly="yes">
      <desc>
        The user name.
      </desc>
    </attribute>

  </interface>

  <interface
    name="IGuestFsObjInfo" extends="IFsObjInfo"
    uuid="d5cf678e-3484-4e4a-ac55-329e15462e18"
    wsmap="managed"
    >
    <desc>
      Represents the guest implementation of the
      <link to="IFsObjInfo" /> object.
    </desc>
  </interface>

  <interface
    name="IGuest" extends="$unknown"
    uuid="19c32350-0618-4ede-b0c3-2b4311bf0d9b"
    wsmap="managed"
    >
    <desc>
      The IGuest interface represents information about the operating system
      running inside the virtual machine. Used in
      <link to="IConsole::guest"/>.

      IGuest provides information about the guest operating system, whether
      Guest Additions are installed and other OS-specific virtual machine
      properties.
    </desc>

    <attribute name="OSTypeId" type="wstring" readonly="yes">
      <desc>
        Identifier of the Guest OS type as reported by the Guest
        Additions.
        You may use <link to="IVirtualBox::getGuestOSType"/> to obtain
        an IGuestOSType object representing details about the given
        Guest OS type.
        <note>
          If Guest Additions are not installed, this value will be
          the same as <link to="IMachine::OSTypeId"/>.
        </note>
      </desc>
    </attribute>

    <attribute name="additionsRunLevel" type="AdditionsRunLevelType" readonly="yes">
      <desc>
        Current run level of the Guest Additions.
      </desc>
    </attribute>

    <attribute name="additionsVersion" type="wstring" readonly="yes">
      <desc>
        Version of the Guest Additions in the same format as
        <link to="IVirtualBox::version"/>.
      </desc>
    </attribute>

    <attribute name="additionsRevision" type="unsigned long" readonly="yes">
      <desc>
        The internal build revision number of the additions.

        See also <link to="IVirtualBox::revision"/>.
      </desc>
    </attribute>

    <attribute name="facilities" type="IAdditionsFacility" readonly="yes" safearray="yes">
      <desc>
        Array of current known facilities. Only returns facilities where a status is known,
        e.g. facilities with an unknown status will not be returned.
      </desc>
    </attribute>

    <attribute name="sessions" type="IGuestSession" readonly="yes" safearray="yes">
      <desc>Returns a collection of all opened guest sessions.</desc>
    </attribute>

    <attribute name="memoryBalloonSize" type="unsigned long">
      <desc>Guest system memory balloon size in megabytes (transient property).</desc>
    </attribute>

    <attribute name="statisticsUpdateInterval" type="unsigned long">
      <desc>Interval to update guest statistics in seconds.</desc>
    </attribute>

    <method name="internalGetStatistics">
      <desc>
        Internal method; do not use as it might change at any time.
      </desc>
      <param name="cpuUser" type="unsigned long" dir="out">
        <desc>Percentage of processor time spent in user mode as seen by the guest.</desc>
      </param>
      <param name="cpuKernel" type="unsigned long" dir="out">
        <desc>Percentage of processor time spent in kernel mode as seen by the guest.</desc>
      </param>
      <param name="cpuIdle" type="unsigned long" dir="out">
        <desc>Percentage of processor time spent idling as seen by the guest.</desc>
      </param>
      <param name="memTotal" type="unsigned long" dir="out">
        <desc>Total amount of physical guest RAM.</desc>
      </param>
      <param name="memFree" type="unsigned long" dir="out">
        <desc>Free amount of physical guest RAM.</desc>
      </param>
      <param name="memBalloon" type="unsigned long" dir="out">
        <desc>Amount of ballooned physical guest RAM.</desc>
      </param>
      <param name="memShared" type="unsigned long" dir="out">
        <desc>Amount of shared physical guest RAM.</desc>
      </param>
      <param name="memCache" type="unsigned long" dir="out">
        <desc>Total amount of guest (disk) cache memory.</desc>
      </param>
      <param name="pagedTotal" type="unsigned long" dir="out">
        <desc>Total amount of space in the page file.</desc>
      </param>
      <param name="memAllocTotal" type="unsigned long" dir="out">
        <desc>Total amount of memory allocated by the hypervisor.</desc>
      </param>
      <param name="memFreeTotal" type="unsigned long" dir="out">
        <desc>Total amount of free memory available in the hypervisor.</desc>
      </param>
      <param name="memBalloonTotal" type="unsigned long" dir="out">
        <desc>Total amount of memory ballooned by the hypervisor.</desc>
      </param>
      <param name="memSharedTotal" type="unsigned long" dir="out">
        <desc>Total amount of shared memory in the hypervisor.</desc>
      </param>
    </method>

    <method name="getFacilityStatus">
      <desc>
        Get the current status of a Guest Additions facility.
      </desc>
      <param name="facility" type="AdditionsFacilityType" dir="in">
        <desc>Facility to check status for.</desc>
      </param>
      <param name="timestamp" type="long long" dir="out">
        <desc>Timestamp (in ms) of last status update seen by the host.</desc>
      </param>
      <param name="status" type="AdditionsFacilityStatus" dir="return">
        <desc>The current (latest) facility status.</desc>
      </param>
    </method>

    <method name="getAdditionsStatus">
      <desc>
        Retrieve the current status of a certain Guest Additions run level.

        <result name="VBOX_E_NOT_SUPPORTED">
          Wrong status level specified.
        </result>

      </desc>
      <param name="level" type="AdditionsRunLevelType" dir="in">
        <desc>Status level to check</desc>
      </param>
      <param name="active" type="boolean" dir="return">
        <desc>Flag whether the status level has been reached or not</desc>
      </param>
    </method>

    <method name="setCredentials">
      <desc>
        Store login credentials that can be queried by guest operating
        systems with Additions installed. The credentials are transient
        to the session and the guest may also choose to erase them. Note
        that the caller cannot determine whether the guest operating system
        has queried or made use of the credentials.

        <result name="VBOX_E_VM_ERROR">
          VMM device is not available.
        </result>

      </desc>
      <param name="userName" type="wstring" dir="in">
        <desc>User name string, can be empty</desc>
      </param>
      <param name="password" type="wstring" dir="in">
        <desc>Password string, can be empty</desc>
      </param>
      <param name="domain" type="wstring" dir="in">
        <desc>Domain name (guest logon scheme specific), can be empty</desc>
      </param>
      <param name="allowInteractiveLogon" type="boolean" dir="in">
        <desc>
          Flag whether the guest should alternatively allow the user to
          interactively specify different credentials. This flag might
          not be supported by all versions of the Additions.
        </desc>
      </param>
    </method>

    <method name="dragHGEnter">
      <desc>
        Informs the guest about a Drag and Drop enter event.

        This is used in Host - Guest direction.

        <result name="VBOX_E_VM_ERROR">
          VMM device is not available.
        </result>

      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>The screen id where the Drag and Drop event occured.</desc>
      </param>
      <param name="y" type="unsigned long" dir="in">
        <desc>y-position of the event.</desc>
      </param>
      <param name="x" type="unsigned long" dir="in">
        <desc>x-position of the event.</desc>
      </param>
      <param name="defaultAction" type="DragAndDropAction" dir="in">
        <desc>The default action to use.</desc>
      </param>
      <param name="allowedActions" type="DragAndDropAction" dir="in" safearray="yes">
        <desc>The actions which are allowed.</desc>
      </param>
      <param name="formats" type="wstring" dir="in" safearray="yes">
        <desc>The supported mime types.</desc>
      </param>
      <param name="resultAction" type="DragAndDropAction" dir="return">
        <desc>The resulting action of this event.</desc>
      </param>
    </method>

    <method name="dragHGMove">
      <desc>
        Informs the guest about a Drag and Drop move event.

        This is used in Host - Guest direction.

        <result name="VBOX_E_VM_ERROR">
          VMM device is not available.
        </result>

      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>The screen id where the Drag and Drop event occured.</desc>
      </param>
      <param name="x" type="unsigned long" dir="in">
        <desc>x-position of the event.</desc>
      </param>
      <param name="y" type="unsigned long" dir="in">
        <desc>y-position of the event.</desc>
      </param>
      <param name="defaultAction" type="DragAndDropAction" dir="in">
        <desc>The default action to use.</desc>
      </param>
      <param name="allowedActions" type="DragAndDropAction" dir="in" safearray="yes">
        <desc>The actions which are allowed.</desc>
      </param>
      <param name="formats" type="wstring" dir="in" safearray="yes">
        <desc>The supported mime types.</desc>
      </param>
      <param name="resultAction" type="DragAndDropAction" dir="return">
        <desc>The resulting action of this event.</desc>
      </param>
    </method>

    <method name="dragHGLeave">
      <desc>
        Informs the guest about a Drag and Drop leave event.

        This is used in Host - Guest direction.

        <result name="VBOX_E_VM_ERROR">
          VMM device is not available.
        </result>

      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>The screen id where the Drag and Drop event occured.</desc>
      </param>
    </method>

    <method name="dragHGDrop">
      <desc>
        Informs the guest about a drop event.

        This is used in Host - Guest direction.

        <result name="VBOX_E_VM_ERROR">
          VMM device is not available.
        </result>

      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>The screen id where the Drag and Drop event occured.</desc>
      </param>
      <param name="x" type="unsigned long" dir="in">
        <desc>x-position of the event.</desc>
      </param>
      <param name="y" type="unsigned long" dir="in">
        <desc>y-position of the event.</desc>
      </param>
      <param name="defaultAction" type="DragAndDropAction" dir="in">
        <desc>The default action to use.</desc>
      </param>
      <param name="allowedActions" type="DragAndDropAction" dir="in" safearray="yes">
        <desc>The actions which are allowed.</desc>
      </param>
      <param name="formats" type="wstring" dir="in" safearray="yes">
        <desc>The supported mime types.</desc>
      </param>
      <param name="format" type="wstring" dir="out">
        <desc>The resulting format of this event.</desc>
      </param>
      <param name="resultAction" type="DragAndDropAction" dir="return">
        <desc>The resulting action of this event.</desc>
      </param>
    </method>

    <method name="dragHGPutData">
      <desc>
        Informs the guest about a drop data event.

        This is used in Host - Guest direction.

        <result name="VBOX_E_VM_ERROR">
          VMM device is not available.
        </result>

      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>The screen id where the Drag and Drop event occured.</desc>
      </param>
      <param name="format" type="wstring" dir="in">
        <desc>The mime type the data is in.</desc>
      </param>
      <param name="data" type="octet" dir="in" safearray="yes">
        <desc>The actual data.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="dragGHPending">
      <desc>
        Ask the guest if there is any Drag and Drop operation pending in the guest.

        If no Drag and Drop operation is pending currently, Ignore is returned.

        This is used in Guest - Host direction.

        <result name="VBOX_E_VM_ERROR">
          VMM device is not available.
        </result>

      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>The screen id where the Drag and Drop event occured.</desc>
      </param>
      <param name="format" type="wstring" dir="out" safearray="yes">
        <desc>On return the supported mime types.</desc>
      </param>
      <param name="allowedActions" type="DragAndDropAction" dir="out" safearray="yes">
        <desc>On return the actions which are allowed.</desc>
      </param>
      <param name="defaultAction" type="DragAndDropAction" dir="return">
        <desc>On return the default action to use.</desc>
      </param>
    </method>

    <method name="dragGHDropped">
      <desc>
        Informs the guest that a drop event occured for a pending Drag and Drop event.

        This is used in Guest - Host direction.

        <result name="VBOX_E_VM_ERROR">
          VMM device is not available.
        </result>

      </desc>

      <param name="format" type="wstring" dir="in">
        <desc>The mime type the data must be in.</desc>
      </param>
      <param name="action" type="DragAndDropAction" dir="in">
        <desc>The action to use.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="dragGHGetData">
      <desc>
        Fetch the data of a previously Drag and Drop event from the guest.

        This is used in Guest - Host direction.

        <result name="VBOX_E_VM_ERROR">
          VMM device is not available.
        </result>

      </desc>

      <param name="data" type="octet" safearray="yes" dir="return">
        <desc>The actual data.</desc>
      </param>
    </method>

    <method name="createSession">
      <desc>
        Creates a new guest session for controlling the guest.

        A guest session represents one impersonated user account on the guest, so
        every operation will use the same credentials specified when creating
        the session object via <link to="IGuest::createSession"/>. Anonymous
        sessions, that is, sessions without specifying a valid
        user account on the guest are not allowed due to security reasons.

        There can be a maximum of 32 sessions at once per VM. Each session keeps
        track of its started guest processes, opened guest files or guest directories.
        To work on guest files or directories a guest session offers methods to open
        or create such objects (see <link to="IGuestSession::fileOpen"/> or
        <link to="IGuestSession::directoryOpen"/> for example).

        When done with either of these objects, including the guest session itself,
        use the appropriate close() method to let the object do its cleanup work.

        Every guest session has its own environment variable block which gets
        automatically applied when starting a new guest process via
        <link to="IGuestSession::processCreate"/> or <link to="IGuestSession::processCreateEx"/>.
        To override (or unset) certain environment variables already set by the
        guest session, one can specify a per-process environment block when using
        one of the both above mentioned process creation calls.

        Closing a session via <link to="IGuestSession::close" /> will try to close
        all the mentioned objects above unless these objects are still used by
        a client.
      </desc>
      <param name="user" type="wstring" dir="in">
        <desc>
          User name this session will be using to control the guest; has to exist
          and have the appropriate rights to execute programs in the VM. Must not
          be empty.
        </desc>
      </param>
      <param name="password" type="wstring" dir="in">
        <desc>
          Password of the user account to be used. Empty passwords are allowed.
        </desc>
      </param>
      <param name="domain" type="wstring" dir="in">
        <desc>
          Domain name of the user account to be used if the guest is part of
          a domain. Optional. This feature is not implemented yet.
        </desc>
      </param>
      <param name="sessionName" type="wstring" dir="in">
        <desc>
          The session's friendly name. Optional, can be empty.
        </desc>
      </param>
      <param name="guestSession" type="IGuestSession" dir="return">
        <desc>
          The newly created session object.
        </desc>
      </param>
    </method>

    <method name="findSession">
      <desc>
        Finds guest sessions by their friendly name and returns an interface
        array with all found guest sessions.
      </desc>
      <param name="sessionName" type="wstring" dir="in">
        <desc>
          The session's friendly name to find. Wildcards like ? and * are allowed.
        </desc>
      </param>
      <param name="sessions" type="IGuestSession" safearray="yes" dir="return">
        <desc>
          Array with all guest sessions found matching the name specified.
        </desc>
      </param>
    </method>

    <method name="updateGuestAdditions">
      <desc>
        Automatically updates already installed Guest Additions in a VM.

        At the moment only Windows guests are supported.

        Because the VirtualBox Guest Additions drivers are not WHQL-certified
        yet there might be warning dialogs during the actual Guest Additions
        update. These need to be confirmed manually in order to continue the
        installation process. This applies to Windows 2000 and Windows XP guests
        and therefore these guests can't be updated in a fully automated fashion
        without user interaction. However, to start a Guest Additions update for
        the mentioned Windows versions anyway, the flag
        AdditionsUpdateFlag_WaitForUpdateStartOnly can be specified. See
        <link to="AdditionsUpdateFlag"/> for more information.

        <result name="VBOX_E_NOT_SUPPORTED">
          Guest OS is not supported for automated Guest Additions updates or the
          already installed Guest Additions are not ready yet.
        </result>

        <result name="VBOX_E_IPRT_ERROR">
          Error while updating.
        </result>

      </desc>
      <param name="source" type="wstring" dir="in">
        <desc>
          Path to the Guest Additions .ISO file to use for the upate.
        </desc>
      </param>
      <param name="flags" type="AdditionsUpdateFlag" dir="in" safearray="yes">
        <desc>
          <link to="AdditionsUpdateFlag"/> flags.
        </desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

  </interface>


  <!--
  // IProgress
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IProgress" extends="$unknown"
    uuid="c20238e4-3221-4d3f-8891-81ce92d9f913"
    wsmap="managed"
    >
    <desc>
        The IProgress interface is used to track and control
        asynchronous tasks within VirtualBox.

        An instance of this is returned every time VirtualBox starts
        an asynchronous task (in other words, a separate thread) which
        continues to run after a method call returns. For example,
        <link to="IConsole::saveState" />, which saves the state of
        a running virtual machine, can take a long time to complete.
        To be able to display a progress bar, a user interface such as
        the VirtualBox graphical user interface can use the IProgress
        object returned by that method.

        Note that IProgress is a "read-only" interface in the sense
        that only the VirtualBox internals behind the Main API can
        create and manipulate progress objects, whereas client code
        can only use the IProgress object to monitor a task's
        progress and, if <link to="#cancelable" /> is @c true,
        cancel the task by calling <link to="#cancel" />.

        A task represented by IProgress consists of either one or
        several sub-operations that run sequentially, one by one (see
        <link to="#operation" /> and <link to="#operationCount" />).
        Every operation is identified by a number (starting from 0)
        and has a separate description.

        You can find the individual percentage of completion of the current
        operation in <link to="#operationPercent" /> and the
        percentage of completion of the task as a whole
        in <link to="#percent" />.

        Similarly, you can wait for the completion of a particular
        operation via <link to="#waitForOperationCompletion" /> or
        for the completion of the whole task via
        <link to="#waitForCompletion" />.
    </desc>

    <attribute name="id" type="uuid" mod="string" readonly="yes">
      <desc>ID of the task.</desc>
    </attribute>

    <attribute name="description" type="wstring" readonly="yes">
      <desc>Description of the task.</desc>
    </attribute>

    <attribute name="initiator" type="$unknown" readonly="yes">
      <desc>Initiator of the task.</desc>
    </attribute>

    <attribute name="cancelable" type="boolean" readonly="yes">
      <desc>Whether the task can be interrupted.</desc>
    </attribute>

    <attribute name="percent" type="unsigned long" readonly="yes">
      <desc>
        Current progress value of the task as a whole, in percent.
        This value depends on how many operations are already complete.
        Returns 100 if <link to="#completed" /> is @c true.
      </desc>
    </attribute>

    <attribute name="timeRemaining" type="long" readonly="yes">
        <desc>
            Estimated remaining time until the task completes, in
            seconds. Returns 0 once the task has completed; returns -1
            if the remaining time cannot be computed, in particular if
            the current progress is 0.

            Even if a value is returned, the estimate will be unreliable
            for low progress values. It will become more reliable as the
            task progresses; it is not recommended to display an ETA
            before at least 20% of a task have completed.
        </desc>
    </attribute>

    <attribute name="completed" type="boolean" readonly="yes">
      <desc>Whether the task has been completed.</desc>
    </attribute>

    <attribute name="canceled" type="boolean" readonly="yes">
      <desc>Whether the task has been canceled.</desc>
    </attribute>

    <attribute name="resultCode" type="long" readonly="yes">
      <desc>
        Result code of the progress task.
        Valid only if <link to="#completed"/> is @c true.
      </desc>
    </attribute>

    <attribute name="errorInfo" type="IVirtualBoxErrorInfo" readonly="yes">
      <desc>
        Extended information about the unsuccessful result of the
        progress operation. May be @c null if no extended information
        is available.
        Valid only if <link to="#completed"/> is @c true and
        <link to="#resultCode"/> indicates a failure.
      </desc>
    </attribute>

    <attribute name="operationCount" type="unsigned long" readonly="yes">
      <desc>
          Number of sub-operations this task is divided into.
          Every task consists of at least one suboperation.
      </desc>
    </attribute>

    <attribute name="operation" type="unsigned long" readonly="yes">
        <desc>Number of the sub-operation being currently executed.</desc>
    </attribute>

    <attribute name="operationDescription" type="wstring" readonly="yes">
      <desc>
          Description of the sub-operation being currently executed.
      </desc>
    </attribute>

    <attribute name="operationPercent" type="unsigned long" readonly="yes">
        <desc>Progress value of the current sub-operation only, in percent.</desc>
    </attribute>

    <attribute name="operationWeight" type="unsigned long" readonly="yes">
        <desc>Weight value of the current sub-operation only.</desc>
    </attribute>

    <attribute name="timeout" type="unsigned long">
      <desc>
          When non-zero, this specifies the number of milliseconds after which
          the operation will automatically be canceled.  This can only be set on
          cancelable objects.
      </desc>
    </attribute>

    <method name="setCurrentOperationProgress">
      <desc>Internal method, not to be called externally.</desc>
      <param name="percent" type="unsigned long" dir="in" />
    </method>
    <method name="setNextOperation">
      <desc>Internal method, not to be called externally.</desc>
      <param name="nextOperationDescription" type="wstring" dir="in" />
      <param name="nextOperationsWeight" type="unsigned long" dir="in" />
    </method>

    <method name="waitForCompletion">
      <desc>
          Waits until the task is done (including all sub-operations)
          with a given timeout in milliseconds; specify -1 for an indefinite wait.

          Note that the VirtualBox/XPCOM/COM/native event queues of the calling
          thread are not processed while waiting.  Neglecting event queues may
          have dire consequences (degrade performance, resource hogs,
          deadlocks, etc.), this is specially so for the main thread on
          platforms using XPCOM.  Callers are adviced wait for short periods
          and service their event queues between calls, or to create a worker
          thread to do the waiting.

        <result name="VBOX_E_IPRT_ERROR">
          Failed to wait for task completion.
        </result>
      </desc>

      <param name="timeout" type="long" dir="in">
        <desc>
          Maximum time in milliseconds to wait or -1 to wait indefinitely.
        </desc>
      </param>
    </method>

    <method name="waitForOperationCompletion">
      <desc>
          Waits until the given operation is done with a given timeout in
          milliseconds; specify -1 for an indefinite wait.

          See <link to="#waitForCompletion"> for event queue considerations.</link>

        <result name="VBOX_E_IPRT_ERROR">
          Failed to wait for operation completion.
        </result>

      </desc>
      <param name="operation" type="unsigned long" dir="in">
        <desc>
          Number of the operation to wait for.
          Must be less than <link to="#operationCount"/>.
        </desc>
      </param>
      <param name="timeout" type="long" dir="in">
        <desc>
          Maximum time in milliseconds to wait or -1 to wait indefinitely.
        </desc>
      </param>
    </method>

    <method name="waitForAsyncProgressCompletion">
      <desc>
          Waits until the other task is completed (including all
          sub-operations) and forward all changes from the other progress to
          this progress. This means sub-operation number, description, percent
          and so on.

          You have to take care on setting up at least the same count on
          sub-operations in this progress object like there are in the other
          progress object.

          If the other progress object supports cancel and this object gets any
          cancel request (when here enabled as well), it will be forwarded to
          the other progress object.

          If there is an error in the other progress, this error isn't
          automatically transfered to this progress object. So you have to
          check any operation error within the other progress object, after
          this method returns.
      </desc>

      <param name="pProgressAsync" type="IProgress" dir="in">
        <desc>
          The progress object of the asynchrony process.
        </desc>
      </param>
    </method>

    <method name="cancel">
      <desc>
        Cancels the task.
        <note>
          If <link to="#cancelable"/> is @c false, then this method will fail.
        </note>

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Operation cannot be canceled.
        </result>

      </desc>
    </method>

  </interface>

  <!--
  // ISnapshot
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="ISnapshot" extends="$unknown"
    uuid="0472823b-c6e7-472a-8e9f-d732e86b8463"
    wsmap="managed"
    >
    <desc>
      The ISnapshot interface represents a snapshot of the virtual
      machine.

      Together with the differencing media that are created
      when a snapshot is taken, a machine can be brought back to
      the exact state it was in when the snapshot was taken.

      The ISnapshot interface has no methods, only attributes; snapshots
      are controlled through methods of the <link to="IConsole" /> interface
      which also manage the media associated with the snapshot.
      The following operations exist:

      <ul>
          <li><link to="IConsole::takeSnapshot"/> creates a new snapshot
              by creating new, empty differencing images for the machine's
              media and saving the VM settings and (if the VM is running)
              the current VM state in the snapshot.

              The differencing images will then receive all data written to
              the machine's media, while their parent (base) images
              remain unmodified after the snapshot has been taken (see
              <link to="IMedium" /> for details about differencing images).
              This simplifies restoring a machine to the state of a snapshot:
              only the differencing images need to be deleted.

              The current machine state is not changed by taking a snapshot
              except that <link to="IMachine::currentSnapshot" /> is set to
              the newly created snapshot, which is also added to the machine's
              snapshots tree.
          </li>

          <li><link to="IConsole::restoreSnapshot"/> resets a machine to
              the state of a previous snapshot by deleting the differencing
              image of each of the machine's media and setting the machine's
              settings and state to the state that was saved in the snapshot (if any).

              This destroys the machine's current state. After calling this,
              <link to="IMachine::currentSnapshot" /> points to the snapshot
              that was restored.
          </li>

          <li><link to="IConsole::deleteSnapshot"/> deletes a snapshot
              without affecting the current machine state.

              This does not change the current machine state, but instead frees the
              resources allocated when the snapshot was taken: the settings and machine
              state file are deleted (if any), and the snapshot's differencing image for
              each of the machine's media gets merged with its parent image.

              Neither the current machine state nor other snapshots are affected
              by this operation, except that parent media will be modified
              to contain the disk data associated with the snapshot being deleted.

              When deleting the current snapshot, the <link to="IMachine::currentSnapshot" />
              attribute is set to the current snapshot's parent or @c null if it
              has no parent. Otherwise the attribute is unchanged.
          </li>
      </ul>

      Each snapshot contains a copy of virtual machine's settings (hardware
      configuration etc.). This copy is contained in an immutable (read-only)
      instance of <link to="IMachine" /> which is available from the snapshot's
      <link to="#machine" /> attribute. When restoring the snapshot, these
      settings are copied back to the original machine.

      In addition, if the machine was running when the
      snapshot was taken (<link to="IMachine::state"/> is <link to="MachineState_Running"/>),
      the current VM state is saved in the snapshot (similarly to what happens
      when a VM's state is saved). The snapshot is then said to be <i>online</i>
      because when restoring it, the VM will be running.

      If the machine was in <link to="MachineState_Saved">saved</link> saved,
      the snapshot receives a copy of the execution state file
      (<link to="IMachine::stateFilePath"/>).

      Otherwise, if the machine was not running (<link to="MachineState_PoweredOff"/>
      or <link to="MachineState_Aborted"/>), the snapshot is <i>offline</i>;
      it then contains a so-called "zero execution state", representing a
      machine that is powered off.
    </desc>

    <attribute name="id" type="uuid" mod="string" readonly="yes">
      <desc>UUID of the snapshot.</desc>
    </attribute>

    <attribute name="name" type="wstring">
      <desc>Short name of the snapshot.
      <note>Setting this attribute causes <link to="IMachine::saveSettings" /> to
      be called implicitly.</note>
      </desc>
    </attribute>

    <attribute name="description" type="wstring">
      <desc>Optional description of the snapshot.
      <note>Setting this attribute causes <link to="IMachine::saveSettings" /> to
      be called implicitly.</note>
      </desc>
    </attribute>

    <attribute name="timeStamp" type="long long" readonly="yes">
      <desc>
        Time stamp of the snapshot, in milliseconds since 1970-01-01 UTC.
      </desc>
    </attribute>

    <attribute name="online" type="boolean" readonly="yes">
      <desc>
        @c true if this snapshot is an online snapshot and @c false otherwise.

          When this attribute is @c true, the
          <link to="IMachine::stateFilePath"/> attribute of the
          <link to="#machine"/> object associated with this snapshot
          will point to the saved state file. Otherwise, it will be
          an empty string.
      </desc>
    </attribute>

    <attribute name="machine" type="IMachine" readonly="yes">
      <desc>
        Virtual machine this snapshot is taken on. This object
        stores all settings the machine had when taking this snapshot.
        <note>
          The returned machine object is immutable, i.e. no
          any settings can be changed.
        </note>
      </desc>
    </attribute>

    <attribute name="parent" type="ISnapshot" readonly="yes">
      <desc>
        Parent snapshot (a snapshot this one is based on), or
        @c null if the snapshot has no parent (i.e. is the first snapshot).
      </desc>
    </attribute>

    <attribute name="children" type="ISnapshot" readonly="yes" safearray="yes">
      <desc>
        Child snapshots (all snapshots having this one as a parent).
        By inspecting this attribute starting with a machine's root snapshot
        (which can be obtained by calling <link to="IMachine::findSnapshot" />
        with a @c null UUID), a machine's snapshots tree can be iterated over.
      </desc>
    </attribute>

    <method name="getChildrenCount" const="yes">
      <desc>
        Returns the number of direct childrens of this snapshot.
      </desc>
      <param name="childrenCount" type="unsigned long" dir="return">
        <desc>
        </desc>
      </param>
    </method>

  </interface>


  <!--
  // IMedium
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="MediumState"
    uuid="ef41e980-e012-43cd-9dea-479d4ef14d13"
    >
    <desc>
      Virtual medium state.
      <see><link to="IMedium"/></see>
    </desc>

    <const name="NotCreated" value="0">
      <desc>
        Associated medium storage does not exist (either was not created yet or
        was deleted).
      </desc>
    </const>
    <const name="Created" value="1">
      <desc>
        Associated storage exists and accessible; this gets set if the
        accessibility check performed by <link to="IMedium::refreshState" />
        was successful.
      </desc>
    </const>
    <const name="LockedRead" value="2">
      <desc>
        Medium is locked for reading (see <link to="IMedium::lockRead"/>),
        no data modification is possible.
      </desc>
    </const>
    <const name="LockedWrite" value="3">
      <desc>
        Medium is locked for writing (see <link to="IMedium::lockWrite"/>),
        no concurrent data reading or modification is possible.
      </desc>
    </const>
    <const name="Inaccessible" value="4">
      <desc>
        Medium accessibility check (see <link to="IMedium::refreshState" />) has
        not yet been performed, or else, associated medium storage is not
        accessible. In the first case, <link to="IMedium::lastAccessError"/>
        is empty, in the second case, it describes the error that occurred.
      </desc>
    </const>
    <const name="Creating" value="5">
      <desc>
        Associated medium storage is being created.
      </desc>
    </const>
    <const name="Deleting" value="6">
      <desc>
        Associated medium storage is being deleted.
      </desc>
    </const>
  </enum>

  <enum
    name="MediumType"
    uuid="fe663fb5-c244-4e1b-9d81-c628b417dd04"
    >
    <desc>
      Virtual medium type. For each <link to="IMedium" />, this defines how the medium is
      attached to a virtual machine (see <link to="IMediumAttachment" />) and what happens
      when a snapshot (see <link to="ISnapshot" />) is taken of a virtual machine which has
      the medium attached. At the moment DVD and floppy media are always of type "writethrough".
    </desc>

    <const name="Normal"            value="0">
      <desc>
        Normal medium (attached directly or indirectly, preserved
        when taking snapshots).
      </desc>
    </const>
    <const name="Immutable"         value="1">
      <desc>
        Immutable medium (attached indirectly, changes are wiped out
        the next time the virtual machine is started).
      </desc>
    </const>
    <const name="Writethrough"      value="2">
      <desc>
        Write through medium (attached directly, ignored when
        taking snapshots).
      </desc>
    </const>
    <const name="Shareable"         value="3">
      <desc>
        Allow using this medium concurrently by several machines.
        <note>Present since VirtualBox 3.2.0, and accepted since 3.2.8.</note>
      </desc>
    </const>
    <const name="Readonly"          value="4">
      <desc>
        A readonly medium, which can of course be used by several machines.
        <note>Present and accepted since VirtualBox 4.0.</note>
      </desc>
    </const>
    <const name="MultiAttach"       value="5">
      <desc>
        A medium which is indirectly attached, so that one base medium can
        be used for several VMs which have their own differencing medium to
        store their modifications. In some sense a variant of Immutable
        with unset AutoReset flag in each differencing medium.
        <note>Present and accepted since VirtualBox 4.0.</note>
      </desc>
    </const>
  </enum>

  <enum
    name="MediumVariant"
    uuid="80685b6b-e42f-497d-8271-e77bf3c61ada"
    >
    <desc>
      Virtual medium image variant. More than one flag may be set.
      <see><link to="IMedium"/></see>
    </desc>

    <const name="Standard"          value="0">
      <desc>
        No particular variant requested, results in using the backend default.
      </desc>
    </const>
    <const name="VmdkSplit2G"       value="0x01">
      <desc>
        VMDK image split in chunks of less than 2GByte.
      </desc>
    </const>
    <const name="VmdkRawDisk"       value="0x02">
      <desc>
        VMDK image representing a raw disk.
      </desc>
    </const>
    <const name="VmdkStreamOptimized" value="0x04">
      <desc>
        VMDK streamOptimized image. Special import/export format which is
        read-only/append-only.
      </desc>
    </const>
    <const name="VmdkESX" value="0x08">
      <desc>
        VMDK format variant used on ESX products.
      </desc>
    </const>
    <const name="Fixed" value="0x10000">
      <desc>
        Fixed image. Only allowed for base images.
      </desc>
    </const>
    <const name="Diff" value="0x20000">
      <desc>
        Differencing image. Only allowed for child images.
      </desc>
    </const>
    <const name="NoCreateDir" value="0x40000000">
      <desc>
        Special flag which suppresses automatic creation of the subdirectory.
        Only used when passing the medium variant as an input parameter.
      </desc>
    </const>
  </enum>

  <interface
    name="IMediumAttachment" extends="$unknown"
    uuid="5ee464d6-0613-4331-b154-7ce12170ef9f"
    wsmap="struct"
    >
    <desc>
      The IMediumAttachment interface links storage media to virtual machines.
      For each medium (<link to="IMedium"/>) which has been attached to a
      storage controller (<link to="IStorageController"/>) of a machine
      (<link to="IMachine"/>) via the <link to="IMachine::attachDevice" />
      method, one instance of IMediumAttachment is added to the machine's
      <link to="IMachine::mediumAttachments"/> array attribute.

      Each medium attachment specifies the storage controller as well as a
      port and device number and the IMedium instance representing a virtual
      hard disk or floppy or DVD image.

      For removable media (DVDs or floppies), there are two additional
      options. For one, the IMedium instance can be @c null to represent
      an empty drive with no media inserted (see <link to="IMachine::mountMedium" />);
      secondly, the medium can be one of the pseudo-media for host drives
      listed in <link to="IHost::DVDDrives"/> or <link to="IHost::floppyDrives"/>.

      <h3>Attaching Hard Disks</h3>

      Hard disks are attached to virtual machines using the
      <link to="IMachine::attachDevice"/> method and detached using the
      <link to="IMachine::detachDevice"/> method. Depending on a medium's
      type (see <link to="IMedium::type" />), hard disks are attached either
      <i>directly</i> or <i>indirectly</i>.

      When a hard disk is being attached directly, it is associated with the
      virtual machine and used for hard disk operations when the machine is
      running. When a hard disk is being attached indirectly, a new differencing
      hard disk linked to it is implicitly created and this differencing hard
      disk is associated with the machine and used for hard disk operations.
      This also means that if <link to="IMachine::attachDevice"/> performs
      a direct attachment then the same hard disk will be returned in response
      to the subsequent  <link to="IMachine::getMedium"/> call; however if
      an indirect attachment is performed then
      <link to="IMachine::getMedium"/> will return the implicitly created
      differencing hard disk, not the original one passed to <link
      to="IMachine::attachDevice"/>. In detail:

      <ul>
        <li><b>Normal base</b> hard disks that do not have children (i.e.
            differencing hard disks linked to them) and that are not already
            attached to virtual machines in snapshots are attached <b>directly</b>.
            Otherwise, they are attached <b>indirectly</b> because having
            dependent children or being part of the snapshot makes it impossible
            to modify hard disk contents without breaking the integrity of the
            dependent party. The <link to="IMedium::readOnly"/> attribute allows to
            quickly determine the kind of the attachment for the given hard
            disk. Note that if a normal base hard disk is to be indirectly
            attached to a virtual machine with snapshots then a special
            procedure called <i>smart attachment</i> is performed (see below).</li>
        <li><b>Normal differencing</b> hard disks are like normal base hard disks:
            they are attached <b>directly</b> if they do not have children and are
            not attached to virtual machines in snapshots, and <b>indirectly</b>
            otherwise. Note that the smart attachment procedure is never performed
            for differencing hard disks.</li>
        <li><b>Immutable</b> hard disks are always attached <b>indirectly</b> because
            they are designed to be non-writable. If an immutable hard disk is
            attached to a virtual machine with snapshots then a special
            procedure called smart attachment is performed (see below).</li>
        <li><b>Writethrough</b> hard disks are always attached <b>directly</b>,
            also as designed. This also means that writethrough hard disks cannot
            have other hard disks linked to them at all.</li>
        <li><b>Shareable</b> hard disks are always attached <b>directly</b>,
            also as designed. This also means that shareable hard disks cannot
            have other hard disks linked to them at all. They behave almost
            like writethrough hard disks, except that shareable hard disks can
            be attached to several virtual machines which are running, allowing
            concurrent accesses. You need special cluster software running in
            the virtual machines to make use of such disks.</li>
      </ul>

      Note that the same hard disk, regardless of its type, may be attached to
      more than one virtual machine at a time. In this case, the machine that is
      started first gains exclusive access to the hard disk and attempts to
      start other machines having this hard disk attached will fail until the
      first machine is powered down.

      Detaching hard disks is performed in a <i>deferred</i> fashion. This means
      that the given hard disk remains associated with the given machine after a
      successful <link to="IMachine::detachDevice"/> call until
      <link to="IMachine::saveSettings"/> is called to save all changes to
      machine settings to disk. This deferring is necessary to guarantee that
      the hard disk configuration may be restored at any time by a call to
      <link to="IMachine::discardSettings"/>  before the settings
      are saved (committed).

      Note that if <link to="IMachine::discardSettings"/> is called after
      indirectly attaching some hard disks to the machine but before a call to
      <link to="IMachine::saveSettings"/> is made, it will implicitly delete
      all differencing hard disks implicitly created by
      <link to="IMachine::attachDevice"/> for these indirect attachments.
      Such implicitly created hard disks will also be immediately deleted when
      detached explicitly using the <link to="IMachine::detachDevice"/>
      call if it is made before <link to="IMachine::saveSettings"/>. This
      implicit deletion is safe because newly created differencing hard
      disks do not contain any user data.

      However, keep in mind that detaching differencing hard disks that were
      implicitly created by <link to="IMachine::attachDevice"/>
      before the last <link to="IMachine::saveSettings"/> call will
      <b>not</b> implicitly delete them as they may already contain some data
      (for example, as a result of virtual machine execution). If these hard
      disks are no more necessary, the caller can always delete them explicitly
      using <link to="IMedium::deleteStorage"/> after they are actually de-associated
      from this machine by the <link to="IMachine::saveSettings"/> call.

      <h3>Smart Attachment</h3>

      When normal base or immutable hard disks are indirectly attached to a
      virtual machine then some additional steps are performed to make sure the
      virtual machine will have the most recent "view" of the hard disk being
      attached. These steps include walking through the machine's snapshots
      starting from the current one and going through ancestors up to the first
      snapshot. Hard disks attached to the virtual machine in all
      of the encountered snapshots are checked whether they are descendants of
      the given normal base or immutable hard disk. The first found child (which
      is the differencing hard disk) will be used instead of the normal base or
      immutable hard disk as a parent for creating a new differencing hard disk
      that will be actually attached to the machine. And only if no descendants
      are found or if the virtual machine does not have any snapshots then the
      normal base or immutable hard disk will be used itself as a parent for
      this differencing hard disk.

      It is easier to explain what smart attachment does using the
      following example:
      <pre>
BEFORE attaching B.vdi:       AFTER attaching B.vdi:

Snapshot 1 (B.vdi)            Snapshot 1 (B.vdi)
 Snapshot 2 (D1->B.vdi)        Snapshot 2 (D1->B.vdi)
  Snapshot 3 (D2->D1.vdi)       Snapshot 3 (D2->D1.vdi)
   Snapshot 4 (none)             Snapshot 4 (none)
    CurState   (none)             CurState   (D3->D2.vdi)

                              NOT
                                 ...
                                  CurState   (D3->B.vdi)
      </pre>
      The first column is the virtual machine configuration before the base hard
      disk <tt>B.vdi</tt> is attached, the second column shows the machine after
      this hard disk is attached. Constructs like <tt>D1->B.vdi</tt> and similar
      mean that the hard disk that is actually attached to the machine is a
      differencing hard disk, <tt>D1.vdi</tt>, which is linked to (based on)
      another hard disk, <tt>B.vdi</tt>.

      As we can see from the example, the hard disk <tt>B.vdi</tt> was detached
      from the machine before taking Snapshot 4. Later, after Snapshot 4 was
      taken, the user decides to attach <tt>B.vdi</tt> again. <tt>B.vdi</tt> has
      dependent child hard disks (<tt>D1.vdi</tt>, <tt>D2.vdi</tt>), therefore
      it cannot be attached directly and needs an indirect attachment (i.e.
      implicit creation of a new differencing hard disk). Due to the smart
      attachment procedure, the new differencing hard disk
      (<tt>D3.vdi</tt>) will be based on <tt>D2.vdi</tt>, not on
      <tt>B.vdi</tt> itself, since <tt>D2.vdi</tt> is the most recent view of
      <tt>B.vdi</tt> existing for this snapshot branch of the given virtual
      machine.

      Note that if there is more than one descendant hard disk of the given base
      hard disk found in a snapshot, and there is an exact device, channel and
      bus match, then this exact match will be used. Otherwise, the youngest
      descendant will be picked up.

      There is one more important aspect of the smart attachment procedure which
      is not related to snapshots at all. Before walking through the snapshots
      as described above, the backup copy of the current list of hard disk
      attachment is searched for descendants. This backup copy is created when
      the hard disk configuration is changed for the first time after the last
      <link to="IMachine::saveSettings"/> call and used by
      <link to="IMachine::discardSettings"/> to undo the recent hard disk
      changes. When such a descendant is found in this backup copy, it will be
      simply re-attached back, without creating a new differencing hard disk for
      it. This optimization is necessary to make it possible to re-attach the
      base or immutable hard disk to a different bus, channel or device slot
      without losing the contents of the differencing hard disk actually
      attached to the machine in place of it.

    </desc>

    <attribute name="medium" type="IMedium" readonly="yes">
      <desc>Medium object associated with this attachment; it
        can be @c null for removable devices.</desc>
    </attribute>

    <attribute name="controller" type="wstring" readonly="yes">
      <desc>Name of the storage controller of this attachment; this
        refers to one of the controllers in <link to="IMachine::storageControllers" />
        by name.</desc>
    </attribute>

    <attribute name="port" type="long" readonly="yes">
      <desc>Port number of this attachment.
        See <link to="IMachine::attachDevice" /> for the meaning of this value for the different controller types.
      </desc>
    </attribute>

    <attribute name="device" type="long" readonly="yes">
      <desc>Device slot number of this attachment.
        See <link to="IMachine::attachDevice" /> for the meaning of this value for the different controller types.
      </desc>
    </attribute>

    <attribute name="type" type="DeviceType" readonly="yes">
      <desc>Device type of this attachment.</desc>
    </attribute>

    <attribute name="passthrough" type="boolean" readonly="yes">
      <desc>Pass I/O requests through to a device on the host.</desc>
    </attribute>

    <attribute name="temporaryEject" type="boolean" readonly="yes">
      <desc>Whether guest-triggered eject results in unmounting the medium.</desc>
    </attribute>

    <attribute name="isEjected" type="boolean" readonly="yes">
      <desc>Signals that the removable medium has been ejected. This is not
        necessarily equivalent to having a @c null medium association.</desc>
    </attribute>

    <attribute name="nonRotational" type="boolean" readonly="yes">
      <desc>Whether the associated medium is non-rotational.</desc>
    </attribute>

    <attribute name="discard" type="boolean" readonly="yes">
      <desc>Whether the associated medium supports discarding unused blocks.</desc>
    </attribute>

    <attribute name="bandwidthGroup" type="IBandwidthGroup" readonly="yes">
      <desc>The bandwidth group this medium attachment is assigned to.</desc>
    </attribute>

  </interface>

  <interface
    name="IMedium" extends="$unknown"
    uuid="29989373-b111-4654-8493-2e1176cba890"
    wsmap="managed"
    >
    <desc>
      The IMedium interface represents virtual storage for a machine's
      hard disks, CD/DVD or floppy drives. It will typically represent
      a disk image on the host, for example a VDI or VMDK file representing
      a virtual hard disk, or an ISO or RAW file representing virtual
      removable media, but can also point to a network location (e.g.
      for iSCSI targets).

      Instances of IMedium are connected to virtual machines by way of medium
      attachments, which link the storage medium to a particular device slot
      of a storage controller of the virtual machine.
      In the VirtualBox API, virtual storage is therefore always represented
      by the following chain of object links:

      <ul>
        <li><link to="IMachine::storageControllers"/> contains an array of
          storage controllers (IDE, SATA, SCSI, SAS or a floppy controller;
          these are instances of <link to="IStorageController"/>).</li>
        <li><link to="IMachine::mediumAttachments"/> contains an array of
          medium attachments (instances of <link to="IMediumAttachment"/>
          created by <link to="IMachine::attachDevice" />),
          each containing a storage controller from the above array, a
          port/device specification, and an instance of IMedium representing
          the medium storage (image file).

          For removable media, the storage medium is optional; a medium
          attachment with no medium represents a CD/DVD or floppy drive
          with no medium inserted. By contrast, hard disk attachments
          will always have an IMedium object attached.</li>
        <li>Each IMedium in turn points to a storage unit (such as a file
          on the host computer or a network resource) that holds actual
          data. This location is represented by the <link to="#location"/>
          attribute.</li>
      </ul>

      Existing media are opened using <link to="IVirtualBox::openMedium"/>;
      new hard disk media can be created with the VirtualBox API using the
      <link to="IVirtualBox::createHardDisk"/> method. Differencing hard
      disks (see below) are usually implicitly created by VirtualBox as
      needed, but may also be created explicitly using <link to="#createDiffStorage"/>.
      VirtualBox cannot create CD/DVD or floppy images (ISO and RAW files); these
      should be created with external tools and then opened from within VirtualBox.

      Only for CD/DVDs and floppies, an IMedium instance can also represent a host
      drive. In that case the <link to="#id" /> attribute contains the UUID of
      one of the drives in <link to="IHost::DVDDrives" /> or <link to="IHost::floppyDrives" />.

      <h3>Media registries</h3>

      When a medium has been opened or created using one of the aforementioned
      APIs, it becomes "known" to VirtualBox. Known media can be attached
      to virtual machines and re-found through <link to="IVirtualBox::openMedium"/>.
      They also appear in the global
      <link to="IVirtualBox::hardDisks" />,
      <link to="IVirtualBox::DVDImages" /> and
      <link to="IVirtualBox::floppyImages" /> arrays.

      Prior to VirtualBox 4.0, opening a medium added it to a global media registry
      in the VirtualBox.xml file, which was shared between all machines and made
      transporting machines and their media from one host to another difficult.

      Starting with VirtualBox 4.0, media are only added to a registry when they are
      <i>attached</i> to a machine using <link to="IMachine::attachDevice" />. For
      backwards compatibility, which registry a medium is added to depends on which
      VirtualBox version created a machine:

      <ul>
        <li>If the medium has first been attached to a machine which was created by
          VirtualBox 4.0 or later, it is added to that machine's media registry in
          the machine XML settings file. This way all information about a machine's
          media attachments is contained in a single file and can be transported
          easily.</li>
        <li>For older media attachments (i.e. if the medium was first attached to a
          machine which was created with a VirtualBox version before 4.0), media
          continue to be registered in the global VirtualBox settings file, for
          backwards compatibility.</li>
      </ul>

      See <link to="IVirtualBox::openMedium" /> for more information.

      Media are removed from media registries by the <link to="IMedium::close"/>,
      <link to="#deleteStorage"/> and  <link to="#mergeTo"/> methods.

      <h3>Accessibility checks</h3>

      VirtualBox defers media accessibility checks until the <link to="#refreshState" />
      method is called explicitly on a medium. This is done to make the VirtualBox object
      ready for serving requests as fast as possible and let the end-user
      application decide if it needs to check media accessibility right away or not.

      As a result, when VirtualBox starts up (e.g. the VirtualBox
      object gets created for the first time), all known media are in the
      "Inaccessible" state, but the value of the <link to="#lastAccessError"/>
      attribute is an empty string because no actual accessibility check has
      been made yet.

      After calling <link to="#refreshState" />, a medium is considered
      <i>accessible</i> if its storage unit can be read. In that case, the
      <link to="#state"/> attribute has a value of "Created". If the storage
      unit cannot be read (for example, because it is located on a disconnected
      network resource, or was accidentally deleted outside VirtualBox),
      the medium is considered <i>inaccessible</i>, which is indicated by the
      "Inaccessible" state. The exact reason why the medium is inaccessible can be
      obtained by reading the <link to="#lastAccessError"/> attribute.

      <h3>Medium types</h3>

      There are five types of medium behavior which are stored in the
      <link to="#type"/> attribute (see <link to="MediumType" />) and
      which define the medium's behavior with attachments and snapshots.

      All media can be also divided in two groups: <i>base</i> media and
      <i>differencing</i> media. A base medium contains all sectors of the
      medium data in its own storage and therefore can be used independently.
      In contrast, a differencing medium is a "delta" to some other medium and
      contains only those sectors which differ from that other medium, which is
      then called a <i>parent</i>. The differencing medium is said to be
      <i>linked to</i> that parent. The parent may be itself a differencing
      medium, thus forming a chain of linked media. The last element in that
      chain must always be a base medium. Note that several differencing
      media may be linked to the same parent medium.

      Differencing media can be distinguished from base media by querying the
      <link to="#parent"/> attribute: base media do not have parents they would
      depend on, so the value of this attribute is always @c null for them.
      Using this attribute, it is possible to walk up the medium tree (from the
      child medium to its parent). It is also possible to walk down the tree
      using the <link to="#children"/> attribute.

      Note that the type of all differencing media is "normal"; all other
      values are meaningless for them. Base media may be of any type.

      <h3>Automatic composition of the file name part</h3>

      Another extension to the <link to="IMedium::location"/> attribute is that
      there is a possibility to cause VirtualBox to compose a unique value for
      the file name part of the location using the UUID of the hard disk. This
      applies only to hard disks in <link to="MediumState_NotCreated"/> state,
      e.g. before the storage unit is created, and works as follows. You set the
      value of the <link to="IMedium::location"/> attribute to a location
      specification which only contains the path specification but not the file
      name part and ends with either a forward slash or a backslash character.
      In response, VirtualBox will generate a new UUID for the hard disk and
      compose the file name using the following pattern:
      <pre>
        &lt;path&gt;/{&lt;uuid&gt;}.&lt;ext&gt;
      </pre>
      where <tt>&lt;path&gt;</tt> is the supplied path specification,
      <tt>&lt;uuid&gt;</tt> is the newly generated UUID and <tt>&lt;ext&gt;</tt>
      is the default extension for the storage format of this hard disk. After
      that, you may call any of the methods that create a new hard disk storage
      unit and they will use the generated UUID and file name.
    </desc>

    <attribute name="id" type="uuid" mod="string" readonly="yes">
      <desc>
        UUID of the medium. For a newly created medium, this value is a randomly
        generated UUID.

        <note>
          For media in one of MediumState_NotCreated, MediumState_Creating or
          MediumState_Deleting states, the value of this property is undefined
          and will most likely be an empty UUID.
        </note>
      </desc>
    </attribute>

    <attribute name="description" type="wstring">
      <desc>
        Optional description of the medium. For a newly created medium the value
        of this attribute is an empty string.

        Medium types that don't support this attribute will return E_NOTIMPL in
        attempt to get or set this attribute's value.

        <note>
          For some storage types, reading this attribute may return an outdated
          (last known) value when <link to="#state"/> is <link
          to="MediumState_Inaccessible"/> or <link
          to="MediumState_LockedWrite"/> because the value of this attribute is
          stored within the storage unit itself. Also note that changing the
          attribute value is not possible in such case, as well as when the
          medium is the <link to="MediumState_LockedRead"/> state.
        </note>
      </desc>
    </attribute>

    <attribute name="state" type="MediumState" readonly="yes">
      <desc>
        Returns the current medium state, which is the last state set by
        the accessibility check performed by <link to="#refreshState"/>.
        If that method has not yet been called on the medium, the state
        is "Inaccessible"; as opposed to truly inaccessible media, the
        value of <link to="#lastAccessError"/> will be an empty string in
        that case.

        <note>As of version 3.1, this no longer performs an accessibility check
          automatically; call <link to="#refreshState"/> for that.
        </note>
      </desc>
    </attribute>

    <attribute name="variant" type="unsigned long" readonly="yes">
      <desc>
        Returns the storage format variant information for this medium
        as a combination of the flags described at <link to="MediumVariant" />.
        Before <link to="#refreshState"/> is called this method returns
        an undefined value.
      </desc>
    </attribute>

    <attribute name="location" type="wstring">
      <desc>
        Location of the storage unit holding medium data.

        The format of the location string is medium type specific. For medium
        types using regular files in a host's file system, the location
        string is the full file name.

        Some medium types may support changing the storage unit location by
        simply changing the value of this property. If this operation is not
        supported, the implementation will return E_NOTIMPL in attempt to set
        this attribute's value.

        When setting a value of the location attribute which is a regular file
        in the host's file system, the given file name may be either relative to
        the <link to="IVirtualBox::homeFolder">VirtualBox home folder</link> or
        absolute. Note that if the given location specification does not contain
        the file extension part then a proper default extension will be
        automatically appended by the implementation depending on the medium type.
      </desc>
    </attribute>

    <attribute name="name" type="wstring" readonly="yes">
      <desc>
        Name of the storage unit holding medium data.

        The returned string is a short version of the <link to="#location"/>
        attribute that is suitable for representing the medium in situations
        where the full location specification is too long (such as lists
        and comboboxes in GUI frontends). This string is also used by frontends
        to sort the media list alphabetically when needed.

        For example, for locations that are regular files in the host's file
        system, the value of this attribute is just the file name (+ extension),
        without the path specification.

        Note that as opposed to the <link to="#location"/> attribute, the name
        attribute will not necessary be unique for a list of media of the
        given type and format.
      </desc>
    </attribute>

    <attribute name="deviceType" type="DeviceType" readonly="yes">
      <desc>Kind of device (DVD/Floppy/HardDisk) which is applicable to this
        medium.</desc>
    </attribute>

    <attribute name="hostDrive" type="boolean" readonly="yes">
      <desc>True if this corresponds to a drive on the host.</desc>
    </attribute>

    <attribute name="size" type="long long" readonly="yes">
      <desc>
        Physical size of the storage unit used to hold medium data (in bytes).

        <note>
          For media whose <link to="#state"/> is <link
          to="MediumState_Inaccessible"/>, the value of this property is the
          last known size. For <link to="MediumState_NotCreated"/> media,
          the returned value is zero.
        </note>
      </desc>
    </attribute>

    <attribute name="format" type="wstring" readonly="yes">
      <desc>
        Storage format of this medium.

        The value of this attribute is a string that specifies a backend used
        to store medium data. The storage format is defined when you create a
        new medium or automatically detected when you open an existing medium,
        and cannot be changed later.

        The list of all storage formats supported by this VirtualBox
        installation can be obtained using
        <link to="ISystemProperties::mediumFormats"/>.
      </desc>
    </attribute>

    <attribute name="mediumFormat" type="IMediumFormat" readonly="yes">
      <desc>
        Storage medium format object corresponding to this medium.

        The value of this attribute is a reference to the medium format object
        that specifies the backend properties used to store medium data. The
        storage format is defined when you create a new medium or automatically
        detected when you open an existing medium, and cannot be changed later.

        <note>@c null is returned if there is no associated medium format
        object. This can e.g. happen for medium objects representing host
        drives and other special medium objects.</note>
      </desc>
    </attribute>

    <attribute name="type" type="MediumType">
      <desc>
        Type (role) of this medium.

        The following constraints apply when changing the value of this
        attribute:
        <ul>
          <li>If a medium is attached to a virtual machine (either in the
              current state or in one of the snapshots), its type cannot be
              changed.
          </li>
          <li>As long as the medium has children, its type cannot be set
              to <link to="MediumType_Writethrough"/>.
          </li>
          <li>The type of all differencing media is
              <link to="MediumType_Normal"/> and cannot be changed.
          </li>
        </ul>

        The type of a newly created or opened medium is set to
        <link to="MediumType_Normal"/>, except for DVD and floppy media,
        which have a type of <link to="MediumType_Writethrough"/>.
      </desc>
    </attribute>

    <attribute name="allowedTypes" type="MediumType" safearray="yes" readonly="yes">
      <desc>
        Returns which medium types can selected for this medium.

        <result name="E_NOTIMPL">
          This attribute is not implemented at the moment.
        </result>
      </desc>
    </attribute>

    <attribute name="parent" type="IMedium" readonly="yes">
      <desc>
        Parent of this medium (the medium this medium is directly based
        on).

        Only differencing media have parents. For base (non-differencing)
        media, @c null is returned.
      </desc>
    </attribute>

    <attribute name="children" type="IMedium" safearray="yes" readonly="yes">
      <desc>
        Children of this medium (all differencing media directly based
        on this medium). A @c null array is returned if this medium
        does not have any children.
      </desc>
    </attribute>

    <attribute name="base" type="IMedium" readonly="yes">
      <desc>
        Base medium of this medium.

        If this is a differencing medium, its base medium is the medium
        the given medium branch starts from. For all other types of media, this
        property returns the medium object itself (i.e. the same object this
        property is read on).
      </desc>
    </attribute>

    <attribute name="readOnly" type="boolean" readonly="yes">
      <desc>
        Returns @c true if this medium is read-only and @c false otherwise.

        A medium is considered to be read-only when its contents cannot be
        modified without breaking the integrity of other parties that depend on
        this medium such as its child media or snapshots of virtual machines
        where this medium is attached to these machines. If there are no
        children and no such snapshots then there is no dependency and the
        medium is not read-only.

        The value of this attribute can be used to determine the kind of the
        attachment that will take place when attaching this medium to a
        virtual machine. If the value is @c false then the medium will
        be attached directly. If the value is @c true then the medium
        will be attached indirectly by creating a new differencing child
        medium for that. See the interface description for more information.

        Note that all <link to="MediumType_Immutable">Immutable</link> media
        are always read-only while all
        <link to="MediumType_Writethrough">Writethrough</link> media are
        always not.

        <note>
          The read-only condition represented by this attribute is related to
          the medium type and usage, not to the current
          <link to="IMedium::state">medium state</link> and not to the read-only
          state of the storage unit.
        </note>
      </desc>
    </attribute>

    <attribute name="logicalSize" type="long long" readonly="yes">
      <desc>
        Logical size of this medium (in bytes), as reported to the
        guest OS running inside the virtual machine this medium is
        attached to. The logical size is defined when the medium is created
        and cannot be changed later.

        <note>
          Reading this property on a differencing medium will return the size
          of its <link to="#base"/> medium.
        </note>
        <note>
          For media whose state is <link to="#state"/> is <link
          to="MediumState_Inaccessible"/>, the value of this property is the
          last known logical size. For <link to="MediumState_NotCreated"/>
          media, the returned value is zero.
        </note>
      </desc>
    </attribute>

    <attribute name="autoReset" type="boolean">
      <desc>
        Whether this differencing medium will be automatically reset each
        time a virtual machine it is attached to is powered up. This
        attribute is automatically set to @c true for the last
        differencing image of an "immutable" medium (see
        <link to="MediumType" />).

        See <link to="#reset"/> for more information about resetting
        differencing media.

        <note>
          Reading this property on a base (non-differencing) medium will
          always @c false. Changing the value of this property in this
          case is not supported.
        </note>

        <result name="VBOX_E_NOT_SUPPORTED">
          This is not a differencing medium (when changing the attribute
          value).
        </result>
      </desc>
    </attribute>

    <attribute name="lastAccessError" type="wstring" readonly="yes">
      <desc>
        Text message that represents the result of the last accessibility
        check performed by <link to="#refreshState"/>.

        An empty string is returned if the last accessibility check
        was successful or has not yet been called. As a result, if
        <link to="#state" /> is "Inaccessible" and this attribute is empty,
        then <link to="#refreshState"/> has yet to be called; this is the
        default value of media after VirtualBox initialization.
        A non-empty string indicates a failure and should normally describe
        a reason of the failure (for example, a file read error).
      </desc>
    </attribute>

    <attribute name="machineIds" type="uuid" mod="string" safearray="yes" readonly="yes">
      <desc>
        Array of UUIDs of all machines this medium is attached to.

        A @c null array is returned if this medium is not attached to any
        machine or to any machine's snapshot.

        <note>
          The returned array will include a machine even if this medium is not
          attached to that machine in the current state but attached to it in
          one of the machine's snapshots. See <link to="#getSnapshotIds"/> for
          details.
        </note>
      </desc>
    </attribute>

    <method name="setIds">
      <desc>
        Changes the UUID and parent UUID for a hard disk medium.
      </desc>
      <param name="setImageId" type="boolean" dir="in">
        <desc>
          Select whether a new image UUID is set or not.
        </desc>
      </param>
      <param name="imageId" type="uuid" mod="string" dir="in">
        <desc>
          New UUID for the image. If an empty string is passed, then a new
          UUID is automatically created, provided that @a setImageId is @c true.
          Specifying a zero UUID is not allowed.
        </desc>
      </param>
      <param name="setParentId" type="boolean" dir="in">
        <desc>
          Select whether a new parent UUID is set or not.
        </desc>
      </param>
      <param name="parentId" type="uuid" mod="string" dir="in">
        <desc>
          New parent UUID for the image. If an empty string is passed, then a
          new UUID is automatically created, provided @a setParentId is
          @c true. A zero UUID is valid.
        </desc>
      </param>
        <result name="E_INVALIDARG">
          Invalid parameter combination.
        </result>
      <result name="VBOX_E_NOT_SUPPORTED">
        Medium is not a hard disk medium.
      </result>
    </method>

    <method name="refreshState">
      <desc>
        If the current medium state (see <link to="MediumState"/>) is one of
        "Created", "Inaccessible" or "LockedRead", then this performs an
        accessibility check on the medium and sets the value of the <link to="#state"/>
        attribute accordingly; that value is also returned for convenience.

        For all other state values, this does not perform a refresh but returns
        the state only.

        The refresh, if performed, may take a long time (several seconds or even
        minutes, depending on the storage unit location and format) because it performs an
        accessibility check of the storage unit. This check may cause a significant
        delay if the storage unit of the given medium is, for example, a file located
        on a network share which is not currently accessible due to connectivity
        problems. In that case, the call will not return until a timeout
        interval defined by the host OS for this operation expires. For this reason,
        it is recommended to never read this attribute on the main UI thread to avoid
        making the UI unresponsive.

        If the last known state of the medium is "Created" and the accessibility
        check fails, then the state would be set to "Inaccessible", and
        <link to="#lastAccessError"/> may be used to get more details about the
        failure. If the state of the medium is "LockedRead", then it remains the
        same, and a non-empty value of <link to="#lastAccessError"/> will
        indicate a failed accessibility check in this case.

        Note that not all medium states are applicable to all medium types.
      </desc>
      <param name="state" type="MediumState" dir="return">
        <desc>
          New medium state.
        </desc>
      </param>
    </method>

    <method name="getSnapshotIds">
      <desc>
        Returns an array of UUIDs of all snapshots of the given machine where
        this medium is attached to.

        If the medium is attached to the machine in the current state, then the
        first element in the array will always be the ID of the queried machine
        (i.e. the value equal to the @c machineId argument), followed by
        snapshot IDs (if any).

        If the medium is not attached to the machine in the current state, then
        the array will contain only snapshot IDs.

        The returned array may be @c null if this medium is not attached
        to the given machine at all, neither in the current state nor in one of
        the snapshots.
      </desc>
      <param name="machineId" type="uuid" mod="string" dir="in">
        <desc>
          UUID of the machine to query.
        </desc>
      </param>
      <param name="snapshotIds" type="uuid" mod="string" safearray="yes" dir="return">
        <desc>
          Array of snapshot UUIDs of the given machine using this medium.
        </desc>
      </param>
    </method>

    <method name="lockRead">
      <desc>
        Locks this medium for reading.

        A read lock is shared: many clients can simultaneously lock the
        same medium for reading unless it is already locked for writing (see
        <link to="#lockWrite"/>) in which case an error is returned.

        When the medium is locked for reading, it cannot be modified
        from within VirtualBox. This means that any method that changes
        the properties of this medium or contents of the storage unit
        will return an error (unless explicitly stated otherwise). That
        includes an attempt to start a virtual machine that wants to
        write to the the medium.

        When the virtual machine is started up, it locks for reading all
        media it uses in read-only mode. If some medium cannot be locked
        for reading, the startup procedure will fail.
        A medium is typically locked for reading while it is used by a running
        virtual machine but has a depending differencing image that receives
        the actual write operations. This way one base medium can have
        multiple child differencing images which can be written to
        simultaneously. Read-only media such as DVD and floppy images are
        also locked for reading only (so they can be in use by multiple
        machines simultaneously).

        A medium is also locked for reading when it is the source of a
        write operation such as <link to="#cloneTo"/> or <link to="#mergeTo"/>.

        The medium locked for reading must be unlocked using the <link
        to="#unlockRead"/> method. Calls to <link to="#lockRead"/>
        can be nested and must be followed by the same number of paired
        <link to="#unlockRead"/> calls.

        This method sets the medium state (see <link to="#state"/>) to
        "LockedRead" on success. The medium's previous state must be
        one of "Created", "Inaccessible" or "LockedRead".

        Locking an inaccessible medium is not an error; this method performs
        a logical lock that prevents modifications of this medium through
        the VirtualBox API, not a physical file-system lock of the underlying
        storage unit.

        This method returns the current state of the medium
        <i>before</i> the operation.

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Invalid medium state (e.g. not created, locked, inaccessible,
          creating, deleting).
        </result>

      </desc>
      <param name="state" type="MediumState" dir="return">
        <desc>
          State of the medium after the operation.
        </desc>
      </param>
    </method>

    <method name="unlockRead">
      <desc>
        Cancels the read lock previously set by <link to="#lockRead"/>.

        For both success and failure, this method returns the current state
        of the medium <i>after</i> the operation.

        See <link to="#lockRead"/> for more details.

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Medium not locked for reading.
        </result>

      </desc>
      <param name="state" type="MediumState" dir="return">
        <desc>
          State of the medium after the operation.
        </desc>
      </param>
    </method>

    <method name="lockWrite">
      <desc>
        Locks this medium for writing.

        A write lock, as opposed to <link to="#lockRead"/>, is
        exclusive: there may be only one client holding a write lock,
        and there may be no read locks while the write lock is held.
        As a result, read-locking fails if a write lock is held, and
        write-locking fails if either a read or another write lock is held.

        When a medium is locked for writing, it cannot be modified
        from within VirtualBox, and it is not guaranteed that the values
        of its properties are up-to-date. Any method that changes the
        properties of this medium or contents of the storage unit will
        return an error (unless explicitly stated otherwise).

        When a virtual machine is started up, it locks for writing all
        media it uses to write data to. If any medium could not be locked
        for writing, the startup procedure will fail. If a medium has
        differencing images, then while the machine is running, only
        the last ("leaf") differencing image is locked for writing,
        whereas its parents are locked for reading only.

        A medium is also locked for writing when it is the target of a
        write operation such as <link to="#cloneTo"/> or <link to="#mergeTo"/>.

        The medium locked for writing must be unlocked using the <link
        to="#unlockWrite"/> method. Write locks <i>cannot</i> be nested.

        This method sets the medium state (see <link to="#state"/>) to
        "LockedWrite" on success. The medium's previous state must be
        either "Created" or "Inaccessible".

        Locking an inaccessible medium is not an error; this method performs
        a logical lock that prevents modifications of this medium through
        the VirtualBox API, not a physical file-system lock of the underlying
        storage unit.

        For both, success and failure, this method returns the current
        state of the medium <i>before</i> the operation.

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Invalid medium state (e.g. not created, locked, inaccessible,
          creating, deleting).
        </result>

      </desc>
      <param name="state" type="MediumState" dir="return">
        <desc>
          State of the medium after the operation.
        </desc>
      </param>
    </method>

    <method name="unlockWrite">
      <desc>
        Cancels the write lock previously set by <link to="#lockWrite"/>.

        For both success and failure, this method returns the current
        state of the medium <i>after</i> the operation.

        See <link to="#lockWrite"/> for more details.

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Medium not locked for writing.
        </result>

      </desc>
      <param name="state" type="MediumState" dir="return">
        <desc>
          State of the medium after the operation.
        </desc>
      </param>
    </method>

    <method name="close">
      <desc>
        Closes this medium.

        The medium must not be attached to any known virtual machine
        and must not have any known child media, otherwise the
        operation will fail.

        When the medium is successfully closed, it is removed from
        the list of registered media, but its storage unit is not
        deleted. In particular, this means that this medium can
        later be opened again using the <link to="IVirtualBox::openMedium"/>
        call.

        Note that after this method successfully returns, the given medium
        object becomes uninitialized. This means that any attempt
        to call any of its methods or attributes will fail with the
        <tt>"Object not ready" (E_ACCESSDENIED)</tt> error.

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Invalid medium state (other than not created, created or
          inaccessible).
        </result>
        <result name="VBOX_E_OBJECT_IN_USE">
          Medium attached to virtual machine.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>

      </desc>
    </method>

    <!-- property methods -->

    <method name="getProperty" const="yes">
      <desc>
        Returns the value of the custom medium property with the given name.

        The list of all properties supported by the given medium format can
        be obtained with <link to="IMediumFormat::describeProperties"/>.

        <note>If this method returns an empty string in @a value, the requested
        property is supported but currently not assigned any value.</note>

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Requested property does not exist (not supported by the format).
        </result>
        <result name="E_INVALIDARG">@a name is @c null or empty.</result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the property to get.</desc>
      </param>
      <param name="value" type="wstring" dir="return">
        <desc>Current property value.</desc>
      </param>
    </method>

    <method name="setProperty">
      <desc>
        Sets the value of the custom medium property with the given name.

        The list of all properties supported by the given medium format can
        be obtained with <link to="IMediumFormat::describeProperties"/>.

        <note>Setting the property value to @c null or an empty string is
        equivalent to deleting the existing value. A default value (if it is
        defined for this property) will be used by the format backend in this
        case.</note>

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Requested property does not exist (not supported by the format).
        </result>
        <result name="E_INVALIDARG">@a name is @c null or empty.</result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the property to set.</desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>Property value to set.</desc>
      </param>
    </method>

    <method name="getProperties" const="yes">
      <desc>
        Returns values for a group of properties in one call.

        The names of the properties to get are specified using the @a names
        argument which is a list of comma-separated property names or
        an empty string if all properties are to be returned.
        <note>Currently the value of this argument is ignored and the method
        always returns all existing properties.</note>

        The list of all properties supported by the given medium format can
        be obtained with <link to="IMediumFormat::describeProperties"/>.

        The method returns two arrays, the array of property names corresponding
        to the @a names argument and the current values of these properties.
        Both arrays have the same number of elements with each element at the
        given index in the first array corresponds to an element at the same
        index in the second array.

        For properties that do not have assigned values, an empty string is
        returned at the appropriate index in the @a returnValues array.

      </desc>
      <param name="names" type="wstring" dir="in">
        <desc>
          Names of properties to get.
        </desc>
      </param>
      <param name="returnNames" type="wstring" safearray="yes" dir="out">
        <desc>Names of returned properties.</desc>
      </param>
      <param name="returnValues" type="wstring" safearray="yes" dir="return">
        <desc>Values of returned properties.</desc>
      </param>
    </method>

    <method name="setProperties">
      <desc>
        Sets values for a group of properties in one call.

        The names of the properties to set are passed in the @a names
        array along with the new values for them in the @a values array. Both
        arrays have the same number of elements with each element at the given
        index in the first array corresponding to an element at the same index
        in the second array.

        If there is at least one property name in @a names that is not valid,
        the method will fail before changing the values of any other properties
        from the @a names array.

        Using this method over <link to="#setProperty"/> is preferred if you
        need to set several properties at once since it is more efficient.

        The list of all properties supported by the given medium format can
        be obtained with <link to="IMediumFormat::describeProperties"/>.

        Setting the property value to @c null or an empty string is equivalent
        to deleting the existing value. A default value (if it is defined for
        this property) will be used by the format backend in this case.
      </desc>
      <param name="names" type="wstring" safearray="yes" dir="in">
        <desc>Names of properties to set.</desc>
      </param>
      <param name="values" type="wstring" safearray="yes" dir="in">
        <desc>Values of properties to set.</desc>
      </param>
    </method>

    <!-- storage methods -->

    <method name="createBaseStorage">
      <desc>
        Starts creating a hard disk storage unit (fixed/dynamic, according
        to the variant flags) in in the background. The previous storage unit
        created for this object, if any, must first be deleted using
        <link to="#deleteStorage"/>, otherwise the operation will fail.

        Before the operation starts, the medium is placed in
        <link to="MediumState_Creating"/> state. If the create operation
        fails, the medium will be placed back in <link to="MediumState_NotCreated"/>
        state.

        After the returned progress object reports that the operation has
        successfully completed, the medium state will be set to <link
        to="MediumState_Created"/>, the medium will be remembered by this
        VirtualBox installation and may be attached to virtual machines.

        <result name="VBOX_E_NOT_SUPPORTED">
          The variant of storage creation operation is not supported. See <link
          to="IMediumFormat::capabilities"/>.
        </result>
      </desc>
      <param name="logicalSize" type="long long" dir="in">
        <desc>Maximum logical size of the medium in bytes.</desc>
      </param>
      <param name="variant" type="unsigned long" dir="in">
        <desc>Exact image variant which should be created (as a combination of
          <link to="MediumVariant" /> flags).</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="deleteStorage">
      <desc>
        Starts deleting the storage unit of this medium.

        The medium must not be attached to any known virtual machine and must
        not have any known child media, otherwise the operation will fail.
        It will also fail if there is no storage unit to delete or if deletion
        is already in progress, or if the medium is being in use (locked for
        read or for write) or inaccessible. Therefore, the only valid state for
        this operation to succeed is <link to="MediumState_Created"/>.

        Before the operation starts, the medium is placed in
        <link to="MediumState_Deleting"/> state and gets removed from the list
        of remembered hard disks (media registry). If the delete operation
        fails, the medium will be remembered again and placed back to
        <link to="MediumState_Created"/> state.

        After the returned progress object reports that the operation is
        complete, the medium state will be set to
        <link to="MediumState_NotCreated"/> and you will be able to use one of
        the storage creation methods to create it again.

        <see><link to="#close"/></see>

        <result name="VBOX_E_OBJECT_IN_USE">
          Medium is attached to a virtual machine.
        </result>
        <result name="VBOX_E_NOT_SUPPORTED">
          Storage deletion is not allowed because neither of storage creation
          operations are supported. See
          <link to="IMediumFormat::capabilities"/>.
        </result>

        <note>
          If the deletion operation fails, it is not guaranteed that the storage
          unit still exists. You may check the <link to="IMedium::state"/> value
          to answer this question.
        </note>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <!-- diff methods -->

    <method name="createDiffStorage">
      <desc>
        Starts creating an empty differencing storage unit based on this
        medium in the format and at the location defined by the @a target
        argument.

        The target medium must be in <link to="MediumState_NotCreated"/>
        state (i.e. must not have an existing storage unit). Upon successful
        completion, this operation will set the type of the target medium to
        <link to="MediumType_Normal"/> and create a storage unit necessary to
        represent the differencing medium data in the given format (according
        to the storage format of the target object).

        After the returned progress object reports that the operation is
        successfully complete, the target medium gets remembered by this
        VirtualBox installation and may be attached to virtual machines.

        <note>
          The medium will be set to <link to="MediumState_LockedRead"/>
          state for the duration of this operation.
        </note>
        <result name="VBOX_E_OBJECT_IN_USE">
          Medium not in @c NotCreated state.
        </result>
      </desc>
      <param name="target" type="IMedium" dir="in">
        <desc>Target medium.</desc>
      </param>
      <param name="variant" type="unsigned long" dir="in">
        <desc>Exact image variant which should be created (as a combination of
          <link to="MediumVariant" /> flags).</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="mergeTo">
      <desc>
        Starts merging the contents of this medium and all intermediate
        differencing media in the chain to the given target medium.

        The target medium must be either a descendant of this medium or
        its ancestor (otherwise this method will immediately return a failure).
        It follows that there are two logical directions of the merge operation:
        from ancestor to descendant (<i>forward merge</i>) and from descendant to
        ancestor (<i>backward merge</i>). Let us consider the following medium
        chain:

        <pre>Base &lt;- Diff_1 &lt;- Diff_2</pre>

        Here, calling this method on the <tt>Base</tt> medium object with
        <tt>Diff_2</tt> as an argument will be a forward merge; calling it on
        <tt>Diff_2</tt> with <tt>Base</tt> as an argument will be a backward
        merge. Note that in both cases the contents of the resulting medium
        will be the same, the only difference is the medium object that takes
        the result of the merge operation. In case of the forward merge in the
        above example, the result will be written to <tt>Diff_2</tt>; in case of
        the backward merge, the result will be written to <tt>Base</tt>. In
        other words, the result of the operation is always stored in the target
        medium.

        Upon successful operation completion, the storage units of all media in
        the chain between this (source) medium and the target medium, including
        the source medium itself, will be automatically deleted and the
        relevant medium objects (including this medium) will become
        uninitialized. This means that any attempt to call any of
        their methods or attributes will fail with the
        <tt>"Object not ready" (E_ACCESSDENIED)</tt> error. Applied to the above
        example, the forward merge of <tt>Base</tt> to <tt>Diff_2</tt> will
        delete and uninitialize both <tt>Base</tt> and <tt>Diff_1</tt> media.
        Note that <tt>Diff_2</tt> in this case will become a base medium
        itself since it will no longer be based on any other medium.

        Considering the above, all of the following conditions must be met in
        order for the merge operation to succeed:
        <ul>
          <li>
            Neither this (source) medium nor any intermediate
            differencing medium in the chain between it and the target
            medium is attached to any virtual machine.
          </li>
          <li>
            Neither the source medium nor the target medium is an
            <link to="MediumType_Immutable"/> medium.
          </li>
          <li>
            The part of the medium tree from the source medium to the
            target medium is a linear chain, i.e. all medium in this
            chain have exactly one child which is the next medium in this
            chain. The only exception from this rule is the target medium in
            the forward merge operation; it is allowed to have any number of
            child media because the merge operation will not change its
            logical contents (as it is seen by the guest OS or by children).
          </li>
          <li>
            None of the involved media are in
            <link to="MediumState_LockedRead"/> or
            <link to="MediumState_LockedWrite"/> state.
          </li>
        </ul>

        <note>
          This (source) medium and all intermediates will be placed to <link
          to="MediumState_Deleting"/> state and the target medium will be
          placed to <link to="MediumState_LockedWrite"/> state and for the
          duration of this operation.
        </note>
      </desc>
      <param name="target" type="IMedium" dir="in">
        <desc>Target medium.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <!-- clone method -->

    <method name="cloneTo">
      <desc>
        Starts creating a clone of this medium in the format and at the
        location defined by the @a target argument.

        The target medium must be either in <link to="MediumState_NotCreated"/>
        state (i.e. must not have an existing storage unit) or in
        <link to="MediumState_Created"/> state (i.e. created and not locked, and
        big enough to hold the data or else the copy will be partial). Upon
        successful completion, the cloned medium will contain exactly the
        same sector data as the medium being cloned, except that in the
        first case a new UUID for the clone will be randomly generated, and in
        the second case the UUID will remain unchanged.

        The @a parent argument defines which medium will be the parent
        of the clone. Passing a @c null reference indicates that the clone will
        be a base image, i.e. completely independent. It is possible to specify
        an arbitrary medium for this parameter, including the parent of the
        medium which is being cloned. Even cloning to a child of the source
        medium is possible. Note that when cloning to an existing image, the
        @a parent argument is ignored.

        After the returned progress object reports that the operation is
        successfully complete, the target medium gets remembered by this
        VirtualBox installation and may be attached to virtual machines.

        <note>
          This medium will be placed to <link to="MediumState_LockedRead"/>
          state for the duration of this operation.
        </note>
        <result name="E_NOTIMPL">
          The specified cloning variant is not supported at the moment.
        </result>
      </desc>
      <param name="target" type="IMedium" dir="in">
        <desc>Target medium.</desc>
      </param>
      <param name="variant" type="unsigned long" dir="in">
        <desc>Exact image variant which should be created (as a combination of
          <link to="MediumVariant" /> flags).</desc>
      </param>
      <param name="parent" type="IMedium" dir="in">
        <desc>Parent of the cloned medium.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="cloneToBase">
    <desc>
    Starts creating a clone of this medium in the format and at the
    location defined by the @a target argument.

    The target medium must be either in <link to="MediumState_NotCreated"/>
    state (i.e. must not have an existing storage unit) or in
    <link to="MediumState_Created"/> state (i.e. created and not locked, and
    big enough to hold the data or else the copy will be partial). Upon
    successful completion, the cloned medium will contain exactly the
    same sector data as the medium being cloned, except that in the
    first case a new UUID for the clone will be randomly generated, and in
    the second case the UUID will remain unchanged.

    The @a parent argument defines which medium will be the parent
    of the clone. In this case the clone will be a base image, i.e.
    completely independent. It is possible to specify an arbitrary
    medium for this parameter, including the parent of the
    medium which is being cloned. Even cloning to a child of the source
    medium is possible. Note that when cloning to an existing image, the
    @a parent argument is ignored.

    After the returned progress object reports that the operation is
    successfully complete, the target medium gets remembered by this
    VirtualBox installation and may be attached to virtual machines.

    <note>
    This medium will be placed to <link to="MediumState_LockedRead"/>
    state for the duration of this operation.
    </note>
    <result name="E_NOTIMPL">
    The specified cloning variant is not supported at the moment.
    </result>
    </desc>
    <param name="target" type="IMedium" dir="in">
    <desc>Target medium.</desc>
    </param>
    <param name="variant" type="unsigned long" dir="in">
    <desc>Exact image variant which should be created (as a combination of
    <link to="MediumVariant" /> flags).</desc>
    </param>
    <param name="progress" type="IProgress" dir="return">
    <desc>Progress object to track the operation completion.</desc>
    </param>
    </method>

    <!-- other methods -->

    <method name="compact">
      <desc>
        Starts compacting of this medium. This means that the medium is
        transformed into a possibly more compact storage representation.
        This potentially creates temporary images, which can require a
        substantial amount of additional disk space.

        This medium will be placed to <link to="MediumState_LockedWrite"/>
        state and all its parent media (if any) will be placed to
        <link to="MediumState_LockedRead"/> state for the duration of this
        operation.

        Please note that the results can be either returned straight away,
        or later as the result of the background operation via the object
        returned via the @a progress parameter.

        <result name="VBOX_E_NOT_SUPPORTED">
          Medium format does not support compacting (but potentially
          needs it).
        </result>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="resize">
      <desc>
        Starts resizing this medium. This means that the nominal size of the
        medium is set to the new value. Both increasing and decreasing the
        size is possible, and there are no safety checks, since VirtualBox
        does not make any assumptions about the medium contents.

        Resizing usually needs additional disk space, and possibly also
        some temporary disk space. Note that resize does not create a full
        temporary copy of the medium, so the additional disk space requirement
        is usually much lower than using the clone operation.

        This medium will be placed to <link to="MediumState_LockedWrite"/>
        state for the duration of this operation.

        Please note that the results can be either returned straight away,
        or later as the result of the background operation via the object
        returned via the @a progress parameter.

        <result name="VBOX_E_NOT_SUPPORTED">
          Medium format does not support resizing.
        </result>
      </desc>
      <param name="logicalSize" type="long long" dir="in">
        <desc>New nominal capacity of the medium in bytes.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="reset">
      <desc>
        Starts erasing the contents of this differencing medium.

        This operation will reset the differencing medium to its initial
        state when it does not contain any sector data and any read operation is
        redirected to its parent medium. This automatically gets called
        during VM power-up for every medium whose <link to="#autoReset" />
        attribute is @c true.

        The medium will be write-locked for the duration of this operation (see
        <link to="#lockWrite" />).

        <result name="VBOX_E_NOT_SUPPORTED">
          This is not a differencing medium.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Medium is not in <link to="MediumState_Created"/> or
          <link to="MediumState_Inaccessible"/> state.
        </result>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

  </interface>


  <!--
  // IMediumFormat
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="DataType"
    uuid="d90ea51e-a3f1-4a01-beb1-c1723c0d3ba7"
    >
    <const name="Int32" value="0"/>
    <const name="Int8" value="1"/>
    <const name="String" value="2"/>
  </enum>

  <enum
    name="DataFlags"
    uuid="86884dcf-1d6b-4f1b-b4bf-f5aa44959d60"
    >
    <const name="None" value="0x00"/>
    <const name="Mandatory" value="0x01"/>
    <const name="Expert" value="0x02"/>
    <const name="Array" value="0x04"/>
    <const name="FlagMask" value="0x07"/>
  </enum>

  <enum
    name="MediumFormatCapabilities"
    uuid="7342ba79-7ce0-4d94-8f86-5ed5a185d9bd"
    >
    <desc>
      Medium format capability flags.
    </desc>

    <const name="Uuid" value="0x01">
      <desc>
        Supports UUIDs as expected by VirtualBox code.
      </desc>
    </const>

    <const name="CreateFixed" value="0x02">
      <desc>
        Supports creating fixed size images, allocating all space instantly.
      </desc>
    </const>

    <const name="CreateDynamic" value="0x04">
      <desc>
        Supports creating dynamically growing images, allocating space on
        demand.
      </desc>
    </const>

    <const name="CreateSplit2G" value="0x08">
      <desc>
        Supports creating images split in chunks of a bit less than 2 GBytes.
      </desc>
    </const>

    <const name="Differencing" value="0x10">
      <desc>
        Supports being used as a format for differencing media (see <link
        to="IMedium::createDiffStorage"/>).
      </desc>
    </const>

    <const name="Asynchronous" value="0x20">
      <desc>
        Supports asynchronous I/O operations for at least some configurations.
      </desc>
    </const>

    <const name="File" value="0x40">
      <desc>
        The format backend operates on files (the <link to="IMedium::location"/>
        attribute of the medium specifies a file used to store medium
        data; for a list of supported file extensions see
        <link to="IMediumFormat::describeFileExtensions"/>).
      </desc>
    </const>

    <const name="Properties" value="0x80">
      <desc>
        The format backend uses the property interface to configure the storage
        location and properties (the <link to="IMediumFormat::describeProperties"/>
        method is used to get access to properties supported by the given medium format).
      </desc>
    </const>

    <const name="TcpNetworking" value="0x100">
      <desc>
        The format backend uses the TCP networking interface for network access.
      </desc>
    </const>

    <const name="VFS" value="0x200">
      <desc>
        The format backend supports virtual filesystem functionality.
      </desc>
    </const>

    <const name="CapabilityMask" value="0x3FF"/>
  </enum>

  <interface
    name="IMediumFormat" extends="$unknown"
    uuid="9bd5b655-ea47-4637-99f3-aad0948be35b"
    wsmap="managed"
    >
    <desc>
        The IMediumFormat interface represents a medium format.

        Each medium format has an associated backend which is used to handle
        media stored in this format. This interface provides information
        about the properties of the associated backend.

        Each medium format is identified by a string represented by the
        <link to="#id"/> attribute. This string is used in calls like
        <link to="IVirtualBox::createHardDisk"/> to specify the desired
        format.

        The list of all supported medium formats can be obtained using
        <link to="ISystemProperties::mediumFormats"/>.

        <see><link to="IMedium"/></see>
    </desc>

    <attribute name="id" type="wstring" readonly="yes">
      <desc>
        Identifier of this format.

        The format identifier is a non-@c null non-empty ASCII string. Note that
        this string is case-insensitive. This means that, for example, all of
        the following strings:
        <pre>
          "VDI"
          "vdi"
          "VdI"</pre>
        refer to the same medium format.

        This string is used in methods of other interfaces where it is necessary
        to specify a medium format, such as
        <link to="IVirtualBox::createHardDisk"/>.
      </desc>
    </attribute>

    <attribute name="name" type="wstring" readonly="yes">
      <desc>
        Human readable description of this format.

        Mainly for use in file open dialogs.
      </desc>
    </attribute>

    <attribute name="capabilities" type="unsigned long" readonly="yes">
      <desc>
        Capabilities of the format as a set of bit flags.

        For the meaning of individual capability flags see
        <link to="MediumFormatCapabilities"/>.
      </desc>
    </attribute>

    <method name="describeFileExtensions">
      <desc>
        Returns two arrays describing the supported file extensions.

        The first array contains the supported extensions and the seconds one
        the type each extension supports. Both have the same size.

        Note that some backends do not work on files, so this array may be
        empty.

        <see><link to="IMediumFormat::capabilities"/></see>
      </desc>
      <param  name="extensions" type="wstring" safearray="yes" dir="out">
        <desc>The array of supported extensions.</desc>
      </param>
      <param  name="type" type="DeviceType" safearray="yes" dir="out">
        <desc>The array which indicates the device type for every given extension.</desc>
      </param>
    </method>

    <method name="describeProperties" const="yes">
      <desc>
        Returns several arrays describing the properties supported by this
        format.

        An element with the given index in each array describes one
        property. Thus, the number of elements in each returned array is the
        same and corresponds to the number of supported properties.

        The returned arrays are filled in only if the
        <link to="MediumFormatCapabilities_Properties"/> flag is set.
        All arguments must be non-@c null.

        <see><link to="DataType"/>, <link to="DataFlags"/></see>
      </desc>

      <param name="names" type="wstring" safearray="yes" dir="out">
        <desc>Array of property names.</desc>
      </param>
      <param name="description" type="wstring" safearray="yes" dir="out">
        <desc>Array of property descriptions.</desc>
      </param>
      <param name="types" type="DataType" safearray="yes" dir="out">
        <desc>Array of property types.</desc>
      </param>
      <param name="flags" type="unsigned long" safearray="yes" dir="out">
        <desc>Array of property flags.</desc>
      </param>
      <param name="defaults" type="wstring" safearray="yes" dir="out">
        <desc>Array of default property values.</desc>
      </param>
    </method>

  </interface>


  <!--
  // IKeyboard
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IKeyboard" extends="$unknown"
    uuid="f6916ec5-a881-4237-898f-7de58cf88672"
    wsmap="managed"
    >
    <desc>
      The IKeyboard interface represents the virtual machine's keyboard. Used
      in <link to="IConsole::keyboard"/>.

      Use this interface to send keystrokes or the Ctrl-Alt-Del sequence
      to the virtual machine.

    </desc>
    <method name="putScancode">
      <desc>Sends a scancode to the keyboard.

        <result name="VBOX_E_IPRT_ERROR">
          Could not send scan code to virtual keyboard.
        </result>

      </desc>
      <param name="scancode" type="long" dir="in"/>
    </method>

    <method name="putScancodes">
      <desc>Sends an array of scancodes to the keyboard.

        <result name="VBOX_E_IPRT_ERROR">
          Could not send all scan codes to virtual keyboard.
        </result>

      </desc>
      <param name="scancodes" type="long" dir="in" safearray="yes"/>
      <param name="codesStored" type="unsigned long" dir="return"/>
    </method>

    <method name="putCAD">
      <desc>Sends the Ctrl-Alt-Del sequence to the keyboard. This
      function is nothing special, it is just a convenience function
      calling <link to="IKeyboard::putScancodes"/> with the proper scancodes.

        <result name="VBOX_E_IPRT_ERROR">
          Could not send all scan codes to virtual keyboard.
        </result>

      </desc>
    </method>

    <attribute name="eventSource" type="IEventSource" readonly="yes">
      <desc>
        Event source for keyboard events.
      </desc>
    </attribute>

  </interface>


  <!--
  // IMouse
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="MouseButtonState"
    uuid="9ee094b8-b28a-4d56-a166-973cb588d7f8"
    >
    <desc>
      Mouse button state.
    </desc>

    <const name="LeftButton"        value="0x01"/>
    <const name="RightButton"       value="0x02"/>
    <const name="MiddleButton"      value="0x04"/>
    <const name="WheelUp"           value="0x08"/>
    <const name="WheelDown"         value="0x10"/>
    <const name="XButton1"          value="0x20"/>
    <const name="XButton2"          value="0x40"/>
    <const name="MouseStateMask"    value="0x7F"/>
  </enum>

  <interface
    name="IMouse" extends="$unknown"
    uuid="05044a52-7811-4f00-ae3a-0ab7ff707b10"
    wsmap="managed"
    >
    <desc>
      The IMouse interface represents the virtual machine's mouse. Used in
      <link to="IConsole::mouse"/>.

      Through this interface, the virtual machine's virtual mouse can be
      controlled.
    </desc>

    <attribute name="absoluteSupported" type="boolean" readonly="yes">
      <desc>
        Whether the guest OS supports absolute mouse pointer positioning
        or not.
        <note>
          You can use the <link to="IMouseCapabilityChangedEvent"/>
          event to be instantly informed about changes of this attribute
          during virtual machine execution.
        </note>
        <see><link to="#putMouseEventAbsolute"/></see>
      </desc>
    </attribute>

    <attribute name="relativeSupported" type="boolean" readonly="yes">
      <desc>
        Whether the guest OS supports relative mouse pointer positioning
        or not.
        <note>
          You can use the <link to="IMouseCapabilityChangedEvent"/>
          event to be instantly informed about changes of this attribute
          during virtual machine execution.
        </note>
        <see><link to="#putMouseEvent"/></see>
      </desc>
    </attribute>

    <attribute name="needsHostCursor" type="boolean" readonly="yes">
      <desc>
        Whether the guest OS can currently switch to drawing it's own mouse
        cursor on demand.
        <note>
          You can use the <link to="IMouseCapabilityChangedEvent"/>
          event to be instantly informed about changes of this attribute
          during virtual machine execution.
        </note>
        <see><link to="#putMouseEvent"/></see>
      </desc>
    </attribute>

    <method name="putMouseEvent">
      <desc>
        Initiates a mouse event using relative pointer movements
        along x and y axis.

        <result name="E_ACCESSDENIED">
          Console not powered up.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not send mouse event to virtual mouse.
        </result>

      </desc>

      <param name="dx" type="long" dir="in">
        <desc>
          Amount of pixels the mouse should move to the right.
          Negative values move the mouse to the left.
        </desc>
      </param>
      <param name="dy" type="long" dir="in">
        <desc>
          Amount of pixels the mouse should move downwards.
          Negative values move the mouse upwards.
        </desc>
      </param>
      <param name="dz" type="long" dir="in">
        <desc>
          Amount of mouse wheel moves.
          Positive values describe clockwise wheel rotations,
          negative values describe counterclockwise rotations.
        </desc>
      </param>
      <param name="dw" type="long" dir="in">
        <desc>
          Amount of horizontal mouse wheel moves.
          Positive values describe a movement to the left,
          negative values describe a movement to the right.
        </desc>
      </param>
      <param name="buttonState" type="long" dir="in">
        <desc>
          The current state of mouse buttons. Every bit represents
          a mouse button as follows:
          <table>
            <tr><td>Bit 0 (<tt>0x01</tt>)</td><td>left mouse button</td></tr>
            <tr><td>Bit 1 (<tt>0x02</tt>)</td><td>right mouse button</td></tr>
            <tr><td>Bit 2 (<tt>0x04</tt>)</td><td>middle mouse button</td></tr>
          </table>
          A value of <tt>1</tt> means the corresponding button is pressed.
          otherwise it is released.
        </desc>
      </param>
    </method>

    <method name="putMouseEventAbsolute">
      <desc>
        Positions the mouse pointer using absolute x and y coordinates.
        These coordinates are expressed in pixels and
        start from <tt>[1,1]</tt> which corresponds to the top left
        corner of the virtual display.

        <result name="E_ACCESSDENIED">
          Console not powered up.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not send mouse event to virtual mouse.
        </result>

        <note>
          This method will have effect only if absolute mouse
          positioning is supported by the guest OS.
        </note>

        <see><link to="#absoluteSupported"/></see>
      </desc>

      <param name="x" type="long" dir="in">
        <desc>
          X coordinate of the pointer in pixels, starting from @c 1.
        </desc>
      </param>
      <param name="y" type="long" dir="in">
        <desc>
          Y coordinate of the pointer in pixels, starting from @c 1.
        </desc>
      </param>
      <param name="dz" type="long" dir="in">
        <desc>
          Amount of mouse wheel moves.
          Positive values describe clockwise wheel rotations,
          negative values describe counterclockwise rotations.
        </desc>
      </param>
      <param name="dw" type="long" dir="in">
        <desc>
          Amount of horizontal mouse wheel moves.
          Positive values describe a movement to the left,
          negative values describe a movement to the right.
        </desc>
      </param>
      <param name="buttonState" type="long" dir="in">
        <desc>
          The current state of mouse buttons. Every bit represents
          a mouse button as follows:
          <table>
            <tr><td>Bit 0 (<tt>0x01</tt>)</td><td>left mouse button</td></tr>
            <tr><td>Bit 1 (<tt>0x02</tt>)</td><td>right mouse button</td></tr>
            <tr><td>Bit 2 (<tt>0x04</tt>)</td><td>middle mouse button</td></tr>
          </table>
          A value of @c 1 means the corresponding button is pressed.
          otherwise it is released.
        </desc>
      </param>
    </method>

    <attribute name="eventSource" type="IEventSource" readonly="yes">
      <desc>
        Event source for mouse events.
      </desc>
    </attribute>

  </interface>

  <!--
  // IDisplay
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="FramebufferPixelFormat"
    uuid="7acfd5ed-29e3-45e3-8136-73c9224f3d2d"
    >
    <desc>
      Format of the video memory buffer. Constants represented by this enum can
      be used to test for particular values of <link
      to="IFramebuffer::pixelFormat"/>. See also <link
      to="IFramebuffer::requestResize"/>.

      See also www.fourcc.org for more information about FOURCC pixel formats.
    </desc>

    <const name="Opaque"                  value="0">
      <desc>
        Unknown buffer format (the user may not assume any particular format of
        the buffer).
      </desc>
    </const>
    <const name="FOURCC_RGB"              value="0x32424752">
      <desc>
        Basic RGB format (<link to="IFramebuffer::bitsPerPixel"/> determines the
        bit layout).
      </desc>
    </const>
  </enum>

  <interface
    name="IFramebuffer" extends="$unknown"
    uuid="b7ed347a-5765-40a0-ae1c-f543eb4ddeaf"
    wsmap="suppress"
    >
    <attribute name="address" type="octet" mod="ptr" readonly="yes">
      <desc>Address of the start byte of the frame buffer.</desc>
    </attribute>

    <attribute name="width" type="unsigned long" readonly="yes">
      <desc>Frame buffer width, in pixels.</desc>
    </attribute>

    <attribute name="height" type="unsigned long" readonly="yes">
      <desc>Frame buffer height, in pixels.</desc>
    </attribute>

    <attribute name="bitsPerPixel" type="unsigned long" readonly="yes">
      <desc>
        Color depth, in bits per pixel. When <link to="#pixelFormat"/> is <link
        to="FramebufferPixelFormat_FOURCC_RGB">FOURCC_RGB</link>, valid values
        are: 8, 15, 16, 24 and 32.
      </desc>
    </attribute>

    <attribute name="bytesPerLine" type="unsigned long" readonly="yes">
      <desc>
        Scan line size, in bytes. When <link to="#pixelFormat"/> is <link
        to="FramebufferPixelFormat_FOURCC_RGB">FOURCC_RGB</link>, the
        size of the scan line must be aligned to 32 bits.
      </desc>
    </attribute>

    <attribute name="pixelFormat" type="unsigned long" readonly="yes">
      <desc>
        Frame buffer pixel format. It's either one of the values defined by <link
        to="FramebufferPixelFormat"/> or a raw FOURCC code.
        <note>
          This attribute must never return <link
          to="FramebufferPixelFormat_Opaque"/> -- the format of the buffer
          <link to="#address"/> points to must be always known.
        </note>
      </desc>
    </attribute>

    <attribute name="usesGuestVRAM" type="boolean" readonly="yes">
      <desc>
        Defines whether this frame buffer uses the virtual video card's memory
        buffer (guest VRAM) directly or not. See <link
        to="IFramebuffer::requestResize"/> for more information.
      </desc>
    </attribute>

    <attribute name="heightReduction" type="unsigned long" readonly="yes">
      <desc>
        Hint from the frame buffer about how much of the standard
        screen height it wants to use for itself. This information is
        exposed to the guest through the VESA BIOS and VMMDev interface
        so that it can use it for determining its video mode table. It
        is not guaranteed that the guest respects the value.
      </desc>
    </attribute>

    <attribute name="overlay" type="IFramebufferOverlay" readonly="yes">
      <desc>
        An alpha-blended overlay which is superposed over the frame buffer.
        The initial purpose is to allow the display of icons providing
        information about the VM state, including disk activity, in front
        ends which do not have other means of doing that.  The overlay is
        designed to controlled exclusively by IDisplay.  It has no locking
        of its own, and any changes made to it are not guaranteed to be
        visible until the affected portion of IFramebuffer is updated.  The
        overlay can be created lazily the first time it is requested.  This
        attribute can also return @c null to signal that the overlay is not
        implemented.
      </desc>
    </attribute>

    <attribute name="winId" type="long long" readonly="yes">
      <desc>
        Platform-dependent identifier of the window where context of this
        frame buffer is drawn, or zero if there's no such window.
      </desc>
    </attribute>

    <method name="lock">
      <desc>
        Locks the frame buffer.
        Gets called by the IDisplay object where this frame buffer is
        bound to.
      </desc>
    </method>

    <method name="unlock">
      <desc>
        Unlocks the frame buffer.
        Gets called by the IDisplay object where this frame buffer is
        bound to.
      </desc>
    </method>

    <method name="notifyUpdate">
      <desc>
        Informs about an update.
        Gets called by the display object where this buffer is
        registered.
      </desc>
      <param name="x" type="unsigned long" dir="in"/>
      <param name="y" type="unsigned long" dir="in"/>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
    </method>

    <method name="requestResize">
      <desc>
        Requests a size and pixel format change.

        There are two modes of working with the video buffer of the virtual
        machine. The <i>indirect</i> mode implies that the IFramebuffer
        implementation allocates a memory buffer for the requested display mode
        and provides it to the virtual machine. In <i>direct</i> mode, the
        IFramebuffer implementation uses the memory buffer allocated and owned
        by the virtual machine. This buffer represents the video memory of the
        emulated video adapter (so called <i>guest VRAM</i>). The direct mode is
        usually faster because the implementation gets a raw pointer to the
        guest VRAM buffer which it can directly use for visualizing the contents
        of the virtual display, as opposed to the indirect mode where the
        contents of guest VRAM are copied to the memory buffer provided by
        the implementation every time a display update occurs.

        It is important to note that the direct mode is really fast only when
        the implementation uses the given guest VRAM buffer directly, for
        example, by blitting it to the window representing the virtual machine's
        display, which saves at least one copy operation comparing to the
        indirect mode. However, using the guest VRAM buffer directly is not
        always possible: the format and the color depth of this buffer may be
        not supported by the target window, or it may be unknown (opaque) as in
        case of text or non-linear multi-plane VGA video modes. In this case,
        the indirect mode (that is always available) should be used as a
        fallback: when the guest VRAM contents are copied to the
        implementation-provided memory buffer, color and format conversion is
        done automatically by the underlying code.

        The @a pixelFormat parameter defines whether the direct mode is
        available or not. If @a pixelFormat is <link
        to="FramebufferPixelFormat_Opaque"/> then direct access to the guest
        VRAM buffer is not available -- the @a VRAM, @a bitsPerPixel and
        @a bytesPerLine parameters must be ignored and the implementation must use
        the indirect mode (where it provides its own buffer in one of the
        supported formats). In all other cases, @a pixelFormat together with
        @a bitsPerPixel and @a bytesPerLine define the format of the video memory
        buffer pointed to by the @a VRAM parameter and the implementation is
        free to choose which mode to use. To indicate that this frame buffer uses
        the direct mode, the implementation of the <link to="#usesGuestVRAM"/>
        attribute must return @c true and <link to="#address"/> must
        return exactly the same address that is passed in the @a VRAM parameter
        of this method; otherwise it is assumed that the indirect strategy is
        chosen.

        The @a width and @a height parameters represent the size of the
        requested display mode in both modes. In case of indirect mode, the
        provided memory buffer should be big enough to store data of the given
        display mode. In case of direct mode, it is guaranteed that the given
        @a VRAM buffer contains enough space to represent the display mode of the
        given size. Note that this frame buffer's <link to="#width"/> and <link
        to="#height"/> attributes must return exactly the same values as
        passed to this method after the resize is completed (see below).

        The @a finished output parameter determines if the implementation has
        finished resizing the frame buffer or not. If, for some reason, the
        resize cannot be finished immediately during this call, @a finished
        must be set to @c false, and the implementation must call
        <link to="IDisplay::resizeCompleted"/> after it has returned from
        this method as soon as possible. If @a finished is @c false, the
        machine will not call any frame buffer methods until
        <link to="IDisplay::resizeCompleted"/> is called.

        Note that if the direct mode is chosen, the <link to="#bitsPerPixel"/>,
        <link to="#bytesPerLine"/> and <link to="#pixelFormat"/> attributes of
        this frame buffer must return exactly the same values as specified in the
        parameters of this method, after the resize is completed. If the
        indirect mode is chosen, these attributes must return values describing
        the format of the implementation's own memory buffer <link
        to="#address"/> points to. Note also that the <link to="#bitsPerPixel"/>
        value must always correlate with <link to="#pixelFormat"/>. Note that
        the <link to="#pixelFormat"/> attribute must never return <link
        to="FramebufferPixelFormat_Opaque"/> regardless of the selected mode.

        <note>
          This method is called by the IDisplay object under the
          <link to="#lock"/> provided by this IFramebuffer
          implementation. If this method returns @c false in @a finished, then
          this lock is not released until
          <link to="IDisplay::resizeCompleted"/> is called.
        </note>
      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Logical screen number. Must be used in the corresponding call to
          <link to="IDisplay::resizeCompleted"/> if this call is made.
        </desc>
      </param>
      <param name="pixelFormat" type="unsigned long" dir="in">
        <desc>
          Pixel format of the memory buffer pointed to by @a VRAM.
          See also <link to="FramebufferPixelFormat"/>.
        </desc>
      </param>
      <param name="VRAM" type="octet" mod="ptr" dir="in">
        <desc>Pointer to the virtual video card's VRAM (may be @c null).</desc>
      </param>
      <param name="bitsPerPixel" type="unsigned long" dir="in">
        <desc>Color depth, bits per pixel.</desc>
      </param>
      <param name="bytesPerLine" type="unsigned long" dir="in">
        <desc>Size of one scan line, in bytes.</desc>
      </param>
      <param name="width" type="unsigned long" dir="in">
        <desc>Width of the guest display, in pixels.</desc>
      </param>
      <param name="height" type="unsigned long" dir="in">
        <desc>Height of the guest display, in pixels.</desc>
      </param>
      <param name="finished" type="boolean" dir="return">
        <desc>
          Can the VM start using the new frame buffer immediately
          after this method returns or it should wait for
          <link to="IDisplay::resizeCompleted"/>.
        </desc>
      </param>
    </method>

    <method name="videoModeSupported">
      <desc>
        Returns whether the frame buffer implementation is willing to
        support a given video mode. In case it is not able to render
        the video mode (or for some reason not willing), it should
        return @c false. Usually this method is called when the guest
        asks the VMM device whether a given video mode is supported
        so the information returned is directly exposed to the guest.
        It is important that this method returns very quickly.
      </desc>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
      <param name="bpp" type="unsigned long" dir="in"/>
      <param name="supported" type="boolean" dir="return"/>
    </method>

    <method name="getVisibleRegion">
      <desc>
        Returns the visible region of this frame buffer.

        If the @a rectangles parameter is @c null then the value of the
        @a count parameter is ignored and the number of elements necessary to
        describe the current visible region is returned in @a countCopied.

        If @a rectangles is not @c null but @a count is less
        than the required number of elements to store region data, the method
        will report a failure. If @a count is equal or greater than the
        required number of elements, then the actual number of elements copied
        to the provided array will be returned in @a countCopied.

        <note>
          The address of the provided array must be in the process space of
          this IFramebuffer object.
        </note>
        <note>
          Method not yet implemented.
        </note>
      </desc>
      <param name="rectangles" type="octet" mod="ptr" dir="in">
        <desc>Pointer to the @c RTRECT array to receive region data.</desc>
      </param>
      <param name="count" type="unsigned long" dir="in">
        <desc>Number of @c RTRECT elements in the @a rectangles array.</desc>
      </param>
      <param name="countCopied" type="unsigned long" dir="return">
        <desc>Number of elements copied to the @a rectangles array.</desc>
      </param>
    </method>

    <method name="setVisibleRegion">
      <desc>
        Suggests a new visible region to this frame buffer.  This region
        represents the area of the VM display which is a union of regions of
        all top-level windows of the guest operating system running inside the
        VM (if the Guest Additions for this system support this
        functionality). This information may be used by the frontends to
        implement the seamless desktop integration feature.

        <note>
          The address of the provided array must be in the process space of
          this IFramebuffer object.
        </note>
        <note>
          The IFramebuffer implementation must make a copy of the provided
          array of rectangles.
        </note>
        <note>
          Method not yet implemented.
        </note>
      </desc>
      <param name="rectangles" type="octet" mod="ptr" dir="in">
        <desc>Pointer to the @c RTRECT array.</desc>
      </param>
      <param name="count" type="unsigned long" dir="in">
        <desc>Number of @c RTRECT elements in the @a rectangles array.</desc>
      </param>
    </method>

    <method name="processVHWACommand">
      <desc>
        Posts a Video HW Acceleration Command to the frame buffer for processing.
        The commands used for 2D video acceleration (DDraw surface creation/destroying, blitting, scaling, color conversion, overlaying, etc.)
        are posted from quest to the host to be processed by the host hardware.

        <note>
          The address of the provided command must be in the process space of
          this IFramebuffer object.
        </note>
      </desc>

      <param name="command" type="octet" mod="ptr" dir="in">
        <desc>Pointer to VBOXVHWACMD containing the command to execute.</desc>
      </param>
    </method>

  </interface>

  <interface
    name="IFramebufferOverlay" extends="IFramebuffer"
    uuid="0bcc1c7e-e415-47d2-bfdb-e4c705fb0f47"
    wsmap="suppress"
    >
    <desc>
      The IFramebufferOverlay interface represents an alpha blended overlay
      for displaying status icons above an IFramebuffer.  It is always created
      not visible, so that it must be explicitly shown.  It only covers a
      portion of the IFramebuffer, determined by its width, height and
      co-ordinates.  It is always in packed pixel little-endian 32bit ARGB (in
      that order) format, and may be written to directly.  Do re-read the
      width though, after setting it, as it may be adjusted (increased) to
      make it more suitable for the front end.
    </desc>
    <attribute name="x" type="unsigned long" readonly="yes">
      <desc>X position of the overlay, relative to the frame buffer.</desc>
    </attribute>

    <attribute name="y" type="unsigned long" readonly="yes">
      <desc>Y position of the overlay, relative to the frame buffer.</desc>
    </attribute>

    <attribute name="visible" type="boolean" readonly="no">
      <desc>
        Whether the overlay is currently visible.
      </desc>
    </attribute>

    <attribute name="alpha" type="unsigned long" readonly="no">
      <desc>
        The global alpha value for the overlay.  This may or may not be
        supported by a given front end.
      </desc>
    </attribute>

    <method name="move">
      <desc>
        Changes the overlay's position relative to the IFramebuffer.
      </desc>
      <param name="x" type="unsigned long" dir="in"/>
      <param name="y" type="unsigned long" dir="in"/>
    </method>

  </interface>

  <interface
    name="IDisplay" extends="$unknown"
    uuid="b83ee395-8679-40ca-8d60-1a0cbe724930"
    wsmap="managed"
    >
    <desc>
      The IDisplay interface represents the virtual machine's display.

      The object implementing this interface is contained in each
      <link to="IConsole::display"/> attribute and represents the visual
      output of the virtual machine.

      The virtual display supports pluggable output targets represented by the
      IFramebuffer interface. Examples of the output target are a window on
      the host computer or an RDP session's display on a remote computer.
    </desc>
    <method name="getScreenResolution">
      <desc>Queries display width, height and color depth for given screen.</desc>
      <param name="screenId" type="unsigned long" dir="in"/>
      <param name="width" type="unsigned long" dir="out"/>
      <param name="height" type="unsigned long" dir="out"/>
      <param name="bitsPerPixel" type="unsigned long" dir="out"/>
    </method>

    <method name="setFramebuffer">
      <desc>
        Sets the framebuffer for given screen.
      </desc>
      <param name="screenId" type="unsigned long" dir="in"/>
      <param name="framebuffer" type="IFramebuffer" dir="in"/>
    </method>

    <method name="getFramebuffer">
      <desc>
        Queries the framebuffer for given screen.
      </desc>
      <param name="screenId" type="unsigned long" dir="in"/>
      <param name="framebuffer" type="IFramebuffer" dir="out"/>
      <param name="xOrigin" type="long" dir="out"/>
      <param name="yOrigin" type="long" dir="out"/>
    </method>

    <method name="setVideoModeHint">
      <desc>
        Asks VirtualBox to request the given video mode from
        the guest. This is just a hint and it cannot be guaranteed
        that the requested resolution will be used. Guest Additions
        are required for the request to be seen by guests. The caller
        should issue the request and wait for a resolution change and
        after a timeout retry.

        Specifying @c 0 for either @a width, @a height or @a bitsPerPixel
        parameters means that the corresponding values should be taken from the
        current video mode (i.e. left unchanged).

        If the guest OS supports multi-monitor configuration then the @a display
        parameter specifies the number of the guest display to send the hint to:
        @c 0 is the primary display, @c 1 is the first secondary and
        so on. If the multi-monitor configuration is not supported, @a display
        must be @c 0.

        <result name="E_INVALIDARG">
          The @a display is not associated with any monitor.
        </result>

      </desc>
      <param name="display" type="unsigned long" dir="in">
        <desc>
          The number of the guest display to send the hint to.
        </desc>
      </param>
      <param name="enabled" type="boolean" dir="in">
        <desc>
          @c True, if this guest screen is enabled,
          @c False otherwise.
        </desc>
      </param>
      <param name="changeOrigin" type="boolean" dir="in">
        <desc>
          @c True, if the origin of the guest screen should be changed,
          @c False otherwise.
        </desc>
      </param>
      <param name="originX" type="long" dir="in">
        <desc>
          The X origin of the guest screen.
        </desc>
      </param>
      <param name="originY" type="long" dir="in">
        <desc>
          The Y origin of the guest screen.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
      <param name="bitsPerPixel" type="unsigned long" dir="in"/>
    </method>

    <method name="setSeamlessMode">
      <desc>
        Enables or disables seamless guest display rendering (seamless desktop
        integration) mode.
        <note>
          Calling this method has no effect if <link
          to="IGuest::getFacilityStatus"/> with facility @c Seamless
          does not return @c Active.
        </note>
      </desc>
      <param name="enabled" type="boolean" dir="in"/>
    </method>

    <method name="takeScreenShot">
      <desc>
        Takes a screen shot of the requested size and copies it to the
        32-bpp buffer allocated by the caller and pointed to by @a address.
        A pixel consists of 4 bytes in order: B, G, R, 0.

        <note>This API can be used only locally by a VM process through the
            COM/XPCOM C++ API as it requires pointer support. It is not
            available for scripting langages, Java or any webservice clients.
            Unless you are writing a new VM frontend use
            <link to="#takeScreenShotToArray" />.
        </note>

        <result name="E_NOTIMPL">
          Feature not implemented.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not take a screenshot.
        </result>

      </desc>
      <param name="screenId" type="unsigned long" dir="in"/>
      <param name="address" type="octet" mod="ptr" dir="in"/>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
    </method>

    <method name="takeScreenShotToArray">
      <desc>
        Takes a guest screen shot of the requested size and returns it as
        an array of bytes in uncompressed 32-bit RGBA format.
        A pixel consists of 4 bytes in order: R, G, B, 0xFF.

        This API is slow, but could be the only option to get guest screenshot
        for scriptable languages not allowed to manipulate with addresses
        directly.

        <result name="E_NOTIMPL">
          Feature not implemented.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not take a screenshot.
        </result>
      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Monitor to take screenshot from.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="in">
        <desc>
          Desired image width.
        </desc>
      </param>
      <param name="height" type="unsigned long" dir="in">
        <desc>
          Desired image height.
        </desc>
      </param>
      <param name="screenData" type="octet" dir="return" safearray="yes">
        <desc>
          Array with resulting screen data.
        </desc>
      </param>
    </method>

    <method name="takeScreenShotPNGToArray">
      <desc>
        Takes a guest screen shot of the requested size and returns it as
        PNG image in array.

        <result name="E_NOTIMPL">
          Feature not implemented.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not take a screenshot.
        </result>
      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Monitor to take the screenshot from.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="in">
        <desc>
          Desired image width.
        </desc>
      </param>
      <param name="height" type="unsigned long" dir="in">
        <desc>
          Desired image height.
        </desc>
      </param>
      <param name="screenData" type="octet" dir="return" safearray="yes">
        <desc>
          Array with resulting screen data.
        </desc>
      </param>
    </method>

    <method name="drawToScreen">
      <desc>
        Draws a 32-bpp image of the specified size from the given buffer
        to the given point on the VM display.

        <result name="E_NOTIMPL">
          Feature not implemented.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not draw to screen.
        </result>

      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Monitor to take the screenshot from.
        </desc>
      </param>
      <param name="address" type="octet" mod="ptr" dir="in">
        <desc>
          Address to store the screenshot to
        </desc>
      </param>
      <param name="x" type="unsigned long" dir="in">
        <desc>
          Relative to the screen top left corner.
        </desc>
      </param>
      <param name="y" type="unsigned long" dir="in">
        <desc>
          Relative to the screen top left corner.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="in">
        <desc>
          Desired image width.
        </desc>
      </param>
      <param name="height" type="unsigned long" dir="in">
        <desc>
          Desired image height.
        </desc>
      </param>
    </method>

    <method name="invalidateAndUpdate">
      <desc>
        Does a full invalidation of the VM display and instructs the VM
        to update it.

        <result name="VBOX_E_IPRT_ERROR">
          Could not invalidate and update screen.
        </result>

      </desc>
    </method>

    <method name="resizeCompleted">
      <desc>
        Signals that a framebuffer has completed the resize operation.

        <result name="VBOX_E_NOT_SUPPORTED">
          Operation only valid for external frame buffers.
        </result>

      </desc>
      <param name="screenId" type="unsigned long" dir="in"/>
    </method>

    <method name="completeVHWACommand">
      <desc>
        Signals that the Video HW Acceleration command has completed.
      </desc>

      <param name="command" type="octet" mod="ptr" dir="in">
        <desc>Pointer to VBOXVHWACMD containing the completed command.</desc>
      </param>
    </method>

    <method name="viewportChanged">
      <desc>
        Signals that framebuffer window viewport has changed.

      <result name="E_INVALIDARG">
        The specified viewport data is invalid.
      </result>

      </desc>

      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Monitor to take the screenshot from.
        </desc>
      </param>
      <param name="x" type="unsigned long" dir="in">
        <desc>
          Framebuffer x offset.
        </desc>
      </param>
      <param name="y" type="unsigned long" dir="in">
        <desc>
          Framebuffer y offset.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="in">
        <desc>
          Viewport width.
        </desc>
      </param>
      <param name="height" type="unsigned long" dir="in">
        <desc>
          Viewport height.
        </desc>
      </param>
    </method>
  </interface>

  <!--
  // INetworkAdapter
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="NetworkAttachmentType"
    uuid="2ac4bc71-6b82-417a-acd1-f7426d2570d6"
    >
    <desc>
      Network attachment type.
    </desc>

    <const name="Null"                  value="0">
      <desc>Null value, also means "not attached".</desc>
    </const>
    <const name="NAT"                   value="1"/>
    <const name="Bridged"               value="2"/>
    <const name="Internal"              value="3"/>
    <const name="HostOnly"              value="4"/>
    <const name="Generic"               value="5"/>
  </enum>

  <enum
    name="NetworkAdapterType"
    uuid="3c2281e4-d952-4e87-8c7d-24379cb6a81c"
    >
    <desc>
      Network adapter type.
    </desc>

    <const name="Null"                  value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="Am79C970A"             value="1">
        <desc>AMD PCNet-PCI II network card (Am79C970A).</desc>
    </const>
    <const name="Am79C973"              value="2">
        <desc>AMD PCNet-FAST III network card (Am79C973).</desc>
    </const>
    <const name="I82540EM"              value="3">
        <desc>Intel PRO/1000 MT Desktop network card (82540EM).</desc>
    </const>
    <const name="I82543GC"              value="4">
        <desc>Intel PRO/1000 T Server network card (82543GC).</desc>
    </const>
    <const name="I82545EM"              value="5">
        <desc>Intel PRO/1000 MT Server network card (82545EM).</desc>
    </const>
    <const name="Virtio"                value="6">
        <desc>Virtio network device.</desc>
    </const>
  </enum>

  <enum
    name="NetworkAdapterPromiscModePolicy"
    uuid="c963768a-376f-4c85-8d84-d8ced4b7269e"
    >
    <desc>
      The promiscuous mode policy of an interface.
    </desc>

    <const name="Deny"                  value="1">
      <desc>Deny promiscuous mode requests.</desc>
    </const>
    <const name="AllowNetwork"          value="2">
      <desc>
        Allow promicuous mode, but restrict the scope it to the internal
        network so that it only applies to other VMs.
      </desc>
    </const>
    <const name="AllowAll"              value="3">
      <desc>
        Allow promicuous mode, include unrelated traffic going over the wire
        and internally on the host.
      </desc>
    </const>
  </enum>

  <interface
    name="INetworkAdapter" extends="$unknown"
    uuid="efa0f965-63c7-4c60-afdf-b1cc9943b9c0"
    wsmap="managed"
    >
    <desc>
        Represents a virtual network adapter that is attached to a virtual machine.
        Each virtual machine has a fixed number of network adapter slots with one
        instance of this attached to each of them. Call
        <link to="IMachine::getNetworkAdapter" /> to get the network adapter that
        is attached to a given slot in a given machine.

        Each network adapter can be in one of five attachment modes, which are
        represented by the <link to="NetworkAttachmentType" /> enumeration;
        see the <link to="#attachmentType" /> attribute.
    </desc>

    <attribute name="adapterType" type="NetworkAdapterType">
      <desc>
        Type of the virtual network adapter. Depending on this value,
        VirtualBox will provide a different virtual network hardware
        to the guest.
      </desc>
    </attribute>

    <attribute name="slot" type="unsigned long" readonly="yes">
      <desc>
        Slot number this adapter is plugged into. Corresponds to
        the value you pass to <link to="IMachine::getNetworkAdapter"/>
        to obtain this instance.
      </desc>
    </attribute>

    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the network adapter is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain this network adapter. Can only be changed when
        the VM is not running.
      </desc>
    </attribute>

    <attribute name="MACAddress" type="wstring">
      <desc>
        Ethernet MAC address of the adapter, 12 hexadecimal characters. When setting
        it to @c null or an empty string, VirtualBox will generate a unique MAC address.
      </desc>
    </attribute>

    <attribute name="attachmentType" type="NetworkAttachmentType">
      <desc>
        Sets/Gets network attachment type of this network adapter.
      </desc>
    </attribute>

    <attribute name="bridgedInterface" type="wstring">
      <desc>
        Name of the network interface the VM should be bridged to.
      </desc>
    </attribute>

    <attribute name="hostOnlyInterface" type="wstring">
      <desc>
        Name of the host only network interface the VM is attached to.
      </desc>
    </attribute>

    <attribute name="internalNetwork" type="wstring">
      <desc>
        Name of the internal network the VM is attached to.
      </desc>
    </attribute>

    <attribute name="NATNetwork" type="wstring">
      <desc>
        Name of the NAT network the VM is attached to.
      </desc>
    </attribute>

    <attribute name="genericDriver" type="wstring">
      <desc>
        Name of the driver to use for the "Generic" network attachment type.
      </desc>
    </attribute>

    <attribute name="cableConnected" type="boolean">
      <desc>
        Flag whether the adapter reports the cable as connected or not.
        It can be used to report offline situations to a VM.
      </desc>
    </attribute>

    <attribute name="lineSpeed" type="unsigned long">
      <desc>
        Line speed reported by custom drivers, in units of 1 kbps.
      </desc>
    </attribute>

    <attribute name="promiscModePolicy" type="NetworkAdapterPromiscModePolicy">
      <desc>
        The promiscuous mode policy of the network adapter when attached to an
        internal network, host only network or a bridge.
      </desc>
    </attribute>

    <attribute name="traceEnabled" type="boolean">
      <desc>
        Flag whether network traffic from/to the network card should be traced.
        Can only be toggled when the VM is turned off.
      </desc>
    </attribute>

    <attribute name="traceFile" type="wstring">
      <desc>
        Filename where a network trace will be stored. If not set, VBox-pid.pcap
        will be used.
      </desc>
    </attribute>

    <attribute name="NATEngine" type="INATEngine" readonly="yes">
      <desc>
        Points to the NAT engine which handles the network address translation
        for this interface. This is active only when the interface actually uses
        NAT.
      </desc>
    </attribute>

    <attribute name="bootPriority" type="unsigned long">
      <desc>
        Network boot priority of the adapter. Priority 1 is highest. If not set,
        the priority is considered to be at the lowest possible setting.
      </desc>
    </attribute>

    <attribute name="bandwidthGroup" type="IBandwidthGroup">
      <desc>The bandwidth group this network adapter is assigned to.</desc>
    </attribute>

    <!-- property methods -->

    <method name="getProperty" const="yes">
      <desc>
        Returns the value of the network attachment property with the given name.

        If the requested data @a key does not exist, this function will
        succeed and return an empty string in the @a value argument.

        <result name="E_INVALIDARG">@a name is @c null or empty.</result>
      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the property to get.</desc>
      </param>
      <param name="value" type="wstring" dir="return">
        <desc>Current property value.</desc>
      </param>
    </method>

    <method name="setProperty">
      <desc>
        Sets the value of the network attachment property with the given name.

        Setting the property value to @c null or an empty string is equivalent
        to deleting the existing value.

        <result name="E_INVALIDARG">@a name is @c null or empty.</result>
      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the property to set.</desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>Property value to set.</desc>
      </param>
    </method>

    <method name="getProperties" const="yes">
      <desc>
        Returns values for a group of properties in one call.

        The names of the properties to get are specified using the @a names
        argument which is a list of comma-separated property names or
        an empty string if all properties are to be returned.
        <note>Currently the value of this argument is ignored and the method
        always returns all existing properties.</note>

        The method returns two arrays, the array of property names corresponding
        to the @a names argument and the current values of these properties.
        Both arrays have the same number of elements with each element at the
        given index in the first array corresponds to an element at the same
        index in the second array.
      </desc>
      <param name="names" type="wstring" dir="in">
        <desc>
          Names of properties to get.
        </desc>
      </param>
      <param name="returnNames" type="wstring" safearray="yes" dir="out">
        <desc>Names of returned properties.</desc>
      </param>
      <param name="returnValues" type="wstring" safearray="yes" dir="return">
        <desc>Values of returned properties.</desc>
      </param>
    </method>

  </interface>


  <!--
  // ISerialPort
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="PortMode"
    uuid="533b5fe3-0185-4197-86a7-17e37dd39d76"
    >
    <desc>
      The PortMode enumeration represents possible communication modes for
      the virtual serial port device.
    </desc>

    <const name="Disconnected"        value="0">
      <desc>Virtual device is not attached to any real host device.</desc>
    </const>
    <const name="HostPipe"            value="1">
      <desc>Virtual device is attached to a host pipe.</desc>
    </const>
    <const name="HostDevice"          value="2">
      <desc>Virtual device is attached to a host device.</desc>
    </const>
    <const name="RawFile"             value="3">
      <desc>Virtual device is attached to a raw file.</desc>
    </const>
  </enum>

  <interface
    name="ISerialPort" extends="$unknown"
    uuid="937f6970-5103-4745-b78e-d28dcf1479a8"
    wsmap="managed"
    >

    <desc>
      The ISerialPort interface represents the virtual serial port device.

      The virtual serial port device acts like an ordinary serial port
      inside the virtual machine. This device communicates to the real
      serial port hardware in one of two modes: host pipe or host device.

      In host pipe mode, the #path attribute specifies the path to the pipe on
      the host computer that represents a serial port. The #server attribute
      determines if this pipe is created by the virtual machine process at
      machine startup or it must already exist before starting machine
      execution.

      In host device mode, the #path attribute specifies the name of the
      serial port device on the host computer.

      There is also a third communication mode: the disconnected mode. In this
      mode, the guest OS running inside the virtual machine will be able to
      detect the serial port, but all port write operations will be discarded
      and all port read operations will return no data.

      <see><link to="IMachine::getSerialPort"/></see>
    </desc>

    <attribute name="slot" type="unsigned long" readonly="yes">
      <desc>
        Slot number this serial port is plugged into. Corresponds to
        the value you pass to <link to="IMachine::getSerialPort"/>
        to obtain this instance.
      </desc>
    </attribute>

    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the serial port is enabled. If disabled,
        the serial port will not be reported to the guest OS.
      </desc>
    </attribute>

    <attribute name="IOBase" type="unsigned long">
      <desc>Base I/O address of the serial port.</desc>
    </attribute>

    <attribute name="IRQ" type="unsigned long">
      <desc>IRQ number of the serial port.</desc>
    </attribute>

    <attribute name="hostMode" type="PortMode">
      <desc>
        How is this port connected to the host.
        <note>
          Changing this attribute may fail if the conditions for
          <link to="#path"/> are not met.
        </note>
      </desc>
    </attribute>

    <attribute name="server" type="boolean">
      <desc>
        Flag whether this serial port acts as a server (creates a new pipe on
        the host) or as a client (uses the existing pipe). This attribute is
        used only when <link to="#hostMode"/> is PortMode_HostPipe.
      </desc>
    </attribute>

    <attribute name="path" type="wstring">
      <desc>
        Path to the serial port's pipe on the host when <link to="ISerialPort::hostMode"/> is
        PortMode_HostPipe, or the host serial device name when
        <link to="ISerialPort::hostMode"/> is PortMode_HostDevice. For both
        cases, setting a @c null or empty string as the attribute's value
        is an error. Otherwise, the value of this property is ignored.
      </desc>
    </attribute>

  </interface>

  <!--
  // IParallelPort
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IParallelPort" extends="$unknown"
    uuid="0c925f06-dd10-4b77-8de8-294d738c3214"
    wsmap="managed"
    >

    <desc>
      The IParallelPort interface represents the virtual parallel port device.

      The virtual parallel port device acts like an ordinary parallel port
      inside the virtual machine. This device communicates to the real
      parallel port hardware using the name of the parallel device on the host
      computer specified in the #path attribute.

      Each virtual parallel port device is assigned a base I/O address and an
      IRQ number that will be reported to the guest operating system and used
      to operate the given parallel port from within the virtual machine.

      <see><link to="IMachine::getParallelPort"/></see>
    </desc>

    <attribute name="slot" type="unsigned long" readonly="yes">
      <desc>
        Slot number this parallel port is plugged into. Corresponds to
        the value you pass to <link to="IMachine::getParallelPort"/>
        to obtain this instance.
      </desc>
    </attribute>

    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the parallel port is enabled. If disabled,
        the parallel port will not be reported to the guest OS.
      </desc>
    </attribute>

    <attribute name="IOBase" type="unsigned long">
      <desc>Base I/O address of the parallel port.</desc>
    </attribute>

    <attribute name="IRQ" type="unsigned long">
      <desc>IRQ number of the parallel port.</desc>
    </attribute>

    <attribute name="path" type="wstring">
      <desc>
        Host parallel device name. If this parallel port is enabled, setting a
        @c null or an empty string as this attribute's value will result in
        an error.
      </desc>
    </attribute>

  </interface>


  <!--
  // IMachineDebugger
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IMachineDebugger" extends="$unknown"
    uuid="a9abbb7c-d678-43b2-bed2-19ec0e32303d"
    wsmap="suppress"
    >
    <method name="dumpGuestCore">
      <desc>
        Takes a core dump of the guest.

        See include/VBox/dbgfcorefmt.h for details on the file format.
      </desc>
      <param name="filename" type="wstring" dir="in">
        <desc>
          The name of the output file.  The file must not exist.
        </desc>
      </param>
      <param name="compression" type="wstring" dir="in">
        <desc>
          Reserved for future compression method indicator.
        </desc>
      </param>
    </method>

    <method name="dumpHostProcessCore">
      <desc>
        Takes a core dump of the VM process on the host.

        This feature is not implemented in the 4.0.0 release but it may show up
        in a dot release.
      </desc>
      <param name="filename" type="wstring" dir="in">
        <desc>
          The name of the output file.  The file must not exist.
        </desc>
      </param>
      <param name="compression" type="wstring" dir="in">
        <desc>
          Reserved for future compression method indicator.
        </desc>
      </param>
    </method>

    <method name="info">
      <desc>
        Interfaces with the info dumpers (DBGFInfo).

        This feature is not implemented in the 4.0.0 release but it may show up
        in a dot release.
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          The name of the info item.
        </desc>
      </param>
      <param name="args" type="wstring" dir="in">
        <desc>
          Arguments to the info dumper.
        </desc>
      </param>
      <param name="info" type="wstring" dir="return">
        <desc>
          The into string.
        </desc>
      </param>
    </method>

    <method name="injectNMI">
      <desc>
        Inject an NMI into a running VT-x/AMD-V VM.
      </desc>
    </method>

    <method name="modifyLogGroups">
      <desc>
        Modifies the group settings of the debug or release logger.
      </desc>
      <param name="settings" type="wstring" dir="in">
        <desc>
          The group settings string. See iprt/log.h for details. To target the
          release logger, prefix the string with "release:".
        </desc>
      </param>
    </method>

    <method name="modifyLogFlags">
      <desc>
        Modifies the debug or release logger flags.
      </desc>
      <param name="settings" type="wstring" dir="in">
        <desc>
          The flags settings string. See iprt/log.h for details. To target the
          release logger, prefix the string with "release:".
        </desc>
      </param>
    </method>

    <method name="modifyLogDestinations">
      <desc>
        Modifies the debug or release logger destinations.
      </desc>
      <param name="settings" type="wstring" dir="in">
        <desc>
          The destination settings string. See iprt/log.h for details. To target the
          release logger, prefix the string with "release:".
        </desc>
      </param>
    </method>

    <method name="readPhysicalMemory">
      <desc>
        Reads guest physical memory, no side effects (MMIO++).

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      </desc>
      <param name="address" type="long long" dir="in">
        <desc>The guest physical address.</desc>
      </param>
      <param name="size" type="unsigned long" dir="in">
        <desc>The number of bytes to read.</desc>
      </param>
      <param name="bytes" type="octet" safearray="yes" dir="return">
        <desc>The bytes read.</desc>
      </param>
    </method>

    <method name="writePhysicalMemory">
      <desc>
        Writes guest physical memory, access handles (MMIO++) are ignored.

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      </desc>
      <param name="address" type="long long" dir="in">
        <desc>The guest physical address.</desc>
      </param>
      <param name="size" type="unsigned long" dir="in">
        <desc>The number of bytes to read.</desc>
      </param>
      <param name="bytes" type="octet" safearray="yes" dir="in">
        <desc>The bytes to write.</desc>
      </param>
    </method>

    <method name="readVirtualMemory">
      <desc>
        Reads guest virtual memory, no side effects (MMIO++).

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      </desc>
      <param name="cpuId" type="unsigned long" dir="in">
        <desc>The identifier of the Virtual CPU.</desc>
      </param>
      <param name="address" type="long long" dir="in">
        <desc>The guest virtual address.</desc>
      </param>
      <param name="size" type="unsigned long" dir="in">
        <desc>The number of bytes to read.</desc>
      </param>
      <param name="bytes" type="octet" safearray="yes" dir="return">
        <desc>The bytes read.</desc>
      </param>
    </method>

    <method name="writeVirtualMemory">
      <desc>
        Writes guest virtual memory, access handles (MMIO++) are ignored.

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      </desc>
      <param name="cpuId" type="unsigned long" dir="in">
        <desc>The identifier of the Virtual CPU.</desc>
      </param>
      <param name="address" type="long long" dir="in">
        <desc>The guest virtual address.</desc>
      </param>
      <param name="size" type="unsigned long" dir="in">
        <desc>The number of bytes to read.</desc>
      </param>
      <param name="bytes" type="octet" safearray="yes" dir="in">
        <desc>The bytes to write.</desc>
      </param>
    </method>

    <method name="detectOS">
      <desc>
        Tries to (re-)detect the guest OS kernel.

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      </desc>
      <param name="os" type="wstring" dir="return">
        <desc>
          The detected OS kernel on success.
        </desc>
      </param>
    </method>

    <method name="getRegister">
      <desc>
        Gets one register.

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      </desc>
      <param name="cpuId" type="unsigned long" dir="in">
        <desc>The identifier of the Virtual CPU.</desc>
      </param>
      <param name="name" type="wstring" dir="in">
        <desc>The register name, case is ignored.</desc>
      </param>
      <param name="value" type="wstring" dir="return">
        <desc>
          The register value.  This is usually a hex value (always 0x prefixed)
          but other format may be used for floating point registers (TBD).
        </desc>
      </param>
    </method>

    <method name="getRegisters">
      <desc>
        Gets all the registers for the given CPU.

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      </desc>
      <param name="cpuId" type="unsigned long" dir="in">
        <desc>The identifier of the Virtual CPU.</desc>
      </param>
      <param name="names" type="wstring" dir="out" safearray="yes">
        <desc>Array containing the lowercase register names.</desc>
      </param>
      <param name="values" type="wstring" dir="out" safearray="yes">
        <desc>
          Array paralell to the names holding the register values as if the
          register was returned by <link to="IMachineDebugger::getRegister"/>.
        </desc>
      </param>
    </method>

    <method name="setRegister">
      <desc>
        Gets one register.

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      </desc>
      <param name="cpuId" type="unsigned long" dir="in">
        <desc>The identifier of the Virtual CPU.</desc>
      </param>
      <param name="name" type="wstring" dir="in">
        <desc>The register name, case is ignored.</desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>
          The new register value.  Hexadecimal, decimal and octal formattings
          are supported in addition to any special formattings returned by
          the getters.
        </desc>
      </param>
    </method>

    <method name="setRegisters">
      <desc>
        Sets zero or more registers atomically.

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      </desc>
      <param name="cpuId" type="unsigned long" dir="in">
        <desc>The identifier of the Virtual CPU.</desc>
      </param>
      <param name="names" type="wstring" dir="in" safearray="yes">
        <desc>Array containing the register names, case ignored.</desc>
      </param>
      <param name="values" type="wstring" dir="in" safearray="yes">
        <desc>
          Array paralell to the names holding the register values. See
          <link to="IMachineDebugger::setRegister"/> for formatting
          guidelines.
        </desc>
      </param>
    </method>

    <method name="dumpGuestStack">
      <desc>
        Produce a simple stack dump using the current guest state.

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      </desc>
      <param name="cpuId" type="unsigned long" dir="in">
        <desc>The identifier of the Virtual CPU.</desc>
      </param>
      <param name="stack" type="wstring" dir="return">
        <desc>String containing the formatted stack dump.</desc>
      </param>
    </method>

    <method name="resetStats">
      <desc>
        Reset VM statistics.
      </desc>
      <param name="pattern" type="wstring" dir="in">
        <desc>The selection pattern. A bit similar to filename globbing.</desc>
      </param>
    </method>

    <method name="dumpStats">
      <desc>
        Dumps VM statistics.
      </desc>
      <param name="pattern" type="wstring" dir="in">
        <desc>The selection pattern. A bit similar to filename globbing.</desc>
      </param>
    </method>

    <method name="getStats">
      <desc>
        Get the VM statistics in a XMLish format.
      </desc>
      <param name="pattern" type="wstring" dir="in">
        <desc>The selection pattern. A bit similar to filename globbing.</desc>
      </param>
      <param name="withDescriptions" type="boolean" dir="in">
        <desc>Whether to include the descriptions.</desc>
      </param>
      <param name="stats" type="wstring" dir="out">
        <desc>The XML document containing the statistics.</desc>
      </param>
    </method>

    <attribute name="singleStep" type="boolean">
      <desc>Switch for enabling single-stepping.</desc>
    </attribute>

    <attribute name="recompileUser" type="boolean">
      <desc>Switch for forcing code recompilation for user mode code.</desc>
    </attribute>

    <attribute name="recompileSupervisor" type="boolean">
      <desc>Switch for forcing code recompilation for supervisor mode code.</desc>
    </attribute>

    <attribute name="PATMEnabled" type="boolean">
      <desc>Switch for enabling and disabling the PATM component.</desc>
    </attribute>

    <attribute name="CSAMEnabled" type="boolean">
      <desc>Switch for enabling and disabling the CSAM component.</desc>
    </attribute>

    <attribute name="logEnabled" type="boolean">
      <desc>Switch for enabling and disabling the debug logger.</desc>
    </attribute>

    <attribute name="logDbgFlags" type="wstring" readonly="yes">
      <desc>The debug logger flags.</desc>
    </attribute>

    <attribute name="logDbgGroups" type="wstring" readonly="yes">
      <desc>The debug logger's group settings.</desc>
    </attribute>

    <attribute name="logDbgDestinations" type="wstring" readonly="yes">
      <desc>The debug logger's destination settings.</desc>
    </attribute>

    <attribute name="logRelFlags" type="wstring" readonly="yes">
      <desc>The release logger flags.</desc>
    </attribute>

    <attribute name="logRelGroups" type="wstring" readonly="yes">
      <desc>The release logger's group settings.</desc>
    </attribute>

    <attribute name="logRelDestinations" type="wstring" readonly="yes">
      <desc>The relase logger's destination settings.</desc>
    </attribute>

    <attribute name="HWVirtExEnabled" type="boolean" readonly="yes">
      <desc>
        Flag indicating whether the VM is currently making use of CPU hardware
        virtualization extensions.
      </desc>
    </attribute>

    <attribute name="HWVirtExNestedPagingEnabled" type="boolean" readonly="yes">
      <desc>
        Flag indicating whether the VM is currently making use of the nested paging
        CPU hardware virtualization extension.
      </desc>
    </attribute>

    <attribute name="HWVirtExVPIDEnabled" type="boolean" readonly="yes">
      <desc>
        Flag indicating whether the VM is currently making use of the VPID
        VT-x extension.
      </desc>
    </attribute>

    <attribute name="OSName" type="wstring" readonly="yes">
      <desc>
        Query the guest OS kernel name as detected by the DBGF.

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      </desc>
    </attribute>

    <attribute name="OSVersion" type="wstring" readonly="yes">
      <desc>
        Query the guest OS kernel version string as detected by the DBGF.

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      </desc>
    </attribute>

    <attribute name="PAEEnabled" type="boolean" readonly="yes">
      <desc>
        Flag indicating whether the VM is currently making use of the Physical
        Address Extension CPU feature.
      </desc>
    </attribute>

    <attribute name="virtualTimeRate" type="unsigned long">
      <desc>
        The rate at which the virtual time runs expressed as a percentage.
        The accepted range is 2% to 20000%.
      </desc>
    </attribute>

    <attribute name="VM" type="long long" readonly="yes">
      <desc>
        Gets the VM handle. This is only for internal use while
        we carve the details of this interface.
      </desc>
    </attribute>

  </interface>

  <!--
  // IUSBController
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IUSBController" extends="$unknown"
    uuid="01e6f13a-0580-452f-a40f-74e32a5e4921"
    wsmap="managed"
    >
    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the USB controller is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain any USB controller. Can only be changed when
        the VM is powered off.
      </desc>
    </attribute>

    <attribute name="enabledEHCI" type="boolean">
      <desc>
        Flag whether the USB EHCI controller is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain a USB EHCI controller. Can only be changed when
        the VM is powered off.
      </desc>
    </attribute>

    <attribute name="proxyAvailable" type="boolean" readonly="yes">
      <desc>
        Flag whether there is an USB proxy available.
      </desc>
    </attribute>

    <attribute name="USBStandard" type="unsigned short" readonly="yes">
      <desc>
        USB standard version which the controller implements.
        This is a BCD which means that the major version is in the
        high byte and minor version is in the low byte.
      </desc>
    </attribute>

    <attribute name="deviceFilters" type="IUSBDeviceFilter" readonly="yes" safearray="yes">
      <desc>
        List of USB device filters associated with the machine.

        If the machine is currently running, these filters are activated
        every time a new (supported) USB device is attached to the host
        computer that was not ignored by global filters
        (<link to="IHost::USBDeviceFilters"/>).

        These filters are also activated when the machine is powered up.
        They are run against a list of all currently available USB
        devices (in states
        <link to="USBDeviceState_Available"/>,
        <link to="USBDeviceState_Busy"/>,
        <link to="USBDeviceState_Held"/>) that were not previously
        ignored by global filters.

        If at least one filter matches the USB device in question, this
        device is automatically captured (attached to) the virtual USB
        controller of this machine.

        <see><link to="IUSBDeviceFilter"/>, <link to="IUSBController"/></see>
      </desc>
    </attribute>

    <method name="createDeviceFilter">
      <desc>
        Creates a new USB device filter. All attributes except
        the filter name are set to empty (any match),
        <i>active</i> is @c false (the filter is not active).

        The created filter can then be added to the list of filters using
        <link to="#insertDeviceFilter"/>.

        <result name="VBOX_E_INVALID_VM_STATE">
          The virtual machine is not mutable.
        </result>

        <see><link to="#deviceFilters"/></see>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          Filter name. See <link to="IUSBDeviceFilter::name"/>
          for more info.
        </desc>
      </param>
      <param name="filter" type="IUSBDeviceFilter" dir="return">
        <desc>Created filter object.</desc>
      </param>
    </method>

    <method name="insertDeviceFilter">
      <desc>
        Inserts the given USB device to the specified position
        in the list of filters.

        Positions are numbered starting from <tt>0</tt>. If the specified
        position is equal to or greater than the number of elements in
        the list, the filter is added to the end of the collection.

        <note>
          Duplicates are not allowed, so an attempt to insert a
          filter that is already in the collection, will return an
          error.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable.
        </result>
        <result name="E_INVALIDARG">
          USB device filter not created within this VirtualBox instance.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          USB device filter already in list.
        </result>

        <see><link to="#deviceFilters"/></see>
      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>Position to insert the filter to.</desc>
      </param>
      <param name="filter" type="IUSBDeviceFilter" dir="in">
        <desc>USB device filter to insert.</desc>
      </param>
    </method>

    <method name="removeDeviceFilter">
      <desc>
        Removes a USB device filter from the specified position in the
        list of filters.

        Positions are numbered starting from <tt>0</tt>. Specifying a
        position equal to or greater than the number of elements in
        the list will produce an error.

        <see><link to="#deviceFilters"/></see>

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable.
        </result>
        <result name="E_INVALIDARG">
          USB device filter list empty or invalid @a position.
        </result>

      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>Position to remove the filter from.</desc>
      </param>
      <param name="filter" type="IUSBDeviceFilter" dir="return">
        <desc>Removed USB device filter.</desc>
      </param>
    </method>

  </interface>


  <!--
  // IUSBDevice
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IUSBDevice" extends="$unknown"
    uuid="f8967b0b-4483-400f-92b5-8b675d98a85b"
    wsmap="managed"
    >
    <desc>
      The IUSBDevice interface represents a virtual USB device attached to the
      virtual machine.

      A collection of objects implementing this interface is stored in the
      <link to="IConsole::USBDevices"/> attribute which lists all USB devices
      attached to a running virtual machine's USB controller.
    </desc>

    <attribute name="id" type="uuid" mod="string" readonly="yes">
      <desc>
        Unique USB device ID. This ID is built from #vendorId,
        #productId, #revision and #serialNumber.
      </desc>
    </attribute>

    <attribute name="vendorId" type="unsigned short" readonly="yes">
      <desc>Vendor ID.</desc>
    </attribute>

    <attribute name="productId" type="unsigned short" readonly="yes">
      <desc>Product ID.</desc>
    </attribute>

    <attribute name="revision" type="unsigned short" readonly="yes">
      <desc>
        Product revision number. This is a packed BCD represented as
        unsigned short. The high byte is the integer part and the low
        byte is the decimal.
      </desc>
    </attribute>

    <attribute name="manufacturer" type="wstring" readonly="yes">
      <desc>Manufacturer string.</desc>
    </attribute>

    <attribute name="product" type="wstring" readonly="yes">
      <desc>Product string.</desc>
    </attribute>

    <attribute name="serialNumber" type="wstring" readonly="yes">
      <desc>Serial number string.</desc>
    </attribute>

    <attribute name="address" type="wstring" readonly="yes">
      <desc>Host specific address of the device.</desc>
    </attribute>

    <attribute name="port" type="unsigned short" readonly="yes">
      <desc>
        Host USB port number the device is physically
        connected to.
      </desc>
    </attribute>

    <attribute name="version" type="unsigned short" readonly="yes">
      <desc>
        The major USB version of the device - 1 or 2.
      </desc>
    </attribute>

    <attribute name="portVersion" type="unsigned short" readonly="yes">
      <desc>
        The major USB version of the host USB port the device is
        physically connected to - 1 or 2. For devices not connected to
        anything this will have the same value as the version attribute.
      </desc>
    </attribute>

    <attribute name="remote" type="boolean" readonly="yes">
      <desc>
        Whether the device is physically connected to a remote VRDE
        client or to a local host machine.
      </desc>
    </attribute>

  </interface>


  <!--
  // IUSBDeviceFilter
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IUSBDeviceFilter" extends="$unknown"
    uuid="d6831fb4-1a94-4c2c-96ef-8d0d6192066d"
    wsmap="managed"
    >
    <desc>
      The IUSBDeviceFilter interface represents an USB device filter used
      to perform actions on a group of USB devices.

      This type of filters is used by running virtual machines to
      automatically capture selected USB devices once they are physically
      attached to the host computer.

      A USB device is matched to the given device filter if and only if all
      attributes of the device match the corresponding attributes of the
      filter (that is, attributes are joined together using the logical AND
      operation). On the other hand, all together, filters in the list of
      filters carry the semantics of the logical OR operation. So if it is
      desirable to create a match like "this vendor id OR this product id",
      one needs to create two filters and specify "any match" (see below)
      for unused attributes.

      All filter attributes used for matching are strings. Each string
      is an expression representing a set of values of the corresponding
      device attribute, that will match the given filter. Currently, the
      following filtering expressions are supported:

      <ul>
        <li><i>Interval filters</i>. Used to specify valid intervals for
          integer device attributes (Vendor ID, Product ID and Revision).
          The format of the string is:

          <tt>int:((m)|([m]-[n]))(,(m)|([m]-[n]))*</tt>

          where <tt>m</tt> and <tt>n</tt> are integer numbers, either in octal
          (starting from <tt>0</tt>), hexadecimal (starting from <tt>0x</tt>)
          or decimal (otherwise) form, so that <tt>m &lt; n</tt>. If <tt>m</tt>
          is omitted before a dash (<tt>-</tt>), the minimum possible integer
          is assumed; if <tt>n</tt> is omitted after a dash, the maximum
          possible integer is assumed.
        </li>
        <li><i>Boolean filters</i>. Used to specify acceptable values for
          boolean device attributes. The format of the string is:

          <tt>true|false|yes|no|0|1</tt>

        </li>
        <li><i>Exact match</i>. Used to specify a single value for the given
          device attribute. Any string that doesn't start with <tt>int:</tt>
          represents the exact match. String device attributes are compared to
          this string including case of symbols. Integer attributes are first
          converted to a string (see individual filter attributes) and then
          compared ignoring case.

        </li>
        <li><i>Any match</i>. Any value of the corresponding device attribute
          will match the given filter. An empty or @c null string is
          used to construct this type of filtering expressions.

        </li>
      </ul>

      <note>
        On the Windows host platform, interval filters are not currently
        available. Also all string filter attributes
        (<link to="#manufacturer"/>, <link to="#product"/>,
        <link to="#serialNumber"/>) are ignored, so they behave as
        <i>any match</i> no matter what string expression is specified.
      </note>

      <see><link to="IUSBController::deviceFilters"/>,
        <link to="IHostUSBDeviceFilter"/></see>
    </desc>

    <attribute name="name" type="wstring">
      <desc>
        Visible name for this filter.
        This name is used to visually distinguish one filter from another,
        so it can neither be @c null nor an empty string.
      </desc>
    </attribute>

    <attribute name="active" type="boolean">
      <desc>Whether this filter active or has been temporarily disabled.</desc>
    </attribute>

    <attribute name="vendorId" type="wstring">
      <desc>
        <link to="IUSBDevice::vendorId">Vendor ID</link> filter.
        The string representation for the <i>exact matching</i>
        has the form <tt>XXXX</tt>, where <tt>X</tt> is the hex digit
        (including leading zeroes).
      </desc>
    </attribute>

    <attribute name="productId" type="wstring">
      <desc>
        <link to="IUSBDevice::productId">Product ID</link> filter.
        The string representation for the <i>exact matching</i>
        has the form <tt>XXXX</tt>, where <tt>X</tt> is the hex digit
        (including leading zeroes).
      </desc>
    </attribute>

    <attribute name="revision" type="wstring">
      <desc>
        <link to="IUSBDevice::productId">Product revision number</link>
        filter. The string representation for the <i>exact matching</i>
        has the form <tt>IIFF</tt>, where <tt>I</tt> is the decimal digit
        of the integer part of the revision, and <tt>F</tt> is the
        decimal digit of its fractional part (including leading and
        trailing zeros).
        Note that for interval filters, it's best to use the hexadecimal
        form, because the revision is stored as a 16 bit packed BCD value;
        so the expression <tt>int:0x0100-0x0199</tt> will match any
        revision from <tt>1.0</tt> to <tt>1.99</tt>.
      </desc>
    </attribute>

    <attribute name="manufacturer" type="wstring">
      <desc>
        <link to="IUSBDevice::manufacturer">Manufacturer</link> filter.
      </desc>
    </attribute>

    <attribute name="product" type="wstring">
      <desc>
        <link to="IUSBDevice::product">Product</link> filter.
      </desc>
    </attribute>

    <attribute name="serialNumber" type="wstring">
      <desc>
        <link to="IUSBDevice::serialNumber">Serial number</link> filter.
      </desc>
    </attribute>

    <attribute name="port" type="wstring">
      <desc>
        <link to="IUSBDevice::port">Host USB port</link> filter.
      </desc>
    </attribute>

    <attribute name="remote" type="wstring">
      <desc>
        <link to="IUSBDevice::remote">Remote state</link> filter.
        <note>
          This filter makes sense only for machine USB filters,
          i.e. it is ignored by IHostUSBDeviceFilter objects.
        </note>
      </desc>
    </attribute>

    <attribute name="maskedInterfaces" type="unsigned long">
      <desc>
        This is an advanced option for hiding one or more USB interfaces
        from the guest. The value is a bit mask where the bits that are set
        means the corresponding USB interface should be hidden, masked off
        if you like.
        This feature only works on Linux hosts.
      </desc>
    </attribute>

  </interface>


  <!--
  // IHostUSBDevice
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="USBDeviceState"
    uuid="b99a2e65-67fb-4882-82fd-f3e5e8193ab4"
    >
    <desc>
      USB device state. This enumeration represents all possible states
      of the USB device physically attached to the host computer regarding
      its state on the host computer and availability to guest computers
      (all currently running virtual machines).

      Once a supported USB device is attached to the host, global USB
      filters (<link to="IHost::USBDeviceFilters"/>) are activated. They can
      either ignore the device, or put it to USBDeviceState_Held state, or do
      nothing. Unless the device is ignored by global filters, filters of all
      currently running guests (<link to="IUSBController::deviceFilters"/>) are
      activated that can put it to USBDeviceState_Captured state.

      If the device was ignored by global filters, or didn't match
      any filters at all (including guest ones), it is handled by the host
      in a normal way. In this case, the device state is determined by
      the host and can be one of USBDeviceState_Unavailable, USBDeviceState_Busy
      or USBDeviceState_Available, depending on the current device usage.

      Besides auto-capturing based on filters, the device can be manually
      captured by guests (<link to="IConsole::attachUSBDevice"/>) if its
      state is USBDeviceState_Busy, USBDeviceState_Available or
      USBDeviceState_Held.

      <note>
        Due to differences in USB stack implementations in Linux and Win32,
        states USBDeviceState_Busy and USBDeviceState_Unavailable are applicable
        only to the Linux version of the product. This also means that (<link
        to="IConsole::attachUSBDevice"/>) can only succeed on Win32 if the
        device state is USBDeviceState_Held.
      </note>

      <see><link to="IHostUSBDevice"/>, <link to="IHostUSBDeviceFilter"/></see>
    </desc>

    <const name="NotSupported"          value="0">
      <desc>
        Not supported by the VirtualBox server, not available to guests.
      </desc>
    </const>
    <const name="Unavailable"           value="1">
      <desc>
        Being used by the host computer exclusively,
        not available to guests.
      </desc>
    </const>
    <const name="Busy"                  value="2">
      <desc>
        Being used by the host computer, potentially available to guests.
      </desc>
    </const>
    <const name="Available"             value="3">
      <desc>
        Not used by the host computer, available to guests (the host computer
        can also start using the device at any time).
      </desc>
    </const>
    <const name="Held"                  value="4">
      <desc>
        Held by the VirtualBox server (ignored by the host computer),
        available to guests.
      </desc>
    </const>
    <const name="Captured"              value="5">
      <desc>
        Captured by one of the guest computers, not available
        to anybody else.
      </desc>
    </const>
  </enum>

  <interface
    name="IHostUSBDevice" extends="IUSBDevice"
    uuid="173b4b44-d268-4334-a00d-b6521c9a740a"
    wsmap="managed"
    >
    <desc>
      The IHostUSBDevice interface represents a physical USB device attached
      to the host computer.

      Besides properties inherited from IUSBDevice, this interface adds the
      <link to="#state"/> property that holds the current state of the USB
      device.

      <see><link to="IHost::USBDevices"/>,
        <link to="IHost::USBDeviceFilters"/></see>
    </desc>

    <attribute name="state" type="USBDeviceState" readonly="yes">
      <desc>
        Current state of the device.
      </desc>
    </attribute>

    <!-- @todo add class, subclass, bandwidth, configs, interfaces endpoints and such later. -->

  </interface>


  <!--
  // IHostUSBDeviceFilter
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="USBDeviceFilterAction"
    uuid="cbc30a49-2f4e-43b5-9da6-121320475933"
    >
    <desc>
      Actions for host USB device filters.
      <see><link to="IHostUSBDeviceFilter"/>, <link to="USBDeviceState"/></see>
    </desc>

    <const name="Null"          value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="Ignore"        value="1">
      <desc>Ignore the matched USB device.</desc>
    </const>
    <const name="Hold"          value="2">
      <desc>Hold the matched USB device.</desc>
    </const>
  </enum>

  <interface
    name="IHostUSBDeviceFilter" extends="IUSBDeviceFilter"
    uuid="4cc70246-d74a-400f-8222-3900489c0374"
    wsmap="managed"
    >
    <desc>
      The IHostUSBDeviceFilter interface represents a global filter for a
      physical USB device used by the host computer. Used indirectly in
      <link to="IHost::USBDeviceFilters"/>.

      Using filters of this type, the host computer determines the initial
      state of the USB device after it is physically attached to the
      host's USB controller.

      <note>
        The <link to="IUSBDeviceFilter::remote"/> attribute is ignored by this type of
        filters, because it makes sense only for
        <link to="IUSBController::deviceFilters">machine USB filters</link>.
      </note>

      <see><link to="IHost::USBDeviceFilters"/></see>
    </desc>

    <attribute name="action" type="USBDeviceFilterAction">
      <desc>
        Action performed by the host when an attached USB device
        matches this filter.
      </desc>
    </attribute>

  </interface>

  <!--
  // IAudioAdapter
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="AudioDriverType"
    uuid="4bcc3d73-c2fe-40db-b72f-0c2ca9d68496"
    >
    <desc>
      Host audio driver type.
    </desc>

    <const name="Null"          value="0">
      <desc>Null value, also means "dummy audio driver".</desc>
    </const>
    <const name="WinMM"         value="1">
        <desc>Windows multimedia (Windows hosts only).</desc>
    </const>
    <const name="OSS"           value="2">
        <desc>Open Sound System (Linux hosts only).</desc>
    </const>
    <const name="ALSA"          value="3">
        <desc>Advanced Linux Sound Architecture (Linux hosts only).</desc>
    </const>
    <const name="DirectSound"   value="4">
        <desc>DirectSound (Windows hosts only).</desc>
    </const>
    <const name="CoreAudio"     value="5">
        <desc>CoreAudio (Mac hosts only).</desc>
    </const>
    <const name="MMPM"          value="6">
        <desc>Reserved for historical reasons.</desc>
    </const>
    <const name="Pulse"         value="7">
        <desc>PulseAudio (Linux hosts only).</desc>
    </const>
    <const name="SolAudio"      value="8">
        <desc>Solaris audio (Solaris hosts only).</desc>
    </const>
  </enum>

  <enum
    name="AudioControllerType"
    uuid="7afd395c-42c3-444e-8788-3ce80292f36c"
    >
    <desc>
      Virtual audio controller type.
    </desc>

    <const name="AC97" value="0"/>
    <const name="SB16" value="1"/>
    <const name="HDA"  value="2"/>
  </enum>

  <interface
    name="IAudioAdapter" extends="$unknown"
    uuid="921873db-5f3f-4b69-91f9-7be9e535a2cb"
    wsmap="managed"
    >
    <desc>
        The IAudioAdapter interface represents the virtual audio adapter of
        the virtual machine. Used in <link to="IMachine::audioAdapter"/>.
    </desc>
    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the audio adapter is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain any audio adapter. Can only be changed when
        the VM is not running.
      </desc>
    </attribute>
    <attribute name="audioController" type="AudioControllerType">
      <desc>
        The audio hardware we emulate.
      </desc>
    </attribute>
    <attribute name="audioDriver" type="AudioDriverType">
      <desc>
        Audio driver the adapter is connected to. This setting
        can only be changed when the VM is not running.
      </desc>
    </attribute>
  </interface>

  <enum
    name="AuthType"
    uuid="7eef6ef6-98c2-4dc2-ab35-10d2b292028d"
    >
    <desc>
      VirtualBox authentication type.
    </desc>

    <const name="Null"            value="0">
      <desc>Null value, also means "no authentication".</desc>
    </const>
    <const name="External"        value="1"/>
    <const name="Guest"           value="2"/>
  </enum>

  <!--
  // IVRDEServer
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IVRDEServer" extends="$unknown"
    uuid="d38de40a-c2c1-4e95-b5a4-167b05f5694c"
    wsmap="managed"
    >
    <attribute name="enabled" type="boolean">
      <desc>VRDE server status.</desc>
    </attribute>

    <attribute name="authType" type="AuthType">
      <desc>VRDE authentication method.</desc>
    </attribute>

    <attribute name="authTimeout" type="unsigned long">
      <desc>Timeout for guest authentication. Milliseconds.</desc>
    </attribute>

    <attribute name="allowMultiConnection" type="boolean">
      <desc>
        Flag whether multiple simultaneous connections to the VM are permitted.
        Note that this will be replaced by a more powerful mechanism in the future.
      </desc>
    </attribute>

    <attribute name="reuseSingleConnection" type="boolean">
      <desc>
        Flag whether the existing connection must be dropped and a new connection
        must be established by the VRDE server, when a new client connects in single
        connection mode.
      </desc>
    </attribute>

    <attribute name="VRDEExtPack" type="wstring">
      <desc>
        The name of Extension Pack providing VRDE for this VM.  Overrides
        <link to="ISystemProperties::defaultVRDEExtPack"/>.
      </desc>
    </attribute>

    <attribute name="authLibrary" type="wstring">
      <desc>
        Library used for authentication of RDP clients by this VM. Overrides
        <link to="ISystemProperties::VRDEAuthLibrary"/>.
      </desc>
    </attribute>

    <attribute name="VRDEProperties" type="wstring" readonly="yes" safearray="yes">
      <desc>
        Array of names of properties, which are supported by this VRDE server.
      </desc>
    </attribute>

    <method name="setVRDEProperty">
      <desc>
        Sets a VRDE specific property string.

        If you pass @c null or empty string as a key @a value, the given @a key
        will be deleted.

      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the key to set.</desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>Value to assign to the key.</desc>
      </param>
    </method>

    <method name="getVRDEProperty" const="yes">
      <desc>
        Returns a VRDE specific property string.

        If the requested data @a key does not exist, this function will
        succeed and return an empty string in the @a value argument.

      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the key to get.</desc>
      </param>
      <param name="value" type="wstring" dir="return">
        <desc>Value of the requested key.</desc>
      </param>
    </method>

  </interface>


  <!--
  // ISharedFolder
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="ISharedFolder" extends="$unknown"
    uuid="8388da11-b559-4574-a5b7-2bd7acd5cef8"
    wsmap="struct"
    >
    <desc>
      The ISharedFolder interface represents a folder in the host computer's
      file system accessible from the guest OS running inside a virtual
      machine using an associated logical name.

      There are three types of shared folders:
      <ul>
        <li><i>Global</i> (<link to="IVirtualBox::sharedFolders"/>), shared
        folders available to all virtual machines.</li>
        <li><i>Permanent</i> (<link to="IMachine::sharedFolders"/>),
        VM-specific shared folders available to the given virtual machine at
        startup.</li>
        <li><i>Transient</i> (<link to="IConsole::sharedFolders"/>),
        VM-specific shared folders created in the session context (for
        example, when the virtual machine is running) and automatically
        discarded when the session is closed (the VM is powered off).</li>
      </ul>

      Logical names of shared folders must be unique within the given scope
      (global, permanent or transient). However, they do not need to be unique
      across scopes. In this case, the definition of the shared folder in a
      more specific scope takes precedence over definitions in all other
      scopes. The order of precedence is (more specific to more general):
      <ol>
        <li>Transient definitions</li>
        <li>Permanent definitions</li>
        <li>Global definitions</li>
      </ol>

      For example, if MyMachine has a shared folder named
      <tt>C_DRIVE</tt> (that points to <tt>C:\\</tt>), then creating a
      transient shared folder named <tt>C_DRIVE</tt> (that points
      to <tt>C:\\\\WINDOWS</tt>) will change the definition
      of <tt>C_DRIVE</tt> in the guest OS so
      that <tt>\\\\VBOXSVR\\C_DRIVE</tt> will give access
      to <tt>C:\\WINDOWS</tt> instead of <tt>C:\\</tt> on the host
      PC. Removing the transient shared folder <tt>C_DRIVE</tt> will restore
      the previous (permanent) definition of <tt>C_DRIVE</tt> that points
      to <tt>C:\\</tt> if it still exists.

      Note that permanent and transient shared folders of different machines
      are in different name spaces, so they don't overlap and don't need to
      have unique logical names.

      <note>
        Global shared folders are not implemented in the current version of the
        product.
      </note>
    </desc>

    <attribute name="name" type="wstring" readonly="yes">
      <desc>Logical name of the shared folder.</desc>
    </attribute>

    <attribute name="hostPath" type="wstring" readonly="yes">
      <desc>Full path to the shared folder in the host file system.</desc>
    </attribute>

    <attribute name="accessible" type="boolean" readonly="yes">
      <desc>
        Whether the folder defined by the host path is currently
        accessible or not.
        For example, the folder can be inaccessible if it is placed
        on the network share that is not available by the time
        this property is read.
      </desc>
    </attribute>

    <attribute name="writable" type="boolean" readonly="yes">
      <desc>
        Whether the folder defined by the host path is writable or
        not.
      </desc>
    </attribute>

    <attribute name="autoMount" type="boolean" readonly="yes">
      <desc>
        Whether the folder gets automatically mounted by the guest or not.
      </desc>
    </attribute>

    <attribute name="lastAccessError" type="wstring" readonly="yes">
      <desc>
        Text message that represents the result of the last accessibility
        check.

        Accessibility checks are performed each time the <link to="#accessible"/>
        attribute is read. An empty string is returned if the last
        accessibility check was successful. A non-empty string indicates a
        failure and should normally describe a reason of the failure (for
        example, a file read error).
      </desc>
    </attribute>

  </interface>

  <!--
  // ISession
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IInternalSessionControl" extends="$unknown"
    uuid="3e83963a-1c3b-400d-8c5f-f2d077b0a597"
    internal="yes"
    wsmap="suppress"
    >
    <method name="getPID">
      <desc>PID of the process that has created this Session object.
      </desc>
      <param name="pid" type="unsigned long" dir="return"/>
    </method>

    <method name="getRemoteConsole">
      <desc>
        Returns the console object suitable for remote control.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="console" type="IConsole" dir="return"/>
    </method>

    <method name="assignMachine">
      <desc>
        Assigns the machine object associated with this direct-type
        session or informs the session that it will be a remote one
        (if @a machine == @c null).

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="machine" type="IMachine" dir="in"/>
      <param name="lockType" type="LockType" dir="in"/>
    </method>

    <method name="assignRemoteMachine">
      <desc>
        Assigns the machine and the (remote) console object associated with
        this remote-type session.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>

      </desc>
      <param name="machine" type="IMachine" dir="in"/>
      <param name="console" type="IConsole" dir="in"/>
    </method>

    <method name="updateMachineState">
      <desc>
        Updates the machine state in the VM process.
        Must be called only in certain cases
        (see the method implementation).

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="aMachineState" type="MachineState" dir="in"/>
    </method>

    <method name="uninitialize">
      <desc>
        Uninitializes (closes) this session. Used by VirtualBox to close
        the corresponding remote session when the direct session dies
        or gets closed.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>

      </desc>
    </method>

    <method name="onNetworkAdapterChange">
      <desc>
        Triggered when settings of a network adapter of the
        associated virtual machine have changed.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="networkAdapter" type="INetworkAdapter" dir="in"/>
      <param name="changeAdapter" type="boolean" dir="in"/>
    </method>

    <method name="onSerialPortChange">
      <desc>
        Triggered when settings of a serial port of the
        associated virtual machine have changed.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="serialPort" type="ISerialPort" dir="in"/>
    </method>

    <method name="onParallelPortChange">
      <desc>
        Triggered when settings of a parallel port of the
        associated virtual machine have changed.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="parallelPort" type="IParallelPort" dir="in"/>
    </method>

    <method name="onStorageControllerChange">
      <desc>
        Triggered when settings of a storage controller of the
        associated virtual machine have changed.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
    </method>

    <method name="onMediumChange">
      <desc>
        Triggered when attached media of the
        associated virtual machine have changed.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>

      <param name="mediumAttachment" type="IMediumAttachment" dir="in">
        <desc>The medium attachment which changed.</desc>
      </param>
      <param name="force" type="boolean" dir="in">
        <desc>If the medium change was forced.</desc>
      </param>
    </method>

    <method name="onStorageDeviceChange">
      <desc>
        Triggered when attached storage devices of the
        associated virtual machine have changed.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>

      <param name="mediumAttachment" type="IMediumAttachment" dir="in">
        <desc>The medium attachment which changed.</desc>
      </param>
      <param name="remove" type="boolean" dir="in">
        <desc>TRUE if the device is removed, FALSE if it was added.</desc>
      </param>
    </method>

    <method name="onClipboardModeChange">
      <desc>
        Notification when the shared clipboard mode changes.
      </desc>
      <param name="clipboardMode" type="ClipboardMode" dir="in">
        <desc>The new shared clipboard mode.</desc>
      </param>
    </method>

    <method name="onDragAndDropModeChange">
      <desc>
        Notification when the drag'n'drop mode changes.
      </desc>
      <param name="dragAndDropMode" type="DragAndDropMode" dir="in">
        <desc>The new mode for drag'n'drop.</desc>
      </param>
    </method>

    <method name="onCPUChange">
      <desc>
        Notification when a CPU changes.
      </desc>
      <param name="cpu" type="unsigned long" dir="in">
        <desc>The CPU which changed</desc>
      </param>
      <param name="add" type="boolean" dir="in">
        <desc>Flag whether the CPU was added or removed</desc>
      </param>
    </method>

    <method name="onCPUExecutionCapChange">
      <desc>
        Notification when the CPU execution cap changes.
      </desc>
      <param name="executionCap" type="unsigned long" dir="in">
        <desc>The new CPU execution cap value. (1-100)</desc>
      </param>
    </method>

    <method name="onVRDEServerChange">
      <desc>
        Triggered when settings of the VRDE server object of the
        associated virtual machine have changed.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="restart" type="boolean" dir="in">
        <desc>Flag whether the server must be restarted</desc>
      </param>
    </method>

    <method name="onUSBControllerChange">
      <desc>
        Triggered when settings of the USB controller object of the
        associated virtual machine have changed.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
    </method>

    <method name="onSharedFolderChange">
      <desc>
        Triggered when a permanent (global or machine) shared folder has been
        created or removed.
        <note>
          We don't pass shared folder parameters in this notification because
          the order in which parallel notifications are delivered is not defined,
          therefore it could happen that these parameters were outdated by the
          time of processing this notification.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="global" type="boolean" dir="in"/>
    </method>

    <method name="onUSBDeviceAttach">
      <desc>
        Triggered when a request to capture a USB device (as a result
        of matched USB filters or direct call to
        <link to="IConsole::attachUSBDevice"/>) has completed.
        A @c null @a error object means success, otherwise it
        describes a failure.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="device" type="IUSBDevice" dir="in"/>
      <param name="error" type="IVirtualBoxErrorInfo" dir="in"/>
      <param name="maskedInterfaces" type="unsigned long" dir="in"/>
    </method>

    <method name="onUSBDeviceDetach">
      <desc>
        Triggered when a request to release the USB device (as a result
        of machine termination or direct call to
        <link to="IConsole::detachUSBDevice"/>) has completed.
        A @c null @a error object means success, otherwise it
        describes a failure.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="id" type="uuid" mod="string" dir="in"/>
      <param name="error" type="IVirtualBoxErrorInfo" dir="in"/>
    </method>

    <method name="onShowWindow">
      <desc>
        Called by <link to="IMachine::canShowConsoleWindow"/> and by
        <link to="IMachine::showConsoleWindow"/> in order to notify
        console listeners
        <link to="ICanShowWindowEvent"/>
        and <link to="IShowWindowEvent"/>.

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="check" type="boolean" dir="in"/>
      <param name="canShow" type="boolean" dir="out"/>
      <param name="winId" type="long long" dir="out"/>
    </method>

    <method name="onBandwidthGroupChange">
      <desc>
        Notification when one of the bandwidth groups change.
      </desc>
      <param name="bandwidthGroup" type="IBandwidthGroup" dir="in">
        <desc>The bandwidth group which changed.</desc>
      </param>
    </method>

    <method name="accessGuestProperty">
      <desc>
        Called by <link to="IMachine::getGuestProperty"/> and by
        <link to="IMachine::setGuestProperty"/> in order to read and
        modify guest properties.

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type is not direct.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in"/>
      <param name="value" type="wstring" dir="in"/>
      <param name="flags" type="wstring" dir="in"/>
      <param name="isSetter" type="boolean" dir="in"/>
      <param name="retValue" type="wstring" dir="out"/>
      <param name="retTimestamp" type="long long" dir="out"/>
      <param name="retFlags" type="wstring" dir="out"/>
    </method>

    <method name="enumerateGuestProperties" const="yes">
      <desc>
        Return a list of the guest properties matching a set of patterns along
        with their values, time stamps and flags.

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type is not direct.
        </result>

      </desc>
      <param name="patterns" type="wstring" dir="in">
        <desc>
          The patterns to match the properties against as a comma-separated
          string.  If this is empty, all properties currently set will be
          returned.
        </desc>
      </param>
      <param name="key" type="wstring" dir="out" safearray="yes">
        <desc>
          The key names of the properties returned.
        </desc>
      </param>
      <param name="value" type="wstring" dir="out" safearray="yes">
        <desc>
          The values of the properties returned.  The array entries match the
          corresponding entries in the @a key array.
        </desc>
      </param>
      <param name="timestamp" type="long long" dir="out" safearray="yes">
        <desc>
          The time stamps of the properties returned.  The array entries match
          the corresponding entries in the @a key array.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="out" safearray="yes">
        <desc>
          The flags of the properties returned.  The array entries match the
          corresponding entries in the @a key array.
        </desc>
      </param>
    </method>

    <method name="onlineMergeMedium">
      <desc>
        Triggers online merging of a hard disk. Used internally when deleting
        a snapshot while a VM referring to the same hard disk chain is running.

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type is not direct.
        </result>

      </desc>
      <param name="mediumAttachment" type="IMediumAttachment" dir="in">
        <desc>The medium attachment to identify the medium chain.</desc>
      </param>
      <param name="sourceIdx" type="unsigned long" dir="in">
        <desc>The index of the source image in the chain.
        Redundant, but drastically reduces IPC.</desc>
      </param>
      <param name="targetIdx" type="unsigned long" dir="in">
        <desc>The index of the target image in the chain.
        Redundant, but drastically reduces IPC.</desc>
      </param>
      <param name="source" type="IMedium" dir="in">
        <desc>Merge source medium.</desc>
      </param>
      <param name="target" type="IMedium" dir="in">
        <desc>Merge target medium.</desc>
      </param>
      <param name="mergeForward" type="boolean" dir="in">
        <desc>Merge direction.</desc>
      </param>
      <param name="parentForTarget" type="IMedium" dir="in">
        <desc>For forward merges: new parent for target medium.</desc>
      </param>
      <param name="childrenToReparent" type="IMedium" safearray="yes" dir="in">
        <desc>For backward merges: list of media which need their parent UUID
        updated.</desc>
      </param>
      <param name="progress" type="IProgress" dir="in">
        <desc>
          Progress object for this operation.
        </desc>
      </param>
    </method>

    <method name="enableVMMStatistics">
      <desc>
        Enables or disables collection of VMM RAM statistics.

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type is not direct.
        </result>

      </desc>
      <param name="enable" type="boolean" dir="in">
        <desc>True enables statistics collection.</desc>
      </param>
    </method>

  </interface>

  <interface
    name="ISession" extends="$unknown"
    uuid="12F4DCDB-12B2-4EC1-B7CD-DDD9F6C5BF4D"
    wsmap="managed"
    >
    <desc>
      The ISession interface represents a client process and allows for locking
      virtual machines (represented by IMachine objects) to prevent conflicting
      changes to the machine.

      Any caller wishing to manipulate a virtual machine needs to create a session
      object first, which lives in its own process space. Such session objects are
      then associated with <link to="IMachine" /> objects living in the VirtualBox
      server process to coordinate such changes.

      There are two typical scenarios in which sessions are used:

      <ul>
        <li>To alter machine settings or control a running virtual machine, one
          needs to lock a machine for a given session (client process) by calling
          <link to="IMachine::lockMachine"/>.

          Whereas multiple sessions may control a running virtual machine, only
          one process can obtain a write lock on the machine to prevent conflicting
          changes. A write lock is also needed if a process wants to actually run a
          virtual machine in its own context, such as the VirtualBox GUI or
          VBoxHeadless front-ends. They must also lock a machine for their own
          sessions before they are allowed to power up the virtual machine.

          As a result, no machine settings can be altered while another process is
          already using it, either because that process is modifying machine settings
          or because the machine is running.
        </li>
        <li>
          To start a VM using one of the existing VirtualBox front-ends (e.g. the
          VirtualBox GUI or VBoxHeadless), one would use
          <link to="IMachine::launchVMProcess"/>, which also takes a session object
          as its first parameter. This session then identifies the caller and lets the
          caller control the started machine (for example, pause machine execution or
          power it down) as well as be notified about machine execution state changes.
        </li>
      </ul>

      How sessions objects are created in a client process depends on whether you use
      the Main API via COM or via the webservice:

      <ul>
        <li>When using the COM API directly, an object of the Session class from the
          VirtualBox type library needs to be created. In regular COM C++ client code,
          this can be done by calling <tt>createLocalObject()</tt>, a standard COM API.
          This object will  then act as a local session object in further calls to open
          a session.
        </li>

        <li>In the webservice, the session manager (IWebsessionManager) instead creates
          a session object automatically whenever <link to="IWebsessionManager::logon" />
          is called. A managed object reference to that session object can be retrieved by
          calling <link to="IWebsessionManager::getSessionObject" />.
        </li>
      </ul>
    </desc>

    <attribute name="state" type="SessionState" readonly="yes">
      <desc>Current state of this session.</desc>
    </attribute>

    <attribute name="type" type="SessionType" readonly="yes">
      <desc>
        Type of this session. The value of this attribute is valid only
        if the session currently has a machine locked (i.e. its
        <link to="#state" /> is Locked), otherwise an error will be returned.
      </desc>
    </attribute>

    <attribute name="machine" type="IMachine" readonly="yes">
      <desc>Machine object associated with this session.</desc>
    </attribute>

    <attribute name="console" type="IConsole" readonly="yes">
      <desc>Console object associated with this session.</desc>
    </attribute>

    <method name="unlockMachine">
      <desc>
        Unlocks a machine that was previously locked for the current session.

        Calling this method is required every time a machine has been locked
        for a particular session using the <link to="IMachine::launchVMProcess" />
        or <link to="IMachine::lockMachine" /> calls. Otherwise the state of
        the machine will be set to <link to="MachineState_Aborted" /> on the
        server, and changes made to the machine settings will be lost.

        Generally, it is recommended to unlock all machines explicitly
        before terminating the application (regardless of the reason for
        the termination).

        <note>
          Do not expect the session state (<link to="ISession::state" />
          to return to "Unlocked" immediately after you invoke this method,
          particularly if you have started a new VM process. The session
          state will automatically return to "Unlocked" once the VM is no
          longer executing, which can of course take a very long time.
        </note>

        <result name="E_UNEXPECTED">
          Session is not locked.
        </result>

      </desc>
    </method>

  </interface>

  <!--
  // IStorageController
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="StorageBus"
    uuid="eee67ab3-668d-4ef5-91e0-7025fe4a0d7a"
    >
    <desc>
      The bus type of the storage controller (IDE, SATA, SCSI, SAS or Floppy);
      see <link to="IStorageController::bus" />.
    </desc>
    <const name="Null"         value="0">
      <desc>@c null value. Never used by the API.</desc>
    </const>
    <const name="IDE"       value="1"/>
    <const name="SATA"      value="2"/>
    <const name="SCSI"      value="3"/>
    <const name="Floppy"    value="4"/>
    <const name="SAS"       value="5"/>
  </enum>

  <enum
    name="StorageControllerType"
    uuid="8a412b8a-f43e-4456-bd37-b474f0879a58"
    >
    <desc>
      The exact variant of storage controller hardware presented
      to the guest; see <link to="IStorageController::controllerType" />.
    </desc>

    <const name="Null"         value="0">
      <desc>@c null value. Never used by the API.</desc>
    </const>
    <const name="LsiLogic"  value="1">
      <desc>A SCSI controller of the LsiLogic variant.</desc>
    </const>
    <const name="BusLogic"  value="2">
      <desc>A SCSI controller of the BusLogic variant.</desc>
    </const>
    <const name="IntelAhci" value="3">
      <desc>An Intel AHCI SATA controller; this is the only variant for SATA.</desc>
    </const>
    <const name="PIIX3"     value="4">
      <desc>An IDE controller of the PIIX3 variant.</desc>
    </const>
    <const name="PIIX4"     value="5">
      <desc>An IDE controller of the PIIX4 variant.</desc>
    </const>
    <const name="ICH6"      value="6">
      <desc>An IDE controller of the ICH6 variant.</desc>
    </const>
    <const name="I82078"    value="7">
      <desc>A floppy disk controller; this is the only variant for floppy drives.</desc>
    </const>
    <const name="LsiLogicSas"  value="8">
      <desc>A variant of the LsiLogic controller using SAS.</desc>
    </const>
  </enum>

  <enum
    name="ChipsetType"
    uuid="8b4096a8-a7c3-4d3b-bbb1-05a0a51ec394"
    >
    <desc>
      Type of emulated chipset (mostly southbridge).
    </desc>

    <const name="Null"         value="0">
      <desc>@c null value. Never used by the API.</desc>
    </const>
    <const name="PIIX3"  value="1">
      <desc>A PIIX3 (PCI IDE ISA Xcelerator) chipset.</desc>
    </const>
    <const name="ICH9"  value="2">
      <desc>A ICH9 (I/O Controller Hub) chipset.</desc>
    </const>
  </enum>

  <interface
    name="IStorageController" extends="$unknown"
    uuid="a1556333-09b6-46d9-bfb7-fc239b7fbe1e"
    wsmap="managed"
    >
    <desc>
        Represents a storage controller that is attached to a virtual machine
        (<link to="IMachine" />). Just as drives (hard disks, DVDs, FDs) are
        attached to storage controllers in a real computer, virtual drives
        (represented by <link to="IMediumAttachment" />) are attached to virtual
        storage controllers, represented by this interface.

        As opposed to physical hardware, VirtualBox has a very generic concept
        of a storage controller, and for purposes of the Main API, all virtual
        storage is attached to virtual machines via instances of this interface.
        There are five types of such virtual storage controllers: IDE, SCSI, SATA,
        SAS and Floppy (see <link to="#bus" />). Depending on which of these four
        is used, certain sub-types may be available and can be selected in
        <link to="#controllerType" />.

        Depending on these settings, the guest operating system might see
        significantly different virtual hardware.
    </desc>

    <attribute name="name" type="wstring" readonly="yes">
      <desc>
        Name of the storage controller, as originally specified with
        <link to="IMachine::addStorageController" />. This then uniquely
        identifies this controller with other method calls such as
        <link to="IMachine::attachDevice" /> and  <link to="IMachine::mountMedium" />.
      </desc>
    </attribute>

    <attribute name="maxDevicesPerPortCount" type="unsigned long" readonly="yes">
      <desc>
        Maximum number of devices which can be attached to one port.
      </desc>
    </attribute>

    <attribute name="minPortCount" type="unsigned long" readonly="yes">
      <desc>
        Minimum number of ports that <link to="IStorageController::portCount"/> can be set to.
      </desc>
    </attribute>

    <attribute name="maxPortCount" type="unsigned long" readonly="yes">
      <desc>
        Maximum number of ports that <link to="IStorageController::portCount"/> can be set to.
      </desc>
    </attribute>

    <attribute name="instance" type="unsigned long">
      <desc>
        The instance number of the device in the running VM.
      </desc>
    </attribute>

    <attribute name="portCount" type="unsigned long">
      <desc>
        The number of currently usable ports on the controller.
        The minimum and maximum number of ports for one controller are
        stored in <link to="IStorageController::minPortCount"/>
        and <link to="IStorageController::maxPortCount"/>.
      </desc>
    </attribute>

    <attribute name="bus" type="StorageBus" readonly="yes">
      <desc>
        The bus type of the storage controller (IDE, SATA, SCSI, SAS or Floppy).
      </desc>
    </attribute>

    <attribute name="controllerType" type="StorageControllerType">
      <desc>
        The exact variant of storage controller hardware presented
        to the guest.
        Depending on this value, VirtualBox will provide a different
        virtual storage controller hardware to the guest.
        For SATA, SAS and floppy controllers, only one variant is
        available, but for IDE and SCSI, there are several.

        For SCSI controllers, the default type is LsiLogic.
      </desc>
    </attribute>

    <attribute name="useHostIOCache" type="boolean">
      <desc>
        If true, the storage controller emulation will use a dedicated I/O thread, enable the host I/O
        caches and use synchronous file APIs on the host. This was the only option in the API before
        VirtualBox 3.2 and is still the default for IDE controllers.

        If false, the host I/O cache will be disabled for image files attached to this storage controller.
        Instead, the storage controller emulation will use asynchronous I/O APIs on the host. This makes
        it possible to turn off the host I/O caches because the emulation can handle unaligned access to
        the file. This should be used on OS X and Linux hosts if a high I/O load is expected or many
        virtual machines are running at the same time to prevent I/O cache related hangs.
        This option new with the API of VirtualBox 3.2 and is now the default for non-IDE storage controllers.
      </desc>
    </attribute>

    <attribute name="bootable" type="boolean" readonly="yes">
      <desc>
        Returns whether it is possible to boot from disks attached to this controller.
      </desc>
    </attribute>
  </interface>

<if target="wsdl">

  <!--
  // IManagedObjectRef
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IManagedObjectRef" extends="$unknown"
    uuid="9474d09d-2313-46de-b568-a42b8718e8ed"
    internal="yes"
    wsmap="managed"
    wscpp="hardcoded"
    >
    <desc>
      Managed object reference.

      Only within the webservice, a managed object reference (which is really
      an opaque number) allows a webservice client to address an object
      that lives in the address space of the webservice server.

      Behind each managed object reference, there is a COM object that lives
      in the webservice server's address space. The COM object is not freed
      until the managed object reference is released, either by an explicit
      call to  <link to="IManagedObjectRef::release" /> or by logging off from
      the webservice (<link to="IWebsessionManager::logoff" />), which releases
      all objects created during the webservice session.

      Whenever a method call of the VirtualBox API returns a COM object, the
      webservice representation of that method will instead return a
      managed object reference, which can then be used to invoke methods
      on that object.
    </desc>

    <method name="getInterfaceName">
      <desc>
        Returns the name of the interface that this managed object represents,
        for example, "IMachine", as a string.
      </desc>
      <param name="return" type="wstring" dir="return"/>
    </method>

    <method name="release">
      <desc>
        Releases this managed object reference and frees the resources that
        were allocated for it in the webservice server process. After calling
        this method, the identifier of the reference can no longer be used.
      </desc>
    </method>

  </interface>

  <!--
  // IWebsessionManager
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IWebsessionManager" extends="$unknown"
    uuid="dea1b4c7-2de3-418a-850d-7868617f7733"
    internal="yes"
    wsmap="global"
    wscpp="hardcoded"
    >
    <desc>
      Websession manager. This provides essential services
      to webservice clients.
    </desc>
    <method name="logon">
      <desc>
        Logs a new client onto the webservice and returns a managed object reference to
        the IVirtualBox instance, which the client can then use as a basis to further
        queries, since all calls to the VirtualBox API are based on the IVirtualBox
        interface, in one way or the other.
      </desc>
      <param name="username" type="wstring" dir="in"/>
      <param name="password" type="wstring" dir="in"/>
      <param name="return" type="IVirtualBox" dir="return"/>
    </method>

    <method name="getSessionObject">
      <desc>
        Returns a managed object reference to the internal ISession object that was created
        for this web service session when the client logged on.

        <see><link to="ISession"/></see>
      </desc>
      <param name="refIVirtualBox" type="IVirtualBox" dir="in"/>
      <param name="return" type="ISession" dir="return"/>
    </method>

    <method name="logoff">
      <desc>
        Logs off the client who has previously logged on with <link to="IWebsessionManager::logon" />
        and destroys all resources associated with the session (most importantly, all
        managed objects created in the server while the session was active).
      </desc>
      <param name="refIVirtualBox" type="IVirtualBox" dir="in"/>
    </method>

  </interface>

</if>

  <!--
  // IPerformanceCollector & friends
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IPerformanceMetric" extends="$unknown"
    uuid="2a1a60ae-9345-4019-ad53-d34ba41cbfe9" wsmap="managed"
    >
    <desc>
      The IPerformanceMetric interface represents parameters of the given
      performance metric.
    </desc>

    <attribute name="metricName" type="wstring" readonly="yes">
      <desc>
        Name of the metric.
      </desc>
    </attribute>

    <attribute name="object" type="$unknown" readonly="yes">
      <desc>
        Object this metric belongs to.
      </desc>
    </attribute>

    <attribute name="description" type="wstring" readonly="yes">
      <desc>
        Textual description of the metric.
      </desc>
    </attribute>

    <attribute name="period" type="unsigned long" readonly="yes">
      <desc>
        Time interval between samples, measured in seconds.
      </desc>
    </attribute>

    <attribute name="count" type="unsigned long" readonly="yes">
      <desc>
        Number of recent samples retained by the performance collector for this
        metric.

        When the collected sample count exceeds this number, older samples
        are discarded.
      </desc>
    </attribute>

    <attribute name="unit" type="wstring" readonly="yes">
      <desc>
        Unit of measurement.
      </desc>
    </attribute>

    <attribute name="minimumValue" type="long" readonly="yes">
      <desc>
        Minimum possible value of this metric.
      </desc>
    </attribute>

    <attribute name="maximumValue" type="long" readonly="yes">
      <desc>
        Maximum possible value of this metric.
      </desc>
    </attribute>
  </interface>

  <interface
    name="IPerformanceCollector" extends="$unknown"
    uuid="e22e1acb-ac4a-43bb-a31c-17321659b0c6"
    wsmap="managed"
    >
    <desc>
      The IPerformanceCollector interface represents a service that collects
      and stores performance metrics data.

      Performance metrics are associated with objects of interfaces like IHost
      and IMachine. Each object has a distinct set of performance metrics.  The
      set can be obtained with <link to="IPerformanceCollector::getMetrics"/>.

      Metric data is collected at the specified intervals and is retained
      internally. The interval and the number of retained samples can be set
      with <link to="IPerformanceCollector::setupMetrics" />. Both metric data
      and collection settings are not persistent, they are discarded as soon as
      VBoxSVC process terminates. Moreover, metric settings and data associated
      with a particular VM only exist while VM is running. They disappear as
      soon as VM shuts down. It is not possible to set up metrics for machines
      that are powered off. One needs to start VM first, then set up metric
      collection parameters.

      Metrics are organized hierarchically, with each level separated by a
      slash (/) character. Generally, the scheme for metric names is like this:

      <tt>Category/Metric[/SubMetric][:aggregation]</tt>

      "Category/Metric" together form the base metric name. A base metric is
      the smallest unit for which a sampling interval and the number of
      retained samples can be set. Only base metrics can be enabled and
      disabled. All sub-metrics are collected when their base metric is
      collected.  Collected values for any set of sub-metrics can be queried
      with <link to="IPerformanceCollector::queryMetricsData" />.

      For example "CPU/Load/User:avg" metric name stands for the "CPU"
      category, "Load" metric, "User" submetric, "average" aggregate. An
      aggregate function is computed over all retained data. Valid aggregate
      functions are:

      <ul>
          <li>avg -- average</li>
          <li>min -- minimum</li>
          <li>max -- maximum</li>
      </ul>

      When setting up metric parameters, querying metric data, enabling or
      disabling metrics wildcards can be used in metric names to specify a
      subset of metrics. For example, to select all CPU-related metrics
      use <tt>CPU/*</tt>, all averages can be queried using <tt>*:avg</tt> and
      so on. To query metric values without aggregates <tt>*:</tt> can be used.

      The valid names for base metrics are:

      <ul>
      <li>CPU/Load</li>
      <li>CPU/MHz</li>
      <li>RAM/Usage</li>
      <li>RAM/VMM</li>
      </ul>

      The general sequence for collecting and retrieving the metrics is:
      <ul>
        <li>
          Obtain an instance of IPerformanceCollector with
          <link to="IVirtualBox::performanceCollector" />
        </li>
        <li>
          Allocate and populate an array with references to objects the metrics
          will be collected for. Use references to IHost and IMachine objects.
        </li>
        <li>
          Allocate and populate an array with base metric names the data will
          be collected for.
        </li>
        <li>
          Call <link to="IPerformanceCollector::setupMetrics" />. From now on
          the metric data will be collected and stored.
        </li>
        <li>
          Wait for the data to get collected.
        </li>
        <li>
          Allocate and populate an array with references to objects the metric
          values will be queried for. You can re-use the object array used for
          setting base metrics.
        </li>
        <li>
          Allocate and populate an array with metric names the data will be
          collected for. Note that metric names differ from base metric names.
        </li>
        <li>
          Call <link to="IPerformanceCollector::queryMetricsData" />. The data
          that have been collected so far are returned. Note that the values
          are still retained internally and data collection continues.
        </li>
      </ul>

      For an example of usage refer to the following files in VirtualBox SDK:
      <ul>
        <li>
          Java: <tt>bindings/webservice/java/jax-ws/samples/metrictest.java</tt>
        </li>
        <li>
          Python: <tt>bindings/xpcom/python/sample/shellcommon.py</tt>
        </li>
      </ul>
    </desc>

    <attribute name="metricNames" type="wstring" readonly="yes" safearray="yes">
      <desc>
        Array of unique names of metrics.

        This array represents all metrics supported by the performance
        collector. Individual objects do not necessarily support all of them.
        <link to="IPerformanceCollector::getMetrics"/> can be used to get the
        list of supported metrics for a particular object.
      </desc>
    </attribute>

    <method name="getMetrics">
      <desc>
        Returns parameters of specified metrics for a set of objects.
        <note>
          @c Null metrics array means all metrics. @c Null object array means
          all existing objects.
        </note>
      </desc>
      <param name="metricNames" type="wstring" dir="in" safearray="yes">
        <desc>
          Metric name filter. Currently, only a comma-separated list of metrics
          is supported.
        </desc>
      </param>
      <param name="objects" type="$unknown" dir="in" safearray="yes">
        <desc>
          Set of objects to return metric parameters for.
        </desc>
      </param>
      <param name="metrics" type="IPerformanceMetric" dir="return" safearray="yes">
        <desc>
          Array of returned metric parameters.
        </desc>
      </param>
    </method>

    <method name="setupMetrics">
      <desc>
        Sets parameters of specified base metrics for a set of objects. Returns
        an array of <link to="IPerformanceMetric" /> describing the metrics
        have been affected.
        <note>
          @c Null or empty metric name array means all metrics. @c Null or
          empty object array means all existing objects. If metric name array
          contains a single element and object array contains many, the single
          metric name array element is applied to each object array element to
          form metric/object pairs.
        </note>
      </desc>
      <param name="metricNames" type="wstring" dir="in" safearray="yes">
        <desc>
          Metric name filter. Comma-separated list of metrics with wildcard
          support.
        </desc>
      </param>
      <param name="objects" type="$unknown" dir="in" safearray="yes">
        <desc>
          Set of objects to setup metric parameters for.
        </desc>
      </param>
      <param name="period" type="unsigned long" dir="in">
        <desc>
          Time interval in seconds between two consecutive samples of
          performance data.
        </desc>
      </param>
      <param name="count" type="unsigned long" dir="in">
        <desc>
          Number of samples to retain in performance data history. Older
          samples get discarded.
        </desc>
      </param>
      <param name="affectedMetrics" type="IPerformanceMetric" dir="return" safearray="yes">
        <desc>
          Array of metrics that have been modified by the call to this method.
        </desc>
      </param>
    </method>

    <method name="enableMetrics">
      <desc>
        Turns on collecting specified base metrics. Returns an array of
        <link to="IPerformanceMetric" /> describing the metrics have been
        affected.
        <note>
          @c Null or empty metric name array means all metrics. @c Null or
          empty object array means all existing objects. If metric name array
          contains a single element and object array contains many, the single
          metric name array element is applied to each object array element to
          form metric/object pairs.
        </note>
      </desc>
      <param name="metricNames" type="wstring" dir="in" safearray="yes">
        <desc>
          Metric name filter. Comma-separated list of metrics with wildcard
          support.
        </desc>
      </param>
      <param name="objects" type="$unknown" dir="in" safearray="yes">
        <desc>
          Set of objects to enable metrics for.
        </desc>
      </param>
      <param name="affectedMetrics" type="IPerformanceMetric" dir="return" safearray="yes">
        <desc>
          Array of metrics that have been modified by the call to this method.
        </desc>
      </param>
    </method>

    <method name="disableMetrics">
      <desc>
        Turns off collecting specified base metrics. Returns an array of
        <link to="IPerformanceMetric" /> describing the metrics have been
        affected.
        <note>
          @c Null or empty metric name array means all metrics. @c Null or
          empty object array means all existing objects. If metric name array
          contains a single element and object array contains many, the single
          metric name array element is applied to each object array element to
          form metric/object pairs.
        </note>
      </desc>
      <param name="metricNames" type="wstring" dir="in" safearray="yes">
        <desc>
          Metric name filter. Comma-separated list of metrics with wildcard
          support.
        </desc>
      </param>
      <param name="objects" type="$unknown" dir="in" safearray="yes">
        <desc>
          Set of objects to disable metrics for.
        </desc>
      </param>
      <param name="affectedMetrics" type="IPerformanceMetric" dir="return" safearray="yes">
        <desc>
          Array of metrics that have been modified by the call to this method.
        </desc>
      </param>
    </method>

    <method name="queryMetricsData">
      <desc>
        Queries collected metrics data for a set of objects.

        The data itself and related metric information are returned in seven
        parallel and one flattened array of arrays. Elements of
        <tt>returnMetricNames, returnObjects, returnUnits, returnScales,
        returnSequenceNumbers, returnDataIndices and returnDataLengths</tt> with
        the same index describe one set of values corresponding to a single
        metric.

        The <tt>returnData</tt> parameter is a flattened array of arrays. Each
        start and length of a sub-array is indicated by
        <tt>returnDataIndices</tt> and <tt>returnDataLengths</tt>. The first
        value for metric <tt>metricNames[i]</tt> is at
        <tt>returnData[returnIndices[i]]</tt>.

        <note>
          @c Null or empty metric name array means all metrics. @c Null or
          empty object array means all existing objects. If metric name array
          contains a single element and object array contains many, the single
          metric name array element is applied to each object array element to
          form metric/object pairs.
        </note>
        <note>
          Data collection continues behind the scenes after call to @c
          queryMetricsData. The return data can be seen as the snapshot of the
          current state at the time of @c queryMetricsData call. The internally
          kept metric values are not cleared by the call. This makes possible
          querying different subsets of metrics or aggregates with subsequent
          calls. If periodic querying is needed it is highly suggested to query
          the values with @c interval*count period to avoid confusion. This way
          a completely new set of data values will be provided by each query.
        </note>
      </desc>
      <param name="metricNames" type="wstring" dir="in" safearray="yes">
        <desc>
          Metric name filter. Comma-separated list of metrics with wildcard
          support.
        </desc>
      </param>
      <param name="objects" type="$unknown" dir="in" safearray="yes">
        <desc>
          Set of objects to query metrics for.
        </desc>
      </param>
      <param name="returnMetricNames" type="wstring" dir="out" safearray="yes">
        <desc>
          Names of metrics returned in @c returnData.
        </desc>
      </param>
      <param name="returnObjects" type="$unknown" dir="out" safearray="yes">
        <desc>
          Objects associated with metrics returned in @c returnData.
        </desc>
      </param>
      <param name="returnUnits" type="wstring" dir="out" safearray="yes">
        <desc>
          Units of measurement for each returned metric.
        </desc>
      </param>
      <param name="returnScales" type="unsigned long" dir="out" safearray="yes">
        <desc>
          Divisor that should be applied to return values in order to get
          floating point values. For example:
          <tt>(double)returnData[returnDataIndices[0]+i] / returnScales[0]</tt>
          will retrieve the floating point value of i-th sample of the first
          metric.
        </desc>
      </param>
      <param name="returnSequenceNumbers" type="unsigned long" dir="out" safearray="yes">
        <desc>
          Sequence numbers of the first elements of value sequences of
          particular metrics returned in @c returnData. For aggregate metrics
          it is the sequence number of the sample the aggregate started
          calculation from.
        </desc>
      </param>
      <param name="returnDataIndices" type="unsigned long" dir="out" safearray="yes">
        <desc>
          Indices of the first elements of value sequences of particular
          metrics returned in @c returnData.
        </desc>
      </param>
      <param name="returnDataLengths" type="unsigned long" dir="out" safearray="yes">
        <desc>
          Lengths of value sequences of particular metrics.
        </desc>
      </param>
      <param name="returnData" type="long" dir="return" safearray="yes">
        <desc>
          Flattened array of all metric data containing sequences of values for
          each metric.
        </desc>
      </param>
    </method>

  </interface>

  <enum
    name="NATAliasMode"
    uuid="67772168-50d9-11df-9669-7fb714ee4fa1"
    >
    <desc></desc>
    <const name="AliasLog" value="0x1">
      <desc></desc>
    </const>
    <const name="AliasProxyOnly" value="0x02">
      <desc></desc>
    </const>
    <const name="AliasUseSamePorts" value="0x04">
      <desc></desc>
    </const>
  </enum>

  <enum
    name="NATProtocol"
    uuid="e90164be-eb03-11de-94af-fff9b1c1b19f"
    >
    <desc>Protocol definitions used with NAT port-forwarding rules.</desc>
    <const name="UDP" value="0">
        <desc>Port-forwarding uses UDP protocol.</desc>
    </const>
    <const name="TCP" value="1">
        <desc>Port-forwarding uses TCP protocol.</desc>
    </const>
  </enum>

  <interface
    name="INATEngine" extends="$unknown"
    uuid="26451b99-3b2d-4dcb-8e4b-d63654218175"
    wsmap="managed"
    >
    <desc>Interface for managing a NAT engine which is used with a virtual machine. This
      allows for changing NAT behavior such as port-forwarding rules. This interface is
      used in the <link to="INetworkAdapter::NATEngine" /> attribute.</desc>
    <attribute name="network" type="wstring">
      <desc>The network attribute of the NAT engine (the same value is used with built-in
        DHCP server to fill corresponding fields of DHCP leases).</desc>
    </attribute>
    <attribute name="hostIP" type="wstring">
        <desc>IP of host interface to bind all opened sockets to.
          <note>Changing this does not change binding of port forwarding.</note>
      </desc>
    </attribute>
    <attribute name="TFTPPrefix" type="wstring">
      <desc>TFTP prefix attribute which is used with the built-in DHCP server to fill
        the corresponding fields of DHCP leases.</desc>
    </attribute>
    <attribute name="TFTPBootFile" type="wstring">
      <desc>TFTP boot file attribute which is used with the built-in DHCP server to fill
        the corresponding fields of DHCP leases.</desc>
    </attribute>
    <attribute name="TFTPNextServer" type="wstring">
      <desc>TFTP server attribute which is used with the built-in DHCP server to fill
        the corresponding fields of DHCP leases.
        <note>The preferred form is IPv4 addresses.</note>
      </desc>
    </attribute>
    <attribute name="aliasMode" type="unsigned long">
      <desc></desc>
    </attribute>
    <attribute name="DNSPassDomain" type="boolean">
      <desc>Whether the DHCP server should pass the DNS domain used by the host.</desc>
    </attribute>
    <attribute name="DNSProxy" type="boolean">
      <desc>Whether the DHCP server (and the DNS traffic by NAT) should pass the address
        of the DNS proxy and process traffic using DNS servers registered on the host.</desc>
    </attribute>
    <attribute name="DNSUseHostResolver" type="boolean">
      <desc>Whether the DHCP server (and the DNS traffic by NAT) should pass the address
        of the DNS proxy and process traffic using the host resolver mechanism.</desc>
    </attribute>
    <attribute name="redirects" type="wstring" readonly="yes" safearray="yes">
      <desc>Array of NAT port-forwarding rules in string representation, in the following
        format: "name,protocol id,host ip,host port,guest ip,guest port".</desc>
    </attribute>
    <method name="setNetworkSettings">
      <desc>Sets network configuration of the NAT engine.</desc>
      <param name="mtu" type="unsigned long" dir="in">
        <desc>MTU (maximum transmission unit) of the NAT engine in bytes.</desc>
      </param>
      <param name="sockSnd" type="unsigned long" dir="in">
        <desc>Capacity of the socket send buffer in bytes when creating a new socket.</desc>
      </param>
      <param name="sockRcv" type="unsigned long" dir="in">
        <desc>Capacity of the socket receive buffer in bytes when creating a new socket.</desc>
      </param>
      <param name="TcpWndSnd" type="unsigned long" dir="in">
        <desc>Initial size of the NAT engine's sending TCP window in bytes when
          establishing a new TCP connection.</desc>
      </param>
      <param name="TcpWndRcv" type="unsigned long" dir="in">
        <desc>Initial size of the NAT engine's receiving TCP window in bytes when
          establishing a new TCP connection.</desc>
      </param>
    </method>
    <method name="getNetworkSettings">
      <desc>Returns network configuration of NAT engine. See <link to="#setNetworkSettings" />
        for parameter descriptions.</desc>
      <param name="mtu" type="unsigned long" dir="out" />
      <param name="sockSnd" type="unsigned long" dir="out" />
      <param name="sockRcv" type="unsigned long" dir="out" />
      <param name="TcpWndSnd" type="unsigned long" dir="out" />
      <param name="TcpWndRcv" type="unsigned long" dir="out" />
    </method>
    <method name="addRedirect">
        <desc>Adds a new NAT port-forwarding rule.</desc>
        <param name="name" type="wstring" dir="in">
          <desc>The name of the rule. An empty name is acceptable, in which case the NAT engine
            auto-generates one using the other parameters.</desc>
        </param>
        <param name="proto" type="NATProtocol" dir="in">
          <desc>Protocol handled with the rule.</desc>
        </param>
        <param name="hostIP" type="wstring" dir="in">
          <desc>IP of the host interface to which the rule should apply. An empty ip address is
            acceptable, in which case the NAT engine binds the handling socket to any interface.</desc>
        </param>
        <param name="hostPort" type="unsigned short" dir="in">
          <desc>The port number to listen on.</desc>
        </param>
        <param name="guestIP" type="wstring" dir="in">
          <desc>The IP address of the guest which the NAT engine will forward matching packets
            to. An empty IP address is acceptable, in which case the NAT engine will forward
            packets to the first DHCP lease (x.x.x.15).</desc>
        </param>
        <param name="guestPort" type="unsigned short" dir="in">
          <desc>The port number to forward.</desc>
        </param>
    </method>
    <method name="removeRedirect">
      <desc>Removes a port-forwarding rule that was previously registered.</desc>
      <param name="name" type="wstring" dir="in">
        <desc>The name of the rule to delete.</desc>
      </param>
    </method>
  </interface>

  <!--
  // IExtPackManager
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IExtPackPlugIn" extends="$unknown"
    uuid="58000040-e718-4746-bbce-4b86d96da461"
    wsmap="suppress"
    >
    <desc>
      Interface for keeping information about a plug-in that ships with an
      extension pack.
    </desc>
    <attribute name="name" type="wstring" readonly="yes">
      <desc>The plug-in name.</desc>
    </attribute>
    <attribute name="description" type="wstring" readonly="yes">
      <desc>The plug-in description.</desc>
    </attribute>
    <attribute name="frontend" type="wstring" readonly="yes">
      <desc>
        The name of the frontend or component name this plug-in plugs into.
      </desc>
    </attribute>
    <attribute name="modulePath" type="wstring" readonly="yes">
      <desc> The module path. </desc>
    </attribute>
  </interface>

  <interface
    name="IExtPackBase" extends="$unknown"
    uuid="f79b75d8-2890-4f34-ffff-ffffa144e82c"
    wsmap="suppress"
    >
    <desc>
      Interface for querying information about an extension pack as well as
      accessing COM objects within it.
    </desc>
    <attribute name="name" type="wstring" readonly="yes">
      <desc>The extension pack name.  This is unique.</desc>
    </attribute>
    <attribute name="description" type="wstring" readonly="yes">
      <desc>The extension pack description.</desc>
    </attribute>
    <attribute name="version" type="wstring" readonly="yes">
      <desc>
        The extension pack version string.  This is restricted to the dotted
	version number and optionally a build indicator.  No tree revision or
        tag will be included in the string as those things are available as
        separate properties.  An optional publisher tag may be present like for
        <link to="IVirtualBox::version"/>.

        Examples: "1.2.3", "1.2.3_BETA1" and "1.2.3_RC2".
      </desc>
    </attribute>
    <attribute name="revision" type="unsigned long" readonly="yes">
      <desc>The extension pack internal revision number.</desc>
    </attribute>
    <attribute name="edition" type="wstring" readonly="yes">
      <desc>
	Edition indicator.  This is usually empty.

	Can for instance be used to help distinguishing between two editions
	of the same extension pack where only the license, service contract or
	something differs.
      </desc>
    </attribute>
    <attribute name="VRDEModule" type="wstring" readonly="yes">
      <desc>The name of the VRDE module if the extension pack sports one.</desc>
    </attribute>
    <attribute name="plugIns" type="IExtPackPlugIn" safearray="yes" readonly="yes">
      <desc>Plug-ins provided by this extension pack.</desc>
    </attribute>
    <attribute name="usable" type="boolean" readonly="yes">
      <desc>
        Indicates whether the extension pack is usable or not.

        There are a number of reasons why an extension pack might be unusable,
        typical examples would be broken installation/file or that it is
        incompatible with the current VirtualBox version.
      </desc>
    </attribute>
    <attribute name="whyUnusable" type="wstring" readonly="yes">
      <desc>
        String indicating why the extension pack is not usable.  This is an
        empty string if usable and always a non-empty string if not usable.
      </desc>
    </attribute>
    <attribute name="showLicense" type="boolean" readonly="yes">
      <desc>Whether to show the license before installation</desc>
    </attribute>
    <attribute name="license" type="wstring" readonly="yes">
      <desc>
        The default HTML license text for the extension pack.  Same as
        calling <link to="#queryLicense">queryLicense</link> with
        preferredLocale and preferredLanguage as empty strings and format set
        to html.
      </desc>
    </attribute>

    <method name="queryLicense">
      <desc>
        Full feature version of the license attribute.
      </desc>
      <param name="preferredLocale" type="wstring" dir="in">
        <desc>
          The preferred license locale. Pass an empty string to get the default
          license.
        </desc>
      </param>
      <param name="preferredLanguage" type="wstring" dir="in">
        <desc>
          The preferred license language. Pass an empty string to get the
          default language for the locale.
        </desc>
      </param>
      <param name="format" type="wstring" dir="in">
        <desc>
          The license format: html, rtf or txt. If a license is present there
          will always be an HTML of it, the rich text format (RTF) and plain
          text (txt) versions are optional. If
        </desc>
      </param>
      <param name="licenseText" type="wstring" dir="return">
        <desc>The license text.</desc>
      </param>
    </method>

  </interface>

  <interface
    name="IExtPack" extends="IExtPackBase"
    uuid="431685da-3618-4ebc-b038-833ba829b4b2"
    wsmap="suppress"
    >
    <desc>
      Interface for querying information about an extension pack as well as
      accessing COM objects within it.
    </desc>
    <method name="queryObject">
      <desc>
        Queries the IUnknown interface to an object in the extension pack
        main module.  This allows plug-ins and others to talk directly to an
        extension pack.
        </desc>
      <param name="objUuid" type="wstring" dir="in">
        <desc>The object ID.  What exactly this is </desc>
      </param>
      <param name="returnInterface" type="$unknown" dir="return">
        <desc>The queried interface.</desc>
      </param>
    </method>
  </interface>

  <interface
    name="IExtPackFile" extends="IExtPackBase"
    uuid="b6b49f55-efcc-4f08-b486-56e8d8afb10b"
    wsmap="suppress"
    >
    <desc>
      Extension pack file (aka tarball, .vbox-extpack) representation returned
      by <link to="IExtPackManager::openExtPackFile"/>.  This provides the base
      extension pack information with the addition of the file name.
    </desc>
    <attribute name="filePath" type="wstring" readonly="yes">
      <desc>
        The path to the extension pack file.
      </desc>
    </attribute>

    <method name="install">
      <desc>
        Install the extension pack.
      </desc>
      <param name="replace" type="boolean" dir="in">
        <desc>
          Set this to automatically uninstall any existing extension pack with
          the same name as the one being installed.
        </desc>
      </param>
      <param name="displayInfo" type="wstring" dir="in">
        <desc>
          Platform specific display information.  Reserved for future hacks.
        </desc>
      </param>
      <param name="progess" type="IProgress" dir="return">
        <desc>
          Progress object for the operation.
        </desc>
      </param>
    </method>
  </interface>

  <interface
    name="IExtPackManager" extends="$unknown"
    uuid="3295e6ce-b051-47b2-9514-2c588bfe7554"
    wsmap="suppress"
    >
    <desc>
      Interface for managing VirtualBox Extension Packs.

      TODO: Describe extension packs, how they are managed and how to create
            one.
    </desc>

    <attribute name="installedExtPacks" type="IExtPack" safearray="yes" readonly="yes">
      <desc>
        List of the installed extension packs.
      </desc>
    </attribute>

    <method name="find">
      <desc>
        Returns the extension pack with the specified name if found.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No extension pack matching @a name was found.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>The name of the extension pack to locate.</desc>
      </param>
      <param name="returnData" type="IExtPack" dir="return">
        <desc>The extension pack if found.</desc>
      </param>
    </method>

    <method name="openExtPackFile">
      <desc>
        Attempts to open an extension pack file in preparation for
        installation.
      </desc>
      <param name="path" type="wstring" dir="in">
        <desc>The path of the extension pack tarball.  This can optionally be
        followed by a "::SHA-256=hex-digit" of the tarball. </desc>
      </param>
      <param name="file" type="IExtPackFile" dir="return">
        <desc>The interface of the extension pack file object.</desc>
      </param>
    </method>

    <method name="uninstall">
      <desc>Uninstalls an extension pack, removing all related files.</desc>
      <param name="name" type="wstring" dir="in">
        <desc>The name of the extension pack to uninstall.</desc>
      </param>
      <param name="forcedRemoval" type="boolean" dir="in">
        <desc>
          Forced removal of the extension pack.  This means that the uninstall
          hook will not be called.
        </desc>
      </param>
      <param name="displayInfo" type="wstring" dir="in">
        <desc>
          Platform specific display information.  Reserved for future hacks.
        </desc>
      </param>
      <param name="progess" type="IProgress" dir="return">
        <desc>
          Progress object for the operation.
        </desc>
      </param>
    </method>

    <method name="cleanup">
      <desc>Cleans up failed installs and uninstalls</desc>
    </method>

    <method name="queryAllPlugInsForFrontend">
      <desc>
        Gets the path to all the plug-in modules for a given frontend.

        This is a convenience method that is intended to simplify the plug-in
        loading process for a frontend.
      </desc>
      <param name="frontendName" type="wstring" dir="in">
        <desc>The name of the frontend or component.</desc>
      </param>
      <param name="plugInModules" type="wstring" dir="return" safearray="yes">
        <desc>Array containing the plug-in modules (full paths).</desc>
      </param>
    </method>

    <method name="isExtPackUsable">
      <desc>Check if the given extension pack is loaded and usable.</desc>
      <param name="name" type="wstring" dir="in">
        <desc>The name of the extension pack to check for.</desc>
      </param>
      <param name="usable" type="boolean" dir="return">
        <desc>Is the given extension pack loaded and usable.</desc>
      </param>
    </method>

  </interface>

  <!--
  // BandwidthGroupType
  /////////////////////////////////////////////////////////////////////////
  -->
  <enum
     name="BandwidthGroupType"
     uuid="1d92b67d-dc69-4be9-ad4c-93a01e1e0c8e">

    <desc>
      Type of a bandwidth control group.
    </desc>

    <const name="Null" value="0">
      <desc>
        Null type, must be first.
      </desc>
    </const>

    <const name="Disk" value="1">
      <desc>
        The bandwidth group controls disk I/O.
      </desc>
    </const>

    <const name="Network" value="2">
      <desc>
        The bandwidth group controls network I/O.
      </desc>
    </const>

  </enum>

  <!--
  // IBandwidthGroup
  /////////////////////////////////////////////////////////////////////////
  -->
  <interface
    name="IBandwidthGroup" extends="$unknown"
    uuid="badea2d7-0261-4146-89f0-6a57cc34833d"
    wsmap="managed"
    >
    <desc>Represents one bandwidth group.</desc>

    <attribute name="name" type="wstring" readonly="yes">
      <desc>Name of the group.</desc>
    </attribute>

    <attribute name="type" type="BandwidthGroupType" readonly="yes">
      <desc>Type of the group.</desc>
    </attribute>

    <attribute name="reference" type="unsigned long" readonly="yes">
      <desc>How many devices/medium attachements use this group.</desc>
    </attribute>

    <attribute name="maxBytesPerSec" type="long long">
      <desc>The maximum number of bytes which can be transfered by all
        entities attached to this group during one second.</desc>
    </attribute>

  </interface>

  <!--
  // IBandwidthControl
  /////////////////////////////////////////////////////////////////////////
  -->
  <interface
    name="IBandwidthControl" extends="$unknown"
    uuid="e2eb3930-d2f4-4f87-be17-0707e30f019f"
    wsmap="managed"
    >
    <desc>
      Controls the bandwidth groups of one machine used to cap I/O done by a VM.
      This includes network and disk I/O.
    </desc>

    <attribute name="numGroups" type="unsigned long" readonly="yes">
      <desc>
        The current number of existing bandwidth groups managed.
      </desc>
    </attribute>

    <method name="createBandwidthGroup">
      <desc>
        Creates a new bandwidth group.
      </desc>

      <param name="name" type="wstring" dir="in">
        <desc>Name of the bandwidth group.</desc>
      </param>
      <param name="type" type="BandwidthGroupType" dir="in">
        <desc>The type of the bandwidth group (network or disk).</desc>
      </param>
      <param name="maxBytesPerSec" type="long long" dir="in">
        <desc>The maximum number of bytes which can be transfered by all
          entities attached to this group during one second.</desc>
      </param>
    </method>

    <method name="deleteBandwidthGroup">
      <desc>
        Deletes a new bandwidth group.
      </desc>

      <param name="name" type="wstring" dir="in">
        <desc>Name of the bandwidth group to delete.</desc>
      </param>
    </method>

    <method name="getBandwidthGroup" const="yes">
      <desc>
        Get a bandwidth group by name.
      </desc>

      <param name="name" type="wstring" dir="in">
        <desc>Name of the bandwidth group to get.</desc>
      </param>
      <param name="bandwidthGroup" type="IBandwidthGroup" dir="return">
        <desc>Where to store the bandwidth group on success.</desc>
      </param>
    </method>

    <method name="getAllBandwidthGroups" const="yes">
      <desc>
        Get all managed bandwidth groups.
      </desc>

      <param name="bandwidthGroups" type="IBandwidthGroup" dir="return" safearray="yes">
        <desc>The array of managed bandwidth groups.</desc>
      </param>
    </method>
  </interface>

  <!--
  // IVirtualBoxClient
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IVirtualBoxClient" extends="$unknown"
    uuid="5fe0bd48-1181-40d1-991f-3b02f269a823"
    wsmap="suppress"
    >
    <desc>
      Convenience interface for client applications. Treat this as a
      singleton, i.e. never create more than one instance of this interface.

      At the moment only available for clients of the local API (not usable
      via the webservice). Once the session logic is redesigned this might
      change.
    </desc>

    <attribute name="virtualBox" type="IVirtualBox" readonly="yes">
      <desc>
        Reference to the server-side API root object.
      </desc>
    </attribute>

    <attribute name="session" type="ISession" readonly="yes">
      <desc>
        Create a new session object and return the reference to it.
      </desc>
    </attribute>

    <attribute name="eventSource" type="IEventSource" readonly="yes">
      <desc>
        Event source for VirtualBoxClient events.
      </desc>
    </attribute>

  </interface>

  <!--
  // Events
  /////////////////////////////////////////////////////////////////////////
  -->
  <enum
    name="VBoxEventType"
    uuid="0d67e79e-b7b1-4919-aab3-b36866075515"
    >

    <desc>
      Type of an event.
      See <link to="IEvent" /> for an introduction to VirtualBox event handling.
    </desc>

    <const name="Invalid" value="0">
      <desc>
        Invalid event, must be first.
      </desc>
    </const>

    <const name="Any" value="1">
      <desc>
        Wildcard for all events.
        Events of this type are never delivered, and only used in
        <link to="IEventSource::registerListener"/> call to simplify registration.
      </desc>
    </const>

    <const name="Vetoable" value="2">
      <desc>
        Wildcard for all vetoable events. Events of this type are never delivered, and only
        used in <link to="IEventSource::registerListener"/> call to simplify registration.
      </desc>
    </const>

    <const name="MachineEvent" value="3">
      <desc>
        Wildcard for all machine events. Events of this type are never delivered, and only used in
        <link to="IEventSource::registerListener"/> call to simplify registration.
      </desc>
    </const>

    <const name="SnapshotEvent" value="4">
      <desc>
        Wildcard for all snapshot events. Events of this type are never delivered, and only used in
        <link to="IEventSource::registerListener"/> call to simplify registration.
      </desc>
    </const>

    <const name="InputEvent" value="5">
      <desc>
        Wildcard for all input device (keyboard, mouse) events.
        Events of this type are never delivered, and only used in
        <link to="IEventSource::registerListener"/> call to simplify registration.
      </desc>
    </const>

    <const name="LastWildcard" value="31">
      <desc>
        Last wildcard.
      </desc>
    </const>

    <const name="OnMachineStateChanged" value="32">
      <desc>
        See <link to="IMachineStateChangedEvent">IMachineStateChangedEvent</link>.
      </desc>
    </const>
    <const name="OnMachineDataChanged" value="33">
      <desc>
        See <link to="IMachineDataChangedEvent">IMachineDataChangedEvent</link>.
      </desc>
    </const>
    <const name="OnExtraDataChanged" value="34">
      <desc>
        See <link to="IExtraDataChangedEvent">IExtraDataChangedEvent</link>.
      </desc>
    </const>
    <const name="OnExtraDataCanChange" value="35">
      <desc>
        See <link to="IExtraDataCanChangeEvent">IExtraDataCanChangeEvent</link>.
      </desc>
    </const>
    <const name="OnMediumRegistered" value="36">
      <desc>
        See <link to="IMediumRegisteredEvent">IMediumRegisteredEvent</link>.
      </desc>
    </const>
    <const name="OnMachineRegistered" value="37">
      <desc>
        See <link to="IMachineRegisteredEvent">IMachineRegisteredEvent</link>.
      </desc>
    </const>
    <const name="OnSessionStateChanged" value="38">
      <desc>
        See <link to="ISessionStateChangedEvent">ISessionStateChangedEvent</link>.
      </desc>
    </const>
    <const name="OnSnapshotTaken" value="39">
      <desc>
        See <link to="ISnapshotTakenEvent">ISnapshotTakenEvent</link>.
      </desc>
    </const>
    <const name="OnSnapshotDeleted" value="40">
      <desc>
        See <link to="ISnapshotDeletedEvent">ISnapshotDeletedEvent</link>.
      </desc>
    </const>
    <const name="OnSnapshotChanged" value="41">
      <desc>
        See <link to="ISnapshotChangedEvent">ISnapshotChangedEvent</link>.
      </desc>
    </const>
    <const name="OnGuestPropertyChanged" value="42">
      <desc>
        See <link to="IGuestPropertyChangedEvent">IGuestPropertyChangedEvent</link>.
      </desc>
    </const>
    <!-- Console events -->
    <const name="OnMousePointerShapeChanged" value="43">
      <desc>
        See <link to="IMousePointerShapeChangedEvent">IMousePointerShapeChangedEvent</link>.
      </desc>
    </const>
    <const name="OnMouseCapabilityChanged" value="44">
      <desc>
        See <link to="IMouseCapabilityChangedEvent">IMouseCapabilityChangedEvent</link>.
      </desc>
    </const>
    <const name="OnKeyboardLedsChanged" value="45">
      <desc>
        See <link to="IKeyboardLedsChangedEvent">IKeyboardLedsChangedEvent</link>.
      </desc>
    </const>
    <const name="OnStateChanged" value="46">
      <desc>
        See <link to="IStateChangedEvent">IStateChangedEvent</link>.
      </desc>
    </const>
    <const name="OnAdditionsStateChanged" value="47">
      <desc>
        See <link to="IAdditionsStateChangedEvent">IAdditionsStateChangedEvent</link>.
      </desc>
    </const>
    <const name="OnNetworkAdapterChanged" value="48">
      <desc>
        See <link to="INetworkAdapterChangedEvent">INetworkAdapterChangedEvent</link>.
      </desc>
    </const>
    <const name="OnSerialPortChanged" value="49">
      <desc>
        See <link to="ISerialPortChangedEvent">ISerialPortChangedEvent</link>.
      </desc>
    </const>
    <const name="OnParallelPortChanged" value="50">
      <desc>
        See <link to="IParallelPortChangedEvent">IParallelPortChangedEvent</link>.
      </desc>
    </const>
    <const name="OnStorageControllerChanged" value="51">
      <desc>
        See <link to="IStorageControllerChangedEvent">IStorageControllerChangedEvent</link>.
      </desc>
    </const>
    <const name="OnMediumChanged" value="52">
      <desc>
        See <link to="IMediumChangedEvent">IMediumChangedEvent</link>.
      </desc>
    </const>
    <const name="OnVRDEServerChanged" value="53">
      <desc>
        See <link to="IVRDEServerChangedEvent">IVRDEServerChangedEvent</link>.
      </desc>
    </const>
    <const name="OnUSBControllerChanged" value="54">
      <desc>
        See <link to="IUSBControllerChangedEvent">IUSBControllerChangedEvent</link>.
      </desc>
    </const>
    <const name="OnUSBDeviceStateChanged" value="55">
      <desc>
        See <link to="IUSBDeviceStateChangedEvent">IUSBDeviceStateChangedEvent</link>.
      </desc>
    </const>
    <const name="OnSharedFolderChanged" value="56">
      <desc>
        See <link to="ISharedFolderChangedEvent">ISharedFolderChangedEvent</link>.
      </desc>
    </const>
    <const name="OnRuntimeError" value="57">
      <desc>
        See <link to="IRuntimeErrorEvent">IRuntimeErrorEvent</link>.
      </desc>
    </const>
    <const name="OnCanShowWindow" value="58">
      <desc>
        See <link to="ICanShowWindowEvent">ICanShowWindowEvent</link>.
      </desc>
    </const>
    <const name="OnShowWindow" value="59">
      <desc>
        See <link to="IShowWindowEvent">IShowWindowEvent</link>.
      </desc>
    </const>
    <const name="OnCPUChanged" value="60">
      <desc>
        See <link to="ICPUChangedEvent">ICPUChangedEvent</link>.
      </desc>
    </const>
    <const name="OnVRDEServerInfoChanged" value="61">
      <desc>
        See <link to="IVRDEServerInfoChangedEvent">IVRDEServerInfoChangedEvent</link>.
      </desc>
    </const>
    <const name="OnEventSourceChanged" value="62">
      <desc>
        See <link to="IEventSourceChangedEvent">IEventSourceChangedEvent</link>.
      </desc>
    </const>
    <const name="OnCPUExecutionCapChanged" value="63">
      <desc>
        See <link to="ICPUExecutionCapChangedEvent">ICPUExecutionCapChangedEvent</link>.
      </desc>
    </const>
    <const name="OnGuestKeyboard" value="64">
      <desc>
        See <link to="IGuestKeyboardEvent">IGuestKeyboardEvent</link>.
      </desc>
    </const>
    <const name="OnGuestMouse" value="65">
      <desc>
        See <link to="IGuestMouseEvent">IGuestMouseEvent</link>.
      </desc>
    </const>
    <const name="OnNATRedirect" value="66">
      <desc>
        See <link to="INATRedirectEvent">INATRedirectEvent</link>.
      </desc>
    </const>
    <const name="OnHostPCIDevicePlug" value="67">
      <desc>
        See <link to="IHostPCIDevicePlugEvent">IHostPCIDevicePlugEvent</link>.
      </desc>
    </const>
    <const name="OnVBoxSVCAvailabilityChanged" value="68">
      <desc>
        See <link to="IVBoxSVCAvailabilityChangedEvent">IVBoxSVCAvailablityChangedEvent</link>.
      </desc>
    </const>
    <const name="OnBandwidthGroupChanged" value="69">
      <desc>
        See <link to="IBandwidthGroupChangedEvent">IBandwidthGroupChangedEvent</link>.
      </desc>
    </const>
    <const name="OnGuestMonitorChanged" value="70">
      <desc>
        See <link to="IGuestMonitorChangedEvent">IGuestMonitorChangedEvent</link>.
      </desc>
    </const>
    <const name="OnStorageDeviceChanged" value="71">
      <desc>
        See <link to="IStorageDeviceChangedEvent">IStorageDeviceChangedEvent</link>.
      </desc>
    </const>
    <const name="OnClipboardModeChanged" value="72">
      <desc>
        See <link to="IClipboardModeChangedEvent">IClipboardModeChangedEvent</link>.
      </desc>
    </const>
    <const name="OnDragAndDropModeChanged" value="73">
      <desc>
        See <link to="IDragAndDropModeChangedEvent">IDragAndDropModeChangedEvent</link>.
      </desc>
    </const>

    <!-- Last event marker -->
    <const name="Last" value="74">
      <desc>
        Must be last event, used for iterations and structures relying on numerical event values.
      </desc>
    </const>

  </enum>

  <interface
    name="IEventSource" extends="$unknown"
    uuid="9b6e1aee-35f3-4f4d-b5bb-ed0ecefd8538"
    wsmap="managed"
    >
    <desc>
      Event source. Generally, any object which could generate events can be an event source,
      or aggregate one. To simplify using one-way protocols such as webservices running on top of HTTP(S),
      an event source can work with listeners in either active or passive mode. In active mode it is up to
      the IEventSource implementation to call <link to="IEventListener::handleEvent" />, in passive mode the
      event source keeps track of pending events for each listener and returns available events on demand.

      See <link to="IEvent" /> for an introduction to VirtualBox event handling.
    </desc>

    <method name="createListener">
      <desc>
        Creates a new listener object, useful for passive mode.
      </desc>
      <param name="listener" type="IEventListener" dir="return"/>
    </method>

    <method name="createAggregator">
      <desc>
        Creates an aggregator event source, collecting events from multiple sources.
        This way a single listener can listen for events coming from multiple sources,
        using a single blocking <link to="#getEvent"/> on the returned aggregator.
      </desc>
      <param name="subordinates" type="IEventSource" dir="in" safearray="yes">
        <desc>
          Subordinate event source this one aggregatres.
        </desc>
      </param>
      <param name="result" type="IEventSource" dir="return">
        <desc>
          Event source aggregating passed sources.
        </desc>
      </param>
    </method>

    <method name="registerListener">
      <desc>
        Register an event listener.

        <note>
          To avoid system overload, the VirtualBox server process checks if passive event
          listeners call <link to="IEventSource::getEvent"/> frequently enough. In the
          current implementation, if more than 500 pending events are detected for a passive
          event listener, it is forcefully unregistered by the system, and further
          <link to="#getEvent" /> calls will return @c VBOX_E_OBJECT_NOT_FOUND.
        </note>
      </desc>
      <param name="listener" type="IEventListener" dir="in">
        <desc>Listener to register.</desc>
      </param>
      <param name="interesting" type="VBoxEventType" dir="in" safearray="yes">
        <desc>
          Event types listener is interested in. One can use wildcards like -
          <link to="VBoxEventType_Any"/> to specify wildcards, matching more
          than one event.
        </desc>
      </param>
      <param name="active" type="boolean" dir="in">
        <desc>
          Which mode this listener is operating in.
          In active mode, <link to="IEventListener::handleEvent" /> is called directly.
          In passive mode, an internal event queue is created for this this IEventListener.
          For each event coming in, it is added to queues for all interested registered passive
          listeners. It is then up to the external code to call the listener's
          <link to="IEventListener::handleEvent" /> method. When done with an event, the
          external code must call <link to="#eventProcessed" />.
        </desc>
      </param>
    </method>

    <method name="unregisterListener">
      <desc>
        Unregister an event listener. If listener is passive, and some waitable events are still
        in queue they are marked as processed automatically.
      </desc>
      <param name="listener" type="IEventListener" dir="in">
        <desc>Listener to unregister.</desc>
      </param>
    </method>

    <method name="fireEvent">
      <desc>
        Fire an event for this source.
      </desc>
      <param name="event" type="IEvent" dir="in">
        <desc>Event to deliver.</desc>
      </param>
      <param name="timeout" type="long" dir="in">
        <desc>
          Maximum time to wait for event processing (if event is waitable), in ms;
          0 = no wait, -1 = indefinite wait.
        </desc>
      </param>
      <param name="result" type="boolean" dir="return">
        <desc>true if an event was delivered to all targets, or is non-waitable.</desc>
      </param>
    </method>

    <method name="getEvent">
      <desc>
        Get events from this peer's event queue (for passive mode). Calling this method
        regularly is required for passive event listeners to avoid system overload;
        see <link to="IEventSource::registerListener" /> for details.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Listener is not registered, or autounregistered.
        </result>
      </desc>
      <param name="listener" type="IEventListener" dir="in">
        <desc>Which listener to get data for.</desc>
      </param>
      <param name="timeout" type="long" dir="in">
        <desc>
          Maximum time to wait for events, in ms;
          0 = no wait, -1 = indefinite wait.
        </desc>
      </param>
      <param name="event" type="IEvent" dir="return">
        <desc>Event retrieved, or null if none available.</desc>
      </param>
    </method>

    <method name="eventProcessed">
      <desc>
        Must be called for waitable events after a particular listener finished its
        event processing. When all listeners of a particular event have called this
        method, the system will then call <link to="IEvent::setProcessed" />.
      </desc>
      <param name="listener" type="IEventListener" dir="in">
        <desc>Which listener processed event.</desc>
      </param>
      <param name="event" type="IEvent" dir="in">
        <desc>Which event.</desc>
      </param>
    </method>

  </interface>

  <interface
    name="IEventListener" extends="$unknown"
    uuid="67099191-32e7-4f6c-85ee-422304c71b90"
    wsmap="managed"
    >
    <desc>
      Event listener. An event listener can work in either active or passive mode, depending on the way
      it was registered.
      See <link to="IEvent" /> for an introduction to VirtualBox event handling.
    </desc>

    <method name="handleEvent">
      <desc>
        Handle event callback for active listeners. It is not called for
        passive listeners. After calling <link to="#handleEvent"/> on all active listeners
        and having received acknowledgement from all passive listeners via
        <link to="IEventSource::eventProcessed"/>, the event is marked as
        processed and <link to="IEvent::waitProcessed"/> will return
        immediately.
      </desc>
      <param name="event" type="IEvent" dir="in">
        <desc>Event available.</desc>
      </param>
    </method>

  </interface>

  <interface
    name="IEvent" extends="$unknown"
    uuid="0ca2adba-8f30-401b-a8cd-fe31dbe839c0"
    wsmap="managed"
    >
    <desc>
      Abstract parent interface for VirtualBox events. Actual events will typically implement
      a more specific interface which derives from this (see below).

      <b>Introduction to VirtualBox events</b>

      Generally speaking, an event (represented by this interface) signals that something
      happened, while an event listener (see <link to="IEventListener" />) represents an
      entity that is interested in certain events. In order for this to work with
      unidirectional protocols (i.e. web services), the concepts of passive and active
      listener are used.

      Event consumers can register themselves as listeners, providing an array of
      events they are interested in (see <link to="IEventSource::registerListener" />).
      When an event triggers, the listener is notified about the event. The exact
      mechanism of the notification depends on whether the listener was registered as
      an active or passive listener:

      <ul>
        <li>An active listener is very similar to a callback: it is a function invoked
          by the API. As opposed to the callbacks that were used in the API before
          VirtualBox 4.0 however, events are now objects with an interface hierarchy.
        </li>

        <li>Passive listeners are somewhat trickier to implement, but do not require
          a client function to be callable, which is not an option with scripting
          languages or web service clients. Internally the <link to="IEventSource" />
          implementation maintains an event queue for each passive listener, and
          newly arrived events are put in this queue. When the listener calls
          <link to="IEventSource::getEvent"/>, first element from its internal event
          queue is returned. When the client completes processing of an event,
          the <link to="IEventSource::eventProcessed" /> function must be called,
          acknowledging that the event was processed. It supports implementing
          waitable events. On passive listener unregistration, all events from its
          queue are auto-acknowledged.
        </li>
      </ul>

      Waitable events are useful in situations where the event generator wants to track
      delivery or a party wants to wait until all listeners have completed the event. A
      typical example would be a vetoable event (see <link to="IVetoEvent" />) where a
      listeners might veto a certain action, and thus the event producer has to make
      sure that all listeners have processed the event and not vetoed before taking
      the action.

      A given event may have both passive and active listeners at the same time.

      <b>Using events</b>

      Any VirtualBox object capable of producing externally visible events provides an
      @c eventSource read-only attribute, which is of the type <link to="IEventSource" />.
      This event source object is notified by VirtualBox once something has happened, so
      consumers may register event listeners with this event source. To register a listener,
      an object implementing the <link to="IEventListener" /> interface must be provided.
      For active listeners, such an object is typically created by the consumer, while for
      passive listeners <link to="IEventSource::createListener" /> should  be used. Please
      note that a listener created with <link to="IEventSource::createListener"/> must not be used as an active listener.

      Once created, the listener must be registered to listen for the desired events
      (see <link to="IEventSource::registerListener" />), providing an array of
      <link to="VBoxEventType" /> enums. Those elements can either be the individual
      event IDs or wildcards matching multiple event IDs.

      After registration, the callback's <link to="IEventListener::handleEvent" /> method is
      called automatically when the event is triggered, while passive listeners have to call
      <link to="IEventSource::getEvent" /> and <link to="IEventSource::eventProcessed" /> in
      an event processing loop.

      The IEvent interface is an abstract parent interface for all such VirtualBox events
      coming in. As a result, the standard use pattern inside <link to="IEventListener::handleEvent" />
      or the event processing loop is to check the <link to="#type" /> attribute of the event and
      then cast to the appropriate specific interface using @c QueryInterface().
    </desc>

    <attribute name="type" readonly="yes" type="VBoxEventType">
      <desc>
        Event type.
      </desc>
    </attribute>

    <attribute name="source" readonly="yes" type="IEventSource">
      <desc>
        Source of this event.
      </desc>
    </attribute>

    <attribute name="waitable" readonly="yes" type="boolean">
      <desc>
        If we can wait for this event being processed. If false, <link to="#waitProcessed"/> returns immediately,
        and <link to="#setProcessed"/> doesn't make sense. Non-waitable events are generally better performing,
        as no additional overhead associated with waitability imposed.
        Waitable events are needed when one need to be able to wait for particular event processed,
        for example for vetoable changes, or if event refers to some resource which need to be kept immutable
        until all consumers confirmed events.
      </desc>
    </attribute>

    <method name="setProcessed">
      <desc>
        Internal method called by the system when all listeners of a particular event have called
        <link to="IEventSource::eventProcessed" />. This should not be called by client code.
      </desc>
    </method>

    <method name="waitProcessed">
      <desc>
        Wait until time outs, or this event is processed. Event must be waitable for this operation to have
        described semantics, for non-waitable returns true immediately.
      </desc>
      <param name="timeout" type="long" dir="in">
        <desc>
          Maximum time to wait for event processeing, in ms;
          0 = no wait, -1 = indefinite wait.
        </desc>
      </param>
      <param name="result" type="boolean" dir="return">
        <desc>If this event was processed before timeout.</desc>
      </param>
    </method>
  </interface>


  <interface
    name="IReusableEvent" extends="IEvent"
    uuid="69bfb134-80f6-4266-8e20-16371f68fa25"
    wsmap="managed"
    >
    <desc>Base abstract interface for all reusable events.</desc>

    <attribute name="generation" readonly="yes" type="unsigned long">
      <desc>Current generation of event, incremented on reuse.</desc>
    </attribute>

    <method name="reuse">
      <desc>
        Marks an event as reused, increments 'generation', fields shall no
        longer be considered valid.
      </desc>
    </method>
  </interface>

  <interface
    name="IMachineEvent" extends="IEvent"
    uuid="92ed7b1a-0d96-40ed-ae46-a564d484325e"
    wsmap="managed" id="MachineEvent"
    >
    <desc>Base abstract interface for all machine events.</desc>

    <attribute name="machineId" readonly="yes" type="uuid" mod="string">
      <desc>ID of the machine this event relates to.</desc>
    </attribute>

  </interface>

  <interface
    name="IMachineStateChangedEvent" extends="IMachineEvent"
    uuid="5748F794-48DF-438D-85EB-98FFD70D18C9"
    wsmap="managed" autogen="VBoxEvent" id="OnMachineStateChanged"
    >
    <desc>Machine state change event.</desc>

    <attribute name="state" readonly="yes" type="MachineState">
      <desc>New execution state.</desc>
    </attribute>
  </interface>

  <interface
    name="IMachineDataChangedEvent" extends="IMachineEvent"
    uuid="abe94809-2e88-4436-83d7-50f3e64d0503"
    wsmap="managed" autogen="VBoxEvent" id="OnMachineDataChanged"
    >
    <desc>
      Any of the settings of the given machine has changed.
    </desc>

    <attribute name="temporary" readonly="yes" type="boolean">
      <desc>@c true if the settings change is temporary. All permanent
        settings changes will trigger an event, and only temporary settings
        changes for running VMs will trigger an event. Note: sending events
        for temporary changes is NOT IMPLEMENTED.</desc>
    </attribute>
  </interface>

  <interface
    name="IMediumRegisteredEvent" extends="IEvent"
    uuid="53fac49a-b7f1-4a5a-a4ef-a11dd9c2a458"
    wsmap="managed" autogen="VBoxEvent" id="OnMediumRegistered"
    >
    <desc>
      The given medium was registered or unregistered
      within this VirtualBox installation.
    </desc>

    <attribute name="mediumId" readonly="yes" type="uuid" mod="string">
      <desc>ID of the medium this event relates to.</desc>
    </attribute>

    <attribute name="mediumType" readonly="yes" type="DeviceType">
      <desc>Type of the medium this event relates to.</desc>
    </attribute>

    <attribute name="registered" type="boolean" readonly="yes">
      <desc>
        If @c true, the medium was registered, otherwise it was
        unregistered.
      </desc>
    </attribute>
  </interface>

  <interface
    name="IMachineRegisteredEvent" extends="IMachineEvent"
    uuid="c354a762-3ff2-4f2e-8f09-07382ee25088"
    wsmap="managed" autogen="VBoxEvent" id="OnMachineRegistered"
    >
    <desc>
      The given machine was registered or unregistered
      within this VirtualBox installation.
    </desc>

    <attribute name="registered" type="boolean" readonly="yes">
      <desc>
        If @c true, the machine was registered, otherwise it was
        unregistered.
      </desc>
    </attribute>
  </interface>

  <interface
    name="ISessionStateChangedEvent" extends="IMachineEvent"
    uuid="714a3eef-799a-4489-86cd-fe8e45b2ff8e"
    wsmap="managed" autogen="VBoxEvent" id="OnSessionStateChanged"
    >
    <desc>
      The state of the session for the given machine was changed.
      <see><link to="IMachine::sessionState"/></see>
    </desc>

    <attribute name="state" type="SessionState" readonly="yes">
      <desc>
        New session state.
      </desc>
    </attribute>
  </interface>

  <interface
    name="IGuestPropertyChangedEvent" extends="IMachineEvent"
    uuid="3f63597a-26f1-4edb-8dd2-6bddd0912368"
    wsmap="managed" autogen="VBoxEvent" id="OnGuestPropertyChanged"
    >
    <desc>
      Notification when a guest property has changed.
    </desc>

    <attribute name="name" readonly="yes" type="wstring">
      <desc>
        The name of the property that has changed.
      </desc>
    </attribute>

    <attribute name="value" readonly="yes" type="wstring">
      <desc>
        The new property value.
      </desc>
    </attribute>

    <attribute name="flags" readonly="yes" type="wstring">
      <desc>
        The new property flags.
      </desc>
    </attribute>

  </interface>

  <interface
    name="ISnapshotEvent" extends="IMachineEvent"
    uuid="21637b0e-34b8-42d3-acfb-7e96daf77c22"
    wsmap="managed" id="SnapshotEvent"
    >
    <desc>Base interface for all snapshot events.</desc>

    <attribute name="snapshotId" readonly="yes" type="uuid" mod="string">
      <desc>ID of the snapshot this event relates to.</desc>
    </attribute>

  </interface>

  <interface
    name="ISnapshotTakenEvent" extends="ISnapshotEvent"
    uuid="d27c0b3d-6038-422c-b45e-6d4a0503d9f1"
    wsmap="managed" autogen="VBoxEvent" id="OnSnapshotTaken"
    >
    <desc>
      A new snapshot of the machine has been taken.
      <see><link to="ISnapshot"/></see>
    </desc>
  </interface>

  <interface
    name="ISnapshotDeletedEvent" extends="ISnapshotEvent"
    uuid="c48f3401-4a9e-43f4-b7a7-54bd285e22f4"
    wsmap="managed" autogen="VBoxEvent" id="OnSnapshotDeleted"
    >
    <desc>
      Snapshot of the given machine has been deleted.

      <note>
        This notification is delivered <b>after</b> the snapshot
        object has been uninitialized on the server (so that any
        attempt to call its methods will return an error).
      </note>

      <see><link to="ISnapshot"/></see>
    </desc>
  </interface>

  <interface
    name="ISnapshotChangedEvent" extends="ISnapshotEvent"
    uuid="07541941-8079-447a-a33e-47a69c7980db"
    wsmap="managed" autogen="VBoxEvent" id="OnSnapshotChanged"
    >
    <desc>
      Snapshot properties (name and/or description) have been changed.
      <see><link to="ISnapshot"/></see>
    </desc>
  </interface>

  <interface
    name="IMousePointerShapeChangedEvent" extends="IEvent"
    uuid="a6dcf6e8-416b-4181-8c4a-45ec95177aef"
    wsmap="managed" autogen="VBoxEvent" id="OnMousePointerShapeChanged"
    >
    <desc>
      Notification when the guest mouse pointer shape has
      changed. The new shape data is given.
    </desc>

    <attribute name="visible" type="boolean" readonly="yes">
      <desc>
        Flag whether the pointer is visible.
      </desc>
    </attribute>
    <attribute name="alpha" type="boolean" readonly="yes">
      <desc>
        Flag whether the pointer has an alpha channel.
      </desc>
    </attribute>
    <attribute name="xhot" type="unsigned long" readonly="yes">
      <desc>
        The pointer hot spot X coordinate.
      </desc>
    </attribute>
    <attribute name="yhot" type="unsigned long" readonly="yes">
      <desc>
        The pointer hot spot Y coordinate.
      </desc>
    </attribute>
    <attribute name="width" type="unsigned long" readonly="yes">
      <desc>
        Width of the pointer shape in pixels.
      </desc>
    </attribute>
    <attribute name="height" type="unsigned long" readonly="yes">
      <desc>
        Height of the pointer shape in pixels.
      </desc>
    </attribute>
    <attribute name="shape" type="octet" safearray="yes" readonly="yes">
      <desc>
        Shape buffer arrays.

        The @a shape buffer contains a 1-bpp (bits per pixel) AND mask
        followed by a 32-bpp XOR (color) mask.

        For pointers without alpha channel the XOR mask pixels are 32
        bit values: (lsb)BGR0(msb). For pointers with alpha channel
        the XOR mask consists of (lsb)BGRA(msb) 32 bit values.

        An AND mask is used for pointers with alpha channel, so if the
        callback does not support alpha, the pointer could be
        displayed as a normal color pointer.

        The AND mask is a 1-bpp bitmap with byte aligned scanlines. The
        size of the AND mask therefore is <tt>cbAnd = (width + 7) / 8 *
          height</tt>. The padding bits at the end of each scanline are
        undefined.

        The XOR mask follows the AND mask on the next 4-byte aligned
        offset: <tt>uint8_t *pXor = pAnd + (cbAnd + 3) &amp; ~3</tt>.
        Bytes in the gap between the AND and the XOR mask are undefined.
        The XOR mask scanlines have no gap between them and the size of
        the XOR mask is: <tt>cXor = width * 4 * height</tt>.

        <note>
          If @a shape is 0, only the pointer visibility is changed.
        </note>
      </desc>
    </attribute>
  </interface>

  <interface
    name="IMouseCapabilityChangedEvent" extends="IEvent"
    uuid="d633ad48-820c-4207-b46c-6bd3596640d5"
    wsmap="managed" autogen="VBoxEvent" id="OnMouseCapabilityChanged"
    >
    <desc>
      Notification when the mouse capabilities reported by the
      guest have changed. The new capabilities are passed.
    </desc>
    <attribute name="supportsAbsolute" type="boolean" readonly="yes">
      <desc>
        Supports absolute coordinates.
      </desc>
    </attribute>
    <attribute name="supportsRelative" type="boolean" readonly="yes">
      <desc>
        Supports relative coordinates.
      </desc>
    </attribute>
    <attribute name="needsHostCursor" type="boolean" readonly="yes">
      <desc>
        If host cursor is needed.
      </desc>
    </attribute>
  </interface>

  <interface
    name="IKeyboardLedsChangedEvent" extends="IEvent"
    uuid="6DDEF35E-4737-457B-99FC-BC52C851A44F"
    wsmap="managed" autogen="VBoxEvent" id="OnKeyboardLedsChanged"
    >
    <desc>
      Notification when the guest OS executes the KBD_CMD_SET_LEDS command
      to alter the state of the keyboard LEDs.
    </desc>
    <attribute name="numLock" type="boolean" readonly="yes">
      <desc>
        NumLock status.
      </desc>
    </attribute>
    <attribute name="capsLock" type="boolean" readonly="yes">
      <desc>
        CapsLock status.
      </desc>
    </attribute>
    <attribute name="scrollLock" type="boolean" readonly="yes">
      <desc>
        ScrollLock status.
      </desc>
    </attribute>
  </interface>

  <interface
    name="IStateChangedEvent" extends="IEvent"
    uuid="4376693C-CF37-453B-9289-3B0F521CAF27"
    wsmap="managed" autogen="VBoxEvent" id="OnStateChanged"
    >
    <desc>
      Notification when the execution state of the machine has changed.
      The new state is given.
    </desc>
    <attribute name="state" type="MachineState" readonly="yes">
      <desc>
        New machine state.
      </desc>
    </attribute>
  </interface>

  <interface
    name="IAdditionsStateChangedEvent" extends="IEvent"
    uuid="D70F7915-DA7C-44C8-A7AC-9F173490446A"
    wsmap="managed" autogen="VBoxEvent" id="OnAdditionsStateChanged"
    >
    <desc>
      Notification when a Guest Additions property changes.
      Interested callees should query IGuest attributes to
      find out what has changed.
    </desc>
  </interface>

  <interface
    name="INetworkAdapterChangedEvent" extends="IEvent"
    uuid="08889892-1EC6-4883-801D-77F56CFD0103"
    wsmap="managed" autogen="VBoxEvent" id="OnNetworkAdapterChanged"
    >
    <desc>
      Notification when a property of one of the
      virtual <link to="IMachine::getNetworkAdapter">network adapters</link>
      changes.  Interested callees should use INetworkAdapter methods and
      attributes to find out what has changed.
    </desc>
    <attribute name="networkAdapter" type="INetworkAdapter" readonly="yes">
      <desc>
        Network adapter that is subject to change.
      </desc>
    </attribute>
  </interface>

  <interface
    name="ISerialPortChangedEvent" extends="IEvent"
    uuid="3BA329DC-659C-488B-835C-4ECA7AE71C6C"
    wsmap="managed" autogen="VBoxEvent" id="OnSerialPortChanged"
    >
    <desc>
      Notification when a property of one of the
      virtual <link to="IMachine::getSerialPort">serial ports</link> changes.
      Interested callees should use ISerialPort methods and attributes
      to find out what has changed.
    </desc>
    <attribute name="serialPort" type="ISerialPort" readonly="yes">
      <desc>
        Serial port that is subject to change.
      </desc>
    </attribute>
  </interface>

  <interface
    name="IParallelPortChangedEvent" extends="IEvent"
    uuid="813C99FC-9849-4F47-813E-24A75DC85615"
    wsmap="managed" autogen="VBoxEvent" id="OnParallelPortChanged"
    >
    <desc>
      Notification when a property of one of the
      virtual <link to="IMachine::getParallelPort">parallel ports</link>
      changes.  Interested callees should use ISerialPort methods and
      attributes to find out what has changed.
    </desc>
    <attribute name="parallelPort" type="IParallelPort" readonly="yes">
      <desc>
        Parallel port that is subject to change.
      </desc>
    </attribute>
  </interface>

  <interface
    name="IStorageControllerChangedEvent" extends="IEvent"
    uuid="715212BF-DA59-426E-8230-3831FAA52C56"
    wsmap="managed" autogen="VBoxEvent" id="OnStorageControllerChanged"
    >
    <desc>
      Notification when a
      <link to="IMachine::mediumAttachments">medium attachment</link>
      changes.
    </desc>
  </interface>

  <interface
    name="IMediumChangedEvent" extends="IEvent"
    uuid="0FE2DA40-5637-472A-9736-72019EABD7DE"
    wsmap="managed" autogen="VBoxEvent" id="OnMediumChanged"
    >
    <desc>
      Notification when a
      <link to="IMachine::mediumAttachments">medium attachment</link>
      changes.
    </desc>
    <attribute name="mediumAttachment" type="IMediumAttachment" readonly="yes">
      <desc>
        Medium attachment that is subject to change.
      </desc>
    </attribute>
  </interface>

  <interface
    name="IClipboardModeChangedEvent" extends="IEvent"
    uuid="cac21692-7997-4595-a731-3a509db604e5"
    wsmap="managed" autogen="VBoxEvent" id="OnClipboardModeChanged"
    >
    <desc>
      Notification when the shared clipboard mode changes.
    </desc>
    <attribute name="clipboardMode" type="ClipboardMode" readonly="yes">
      <desc>
        The new clipboard mode.
      </desc>
    </attribute>
  </interface>

  <interface
    name="IDragAndDropModeChangedEvent" extends="IEvent"
    uuid="e90b8850-ac8e-4dff-8059-4100ae2c3c3d"
    wsmap="managed" autogen="VBoxEvent" id="OnDragAndDropModeChanged"
    >
    <desc>
      Notification when the drag'n'drop mode changes.
    </desc>
    <attribute name="dragAndDropMode" type="DragAndDropMode" readonly="yes">
      <desc>
        The new drag'n'drop mode.
      </desc>
    </attribute>
  </interface>

  <interface
    name="ICPUChangedEvent" extends="IEvent"
    uuid="4da2dec7-71b2-4817-9a64-4ed12c17388e"
    wsmap="managed" autogen="VBoxEvent" id="OnCPUChanged"
    >
    <desc>
      Notification when a CPU changes.
    </desc>
    <attribute name="CPU" type="unsigned long" readonly="yes">
      <desc>
        The CPU which changed.
      </desc>
    </attribute>
    <attribute name="add" type="boolean" readonly="yes">
      <desc>
        Flag whether the CPU was added or removed.
      </desc>
    </attribute>
  </interface>

  <interface
    name="ICPUExecutionCapChangedEvent" extends="IEvent"
    uuid="dfa7e4f5-b4a4-44ce-85a8-127ac5eb59dc"
    wsmap="managed" autogen="VBoxEvent" id="OnCPUExecutionCapChanged"
    >
    <desc>
      Notification when the CPU execution cap changes.
    </desc>
    <attribute name="executionCap" type="unsigned long" readonly="yes">
      <desc>
        The new CPU execution cap value. (1-100)
      </desc>
    </attribute>
  </interface>

  <interface
    name="IGuestKeyboardEvent" extends="IEvent"
    uuid="88394258-7006-40d4-b339-472ee3801844"
    wsmap="managed" autogen="VBoxEvent" id="OnGuestKeyboard"
    >
    <desc>
      Notification when guest keyboard event happens.
    </desc>
    <attribute name="scancodes"  type="long" safearray="yes" readonly="yes">
      <desc>
        Array of scancodes.
      </desc>
    </attribute>
  </interface>

  <interface
    name="IGuestMouseEvent" extends="IReusableEvent"
    uuid="1f85d35c-c524-40ff-8e98-307000df0992"
    wsmap="managed" autogen="VBoxEvent" id="OnGuestMouse"
    >
    <desc>
      Notification when guest mouse event happens.
    </desc>

    <attribute name="absolute" type="boolean" readonly="yes">
      <desc>
        If this event is relative or absolute.
      </desc>
    </attribute>

    <attribute name="x" type="long" readonly="yes">
      <desc>
        New X position, or X delta.
      </desc>
    </attribute>

    <attribute name="y" type="long" readonly="yes">
      <desc>
        New Y position, or Y delta.
      </desc>
    </attribute>

    <attribute name="z" type="long" readonly="yes">
      <desc>
        Z delta.
      </desc>
    </attribute>

    <attribute name="w" type="long" readonly="yes">
      <desc>
        W delta.
      </desc>
    </attribute>

    <attribute name="buttons" type="long" readonly="yes">
      <desc>
        Button state bitmask.
      </desc>
    </attribute>

  </interface>


  <interface
    name="IVRDEServerChangedEvent" extends="IEvent"
    uuid="a06fd66a-3188-4c8c-8756-1395e8cb691c"
    wsmap="managed" autogen="VBoxEvent" id="OnVRDEServerChanged"
    >
    <desc>
      Notification when a property of the
      <link to="IMachine::VRDEServer">VRDE server</link> changes.
      Interested callees should use IVRDEServer methods and attributes to
      find out what has changed.
    </desc>
  </interface>

  <interface
    name="IVRDEServerInfoChangedEvent" extends="IEvent"
    uuid="dd6a1080-e1b7-4339-a549-f0878115596e"
    wsmap="managed" autogen="VBoxEvent" id="OnVRDEServerInfoChanged"
    >
    <desc>
      Notification when the status of the VRDE server changes. Interested callees
      should use <link to="IConsole::VRDEServerInfo">IVRDEServerInfo</link>
      attributes to find out what is the current status.
    </desc>
  </interface>

  <interface
    name="IUSBControllerChangedEvent" extends="IEvent"
    uuid="93BADC0C-61D9-4940-A084-E6BB29AF3D83"
    wsmap="managed" autogen="VBoxEvent" id="OnUSBControllerChanged"
    >
    <desc>
      Notification when a property of the virtual
      <link to="IMachine::USBController">USB controller</link> changes.
      Interested callees should use IUSBController methods and attributes to
      find out what has changed.
    </desc>
  </interface>

  <interface
    name="IUSBDeviceStateChangedEvent" extends="IEvent"
    uuid="806da61b-6679-422a-b629-51b06b0c6d93"
    wsmap="managed" autogen="VBoxEvent" id="OnUSBDeviceStateChanged"
    >
    <desc>
      Notification when a USB device is attached to or detached from
      the virtual USB controller.

      This notification is sent as a result of the indirect
      request to attach the device because it matches one of the
      machine USB filters, or as a result of the direct request
      issued by <link to="IConsole::attachUSBDevice"/> or
      <link to="IConsole::detachUSBDevice"/>.

      This notification is sent in case of both a succeeded and a
      failed request completion. When the request succeeds, the
      @a error parameter is @c null, and the given device has been
      already added to (when @a attached is @c true) or removed from
      (when @a attached is @c false) the collection represented by
      <link to="IConsole::USBDevices"/>. On failure, the collection
      doesn't change and the @a error parameter represents the error
      message describing the failure.
    </desc>
    <attribute name="device" type="IUSBDevice" readonly="yes">
      <desc>
        Device that is subject to state change.
      </desc>
    </attribute>
    <attribute name="attached" type="boolean" readonly="yes">
      <desc>
        @c true if the device was attached and @c false otherwise.
      </desc>
    </attribute>
    <attribute name="error" type="IVirtualBoxErrorInfo" readonly="yes">
      <desc>
        @c null on success or an error message object on failure.
      </desc>
    </attribute>
  </interface>

  <interface
    name="ISharedFolderChangedEvent" extends="IEvent"
    uuid="B66349B5-3534-4239-B2DE-8E1535D94C0B"
    wsmap="managed" autogen="VBoxEvent" id="OnSharedFolderChanged"
    >
    <desc>
      Notification when a shared folder is added or removed.
      The @a scope argument defines one of three scopes:
      <link to="IVirtualBox::sharedFolders">global shared folders</link>
      (<link to="Scope_Global">Global</link>),
      <link to="IMachine::sharedFolders">permanent shared folders</link> of
      the machine (<link to="Scope_Machine">Machine</link>) or <link
      to="IConsole::sharedFolders">transient shared folders</link> of the
      machine (<link to="Scope_Session">Session</link>). Interested callees
      should use query the corresponding collections to find out what has
      changed.
    </desc>
    <attribute name="scope" type="Scope" readonly="yes">
      <desc>
        Scope of the notification.
      </desc>
    </attribute>
  </interface>

  <interface
    name="IRuntimeErrorEvent" extends="IEvent"
    uuid="883DD18B-0721-4CDE-867C-1A82ABAF914C"
    wsmap="managed" autogen="VBoxEvent" id="OnRuntimeError"
    >
    <desc>
      Notification when an error happens during the virtual
      machine execution.

      There are three kinds of runtime errors:
      <ul>
        <li><i>fatal</i></li>
        <li><i>non-fatal with retry</i></li>
        <li><i>non-fatal warnings</i></li>
      </ul>

      <b>Fatal</b> errors are indicated by the @a fatal parameter set
      to @c true. In case of fatal errors, the virtual machine
      execution is always paused before calling this notification, and
      the notification handler is supposed either to immediately save
      the virtual machine state using <link to="IConsole::saveState"/>
      or power it off using <link to="IConsole::powerDown"/>.
      Resuming the execution can lead to unpredictable results.

      <b>Non-fatal</b> errors and warnings are indicated by the
      @a fatal parameter set to @c false. If the virtual machine
      is in the Paused state by the time the error notification is
      received, it means that the user can <i>try to resume</i> the machine
      execution after attempting to solve the problem that caused the
      error. In this case, the notification handler is supposed
      to show an appropriate message to the user (depending on the
      value of the @a id parameter) that offers several actions such
      as <i>Retry</i>, <i>Save</i> or <i>Power Off</i>. If the user
      wants to retry, the notification handler should continue
      the machine execution using the <link to="IConsole::resume"/>
      call. If the machine execution is not Paused during this
      notification, then it means this notification is a <i>warning</i>
      (for example, about a fatal condition that can happen very soon);
      no immediate action is required from the user, the machine
      continues its normal execution.

      Note that in either case the notification handler
      <b>must not</b> perform any action directly on a thread
      where this notification is called. Everything it is allowed to
      do is to post a message to another thread that will then talk
      to the user and take the corresponding action.

      Currently, the following error identifiers are known:
      <ul>
        <li><tt>"HostMemoryLow"</tt></li>
        <li><tt>"HostAudioNotResponding"</tt></li>
        <li><tt>"VDIStorageFull"</tt></li>
        <li><tt>"3DSupportIncompatibleAdditions"</tt></li>
      </ul>
    </desc>
    <attribute name="fatal" type="boolean" readonly="yes">
      <desc>
        Whether the error is fatal or not.
      </desc>
    </attribute>
    <attribute name="id" type="wstring" readonly="yes">
      <desc>
        Error identifier.
      </desc>
    </attribute>
    <attribute name="message" type="wstring" readonly="yes">
      <desc>
        Optional error message.
      </desc>
    </attribute>
  </interface>


  <interface
    name="IEventSourceChangedEvent" extends="IEvent"
    uuid="e7932cb8-f6d4-4ab6-9cbf-558eb8959a6a"
    waitable="yes"
    wsmap="managed" autogen="VBoxEvent" id="OnEventSourceChanged"
    >
    <desc>
      Notification when an event source state changes (listener added or removed).
    </desc>

    <attribute name="listener" type="IEventListener" readonly="yes">
      <desc>
        Event listener which has changed.
      </desc>
    </attribute>

    <attribute name="add" type="boolean" readonly="yes">
      <desc>
        Flag whether listener was added or removed.
      </desc>
    </attribute>
  </interface>

  <interface
    name="IExtraDataChangedEvent" extends="IEvent"
    uuid="024F00CE-6E0B-492A-A8D0-968472A94DC7"
    wsmap="managed" autogen="VBoxEvent" id="OnExtraDataChanged"
    >
    <desc>
      Notification when machine specific or global extra data
      has changed.
    </desc>
    <attribute name="machineId" type="uuid" mod="string" readonly="yes">
      <desc>
        ID of the machine this event relates to.
        Null for global extra data changes.
      </desc>
    </attribute>
    <attribute name="key" type="wstring" readonly="yes">
      <desc>
        Extra data key that has changed.
      </desc>
    </attribute>
    <attribute name="value" type="wstring" readonly="yes">
      <desc>
        Extra data value for the given key.
      </desc>
    </attribute>
  </interface>

  <interface
    name="IVetoEvent" extends="IEvent"
    uuid="9a1a4130-69fe-472f-ac10-c6fa25d75007"
    wsmap="managed"
    >
    <desc>Base abstract interface for veto events.</desc>

    <method name="addVeto">
      <desc>
        Adds a veto on this event.
      </desc>
      <param name="reason" type="wstring" dir="in">
        <desc>
          Reason for veto, could be null or empty string.
        </desc>
      </param>
    </method>

    <method name="isVetoed">
      <desc>
        If this event was vetoed.
      </desc>
      <param name="result" type="boolean" dir="return">
        <desc>
          Reason for veto.
        </desc>
      </param>
    </method>

    <method name="getVetos">
      <desc>
        Current veto reason list, if size is 0 - no veto.
      </desc>
      <param name="result" type="wstring" dir="return" safearray="yes">
        <desc>
          Array of reasons for veto provided by different event handlers.
        </desc>
      </param>
    </method>

  </interface>

  <interface
    name="IExtraDataCanChangeEvent" extends="IVetoEvent"
    uuid="245d88bd-800a-40f8-87a6-170d02249a55"
    wsmap="managed" autogen="VBoxEvent" id="OnExtraDataCanChange"
    waitable="true"
    >
    <desc>
      Notification when someone tries to change extra data for
      either the given machine or (if @c null) global extra data.
      This gives the chance to veto against changes.
    </desc>
    <attribute name="machineId" type="uuid" mod="string" readonly="yes">
      <desc>
        ID of the machine this event relates to.
        Null for global extra data changes.
      </desc>
    </attribute>
    <attribute name="key" type="wstring" readonly="yes">
      <desc>
        Extra data key that has changed.
      </desc>
    </attribute>
    <attribute name="value" type="wstring" readonly="yes">
      <desc>
        Extra data value for the given key.
      </desc>
    </attribute>
  </interface>

  <interface
    name="ICanShowWindowEvent" extends="IVetoEvent"
    uuid="adf292b0-92c9-4a77-9d35-e058b39fe0b9"
    wsmap="managed" autogen="VBoxEvent" id="OnCanShowWindow"
    waitable="true"
    >
    <desc>
      Notification when a call to
      <link to="IMachine::canShowConsoleWindow"/> is made by a
      front-end to check if a subsequent call to
      <link to="IMachine::showConsoleWindow"/> can succeed.

      The callee should give an answer appropriate to the current
      machine state using event veto. This answer must
      remain valid at least until the next
      <link to="IConsole::state">machine state</link> change.
    </desc>
  </interface>

  <interface
    name="IShowWindowEvent" extends="IEvent"
    uuid="B0A0904D-2F05-4D28-855F-488F96BAD2B2"
    wsmap="managed" autogen="VBoxEvent" id="OnShowWindow"
    waitable="true"
    >
    <desc>
      Notification when a call to
      <link to="IMachine::showConsoleWindow"/>
      requests the console window to be activated and brought to
      foreground on the desktop of the host PC.

      This notification should cause the VM console process to
      perform the requested action as described above. If it is
      impossible to do it at a time of this notification, this
      method should return a failure.

      Note that many modern window managers on many platforms
      implement some sort of focus stealing prevention logic, so
      that it may be impossible to activate a window without the
      help of the currently active application (which is supposedly
      an initiator of this notification). In this case, this method
      must return a non-zero identifier that represents the
      top-level window of the VM console process. The caller, if it
      represents a currently active process, is responsible to use
      this identifier (in a platform-dependent manner) to perform
      actual window activation.

      This method must set @a winId to zero if it has performed all
      actions necessary to complete the request and the console
      window is now active and in foreground, to indicate that no
      further action is required on the caller's side.
    </desc>
    <attribute name="winId" type="long long">
      <desc>
        Platform-dependent identifier of the top-level VM console
        window, or zero if this method has performed all actions
        necessary to implement the <i>show window</i> semantics for
        the given platform and/or this VirtualBox front-end.
      </desc>
    </attribute>
  </interface>

  <interface
    name="INATRedirectEvent" extends="IMachineEvent"
    uuid="24eef068-c380-4510-bc7c-19314a7352f1"
    wsmap="managed" autogen="VBoxEvent" id="OnNATRedirect"
    >
    <desc>
      Notification when NAT redirect rule added or removed.
    </desc>
    <attribute name="slot"  type="unsigned long" readonly="yes">
      <desc>
        Adapter which NAT attached to.
      </desc>
    </attribute>
    <attribute name="remove"  type="boolean" readonly="yes">
      <desc>
        Whether rule remove or add.
      </desc>
    </attribute>
    <attribute name="name"  type="wstring" readonly="yes">
      <desc>
        Name of the rule.
      </desc>
    </attribute>
    <attribute name="proto"  type="NATProtocol" readonly="yes">
      <desc>
        Protocol (TCP or UDP) of the redirect rule.
      </desc>
    </attribute>
    <attribute name="hostIP"  type="wstring" readonly="yes">
      <desc>
        Host ip address to bind socket on.
      </desc>
    </attribute>
    <attribute name="hostPort"  type="long" readonly="yes">
      <desc>
        Host port to bind socket on.
      </desc>
    </attribute>
    <attribute name="guestIP"  type="wstring" readonly="yes">
      <desc>
        Guest ip address to redirect to.
      </desc>
    </attribute>
    <attribute name="guestPort"  type="long" readonly="yes">
      <desc>
        Guest port to redirect to.
      </desc>
    </attribute>
  </interface>

  <interface
    name="IHostPCIDevicePlugEvent" extends="IMachineEvent"
    waitable="yes"
    uuid="a0bad6df-d612-47d3-89d4-db3992533948"
    wsmap="managed" autogen="VBoxEvent" id="OnHostPCIDevicePlug"
    >
    <desc>
      Notification when host PCI device is plugged/unplugged. Plugging
      usually takes place on VM startup, unplug - when
      <link to="IMachine::detachHostPCIDevice"/> is called.

      <see><link to="IMachine::detachHostPCIDevice"/></see>

    </desc>

    <attribute name="plugged" type="boolean" readonly="yes">
      <desc>
      If device successfully plugged or unplugged.
      </desc>
    </attribute>

    <attribute name="success" type="boolean" readonly="yes">
      <desc>
        If operation was successful, if false - 'message' attribute
        may be of interest.
      </desc>
    </attribute>

    <attribute name="attachment" type="IPCIDeviceAttachment" readonly="yes">
      <desc>
        Attachment info for this device.
      </desc>
    </attribute>

    <attribute name="message" type="wstring" readonly="yes">
      <desc>
        Optional error message.
      </desc>
    </attribute>

  </interface>

  <interface
    name="IVBoxSVCAvailabilityChangedEvent" extends="IEvent"
    uuid="97c78fcd-d4fc-485f-8613-5af88bfcfcdc"
    wsmap="managed" autogen="VBoxEvent" id="OnVBoxSVCAvailabilityChanged"
    >
    <desc>
      Notification when VBoxSVC becomes unavailable (due to a crash or similar
      unexpected circumstances) or available again.
    </desc>

    <attribute name="available" type="boolean" readonly="yes">
      <desc>
        Whether VBoxSVC is available now.
      </desc>
    </attribute>
  </interface>

  <interface
    name="IBandwidthGroupChangedEvent" extends="IEvent"
    uuid="334df94a-7556-4cbc-8c04-043096b02d82"
    wsmap="managed" autogen="VBoxEvent" id="OnBandwidthGroupChanged"
    >
    <desc>
      Notification when one of the bandwidth groups changed
    </desc>
    <attribute name="bandwidthGroup" type="IBandwidthGroup" readonly="yes">
      <desc>
        The changed bandwidth group.
      </desc>
    </attribute>
  </interface>

  <enum
    name="GuestMonitorChangedEventType"
    uuid="ef172985-7e36-4297-95be-e46396968d66"
    >

    <desc>
      How the guest monitor has been changed.
    </desc>

    <const name="Enabled" value="0">
      <desc>
        The guest monitor has been enabled by the guest.
      </desc>
    </const>

    <const name="Disabled" value="1">
      <desc>
        The guest monitor has been disabled by the guest.
      </desc>
    </const>

    <const name="NewOrigin" value="2">
      <desc>
        The guest monitor origin has changed in the guest.
      </desc>
    </const>
  </enum>

  <interface
    name="IGuestMonitorChangedEvent" extends="IEvent"
    uuid="0f7b8a22-c71f-4a36-8e5f-a77d01d76090"
    wsmap="managed" autogen="VBoxEvent" id="OnGuestMonitorChanged"
    >
    <desc>
      Notification when the guest enables one of its monitors.
    </desc>

    <attribute name="changeType" type="GuestMonitorChangedEventType" readonly="yes">
      <desc>
        What was changed for this guest monitor.
      </desc>
    </attribute>

    <attribute name="screenId" type="unsigned long" readonly="yes">
      <desc>
        The monitor which was changed.
      </desc>
    </attribute>

    <attribute name="originX" type="unsigned long" readonly="yes">
      <desc>
        Physical X origin relative to the primary screen.
        Valid for Enabled and NewOrigin.
      </desc>
    </attribute>

    <attribute name="originY" type="unsigned long" readonly="yes">
      <desc>
        Physical Y origin relative to the primary screen.
        Valid for Enabled and NewOrigin.
      </desc>
    </attribute>

    <attribute name="width" type="unsigned long" readonly="yes">
      <desc>
        Width of the screen.
        Valid for Enabled.
      </desc>
    </attribute>

    <attribute name="height" type="unsigned long" readonly="yes">
      <desc>
        Height of the screen.
        Valid for Enabled.
      </desc>
    </attribute>

  </interface>

  <interface
    name="IStorageDeviceChangedEvent" extends="IEvent"
    uuid="8a5c2dce-e341-49d4-afce-c95979f7d70c"
    wsmap="managed" autogen="VBoxEvent" id="OnStorageDeviceChanged"
    >
    <desc>
      Notification when a
      <link to="IMachine::mediumAttachments">storage device</link>
      is attached or removed.
    </desc>
    <attribute name="storageDevice" type="IMediumAttachment" readonly="yes">
      <desc>
        Storage device that is subject to change.
      </desc>
    </attribute>
    <attribute name="removed" type="boolean" readonly="yes">
      <desc>
        Flag whether the device was removed or added to the VM.
      </desc>
    </attribute>
  </interface>

  <module name="VBoxSVC" context="LocalServer">
    <class name="VirtualBox" uuid="B1A7A4F2-47B9-4A1E-82B2-07CCD5323C3F"
           namespace="virtualbox.org">
      <interface name="IVirtualBox" default="yes"/>
    </class>
  </module>

  <module name="VBoxC" context="InprocServer" threadingModel="Free">
    <class name="VirtualBoxClient" uuid="dd3fc71d-26c0-4fe1-bf6f-67f633265bba"
           namespace="virtualbox.org">
      <interface name="IVirtualBoxClient" default="yes"/>
    </class>

    <class name="Session" uuid="3C02F46D-C9D2-4F11-A384-53F0CF917214"
           namespace="virtualbox.org">
      <interface name="ISession" default="yes"/>
    </class>
  </module>

</library>

</idl>

<!-- vim: set shiftwidth=2 tabstop=2 expandtab: -->
