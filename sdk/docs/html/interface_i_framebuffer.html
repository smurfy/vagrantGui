<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VirtualBox Main API: IFramebuffer Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<h1>IFramebuffer Interface Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="IFramebuffer" --><div class="dynheader">
Inheritance diagram for IFramebuffer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="interface_i_framebuffer.png" usemap="#IFramebuffer_map" alt=""/>
  <map id="IFramebuffer_map" name="IFramebuffer_map">
<area href="interface_i_framebuffer_overlay.html" alt="IFramebufferOverlay" shape="rect" coords="0,56,131,80"/>
</map>
</div>

<p><a href="interface_i_framebuffer-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_framebuffer.html#a6c8c55156546a623bac5a944098909fd">lock</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks the frame buffer.  <a href="#a6c8c55156546a623bac5a944098909fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_framebuffer.html#a3a31b634951c3f0aee780530d9be8432">unlock</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlocks the frame buffer.  <a href="#a3a31b634951c3f0aee780530d9be8432"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_framebuffer.html#af9ef34af79a7fbe86adf89146b429097">notifyUpdate</a> (in unsigned long x, in unsigned long y, in unsigned long <a class="el" href="interface_i_framebuffer.html#a27104dd7a42288a0b92eaf470c43c81f">width</a>, in unsigned long <a class="el" href="interface_i_framebuffer.html#ad37debf5af6d0a14631227aeb69d46ca">height</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Informs about an update.  <a href="#af9ef34af79a7fbe86adf89146b429097"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_framebuffer.html#acca74acdc0d58669b878bc0162cb8c8d">requestResize</a> (in unsigned long screenId, in unsigned long <a class="el" href="interface_i_framebuffer.html#ac6e02d790c59b14bbbfa3ee2415ed5db">pixelFormat</a>, in octetPtr VRAM, in unsigned long <a class="el" href="interface_i_framebuffer.html#a3cd2d1ab05ce6341aae02e53639b4ef0">bitsPerPixel</a>, in unsigned long <a class="el" href="interface_i_framebuffer.html#a2902f985df6b5e223439c1a35e132166">bytesPerLine</a>, in unsigned long <a class="el" href="interface_i_framebuffer.html#a27104dd7a42288a0b92eaf470c43c81f">width</a>, in unsigned long <a class="el" href="interface_i_framebuffer.html#ad37debf5af6d0a14631227aeb69d46ca">height</a>,[retval] out boolean finished)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Requests a size and pixel format change.  <a href="#acca74acdc0d58669b878bc0162cb8c8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_framebuffer.html#a0684d1eb3ada2b8c4f3ed75975ddce37">videoModeSupported</a> (in unsigned long <a class="el" href="interface_i_framebuffer.html#a27104dd7a42288a0b92eaf470c43c81f">width</a>, in unsigned long <a class="el" href="interface_i_framebuffer.html#ad37debf5af6d0a14631227aeb69d46ca">height</a>, in unsigned long bpp,[retval] out boolean supported)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the frame buffer implementation is willing to support a given video mode.  <a href="#a0684d1eb3ada2b8c4f3ed75975ddce37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_framebuffer.html#a43c690a6a59e2b4792bf6016d8dab1dd">getVisibleRegion</a> (in octetPtr rectangles, in unsigned long count,[retval] out unsigned long countCopied)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the visible region of this frame buffer.  <a href="#a43c690a6a59e2b4792bf6016d8dab1dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_framebuffer.html#aac811856aac09ce54871faf9bf07950a">setVisibleRegion</a> (in octetPtr rectangles, in unsigned long count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suggests a new visible region to this frame buffer.  <a href="#aac811856aac09ce54871faf9bf07950a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_framebuffer.html#a8160e287a864fa871511ebd812e6f74f">processVHWACommand</a> (in octetPtr command)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Posts a Video HW Acceleration Command to the frame buffer for processing.  <a href="#a8160e287a864fa871511ebd812e6f74f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute octetPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_framebuffer.html#afd0d7950ae0255bb219b6ab044649a6f">address</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Address of the start byte of the frame buffer.  <a href="#afd0d7950ae0255bb219b6ab044649a6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_framebuffer.html#a27104dd7a42288a0b92eaf470c43c81f">width</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frame buffer width, in pixels.  <a href="#a27104dd7a42288a0b92eaf470c43c81f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_framebuffer.html#ad37debf5af6d0a14631227aeb69d46ca">height</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frame buffer height, in pixels.  <a href="#ad37debf5af6d0a14631227aeb69d46ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_framebuffer.html#a3cd2d1ab05ce6341aae02e53639b4ef0">bitsPerPixel</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Color depth, in bits per pixel.  <a href="#a3cd2d1ab05ce6341aae02e53639b4ef0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_framebuffer.html#a2902f985df6b5e223439c1a35e132166">bytesPerLine</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scan line size, in bytes.  <a href="#a2902f985df6b5e223439c1a35e132166"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_framebuffer.html#ac6e02d790c59b14bbbfa3ee2415ed5db">pixelFormat</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frame buffer pixel format.  <a href="#ac6e02d790c59b14bbbfa3ee2415ed5db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_framebuffer.html#a8899610297a797c20c35b0fca3853d3f">usesGuestVRAM</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines whether this frame buffer uses the virtual video card's memory buffer (guest VRAM) directly or not.  <a href="#a8899610297a797c20c35b0fca3853d3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_framebuffer.html#af528ac47e505a5fbd3fb7016da0bfdb8">heightReduction</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hint from the frame buffer about how much of the standard screen height it wants to use for itself.  <a href="#af528ac47e505a5fbd3fb7016da0bfdb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute <br class="typebreak"/>
<a class="el" href="interface_i_framebuffer_overlay.html">IFramebufferOverlay</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_framebuffer.html#ac81446b93ab2d249cd3e83cdcf0e5610">overlay</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An alpha-blended overlay which is superposed over the frame buffer.  <a href="#ac81446b93ab2d249cd3e83cdcf0e5610"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_framebuffer.html#a718b9fa50e62fa4ca9c38673a17c3b12">winId</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Platform-dependent identifier of the window where context of this frame buffer is drawn, or zero if there's no such window.  <a href="#a718b9fa50e62fa4ca9c38673a17c3b12"></a><br/></td></tr>
</table>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a6c8c55156546a623bac5a944098909fd"></a><!-- doxytag: member="IFramebuffer::lock" ref="a6c8c55156546a623bac5a944098909fd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IFramebuffer::lock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locks the frame buffer. </p>
<p>Gets called by the <a class="el" href="interface_i_display.html" title="The IDisplay interface represents the virtual machine&#39;s display.">IDisplay</a> object where this frame buffer is bound to. </p>

</div>
</div>
<a class="anchor" id="a3a31b634951c3f0aee780530d9be8432"></a><!-- doxytag: member="IFramebuffer::unlock" ref="a3a31b634951c3f0aee780530d9be8432" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IFramebuffer::unlock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlocks the frame buffer. </p>
<p>Gets called by the <a class="el" href="interface_i_display.html" title="The IDisplay interface represents the virtual machine&#39;s display.">IDisplay</a> object where this frame buffer is bound to. </p>

</div>
</div>
<a class="anchor" id="af9ef34af79a7fbe86adf89146b429097"></a><!-- doxytag: member="IFramebuffer::notifyUpdate" ref="af9ef34af79a7fbe86adf89146b429097" args="(in unsigned long x, in unsigned long y, in unsigned long width, in unsigned long height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IFramebuffer::notifyUpdate </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Informs about an update. </p>
<p>Gets called by the display object where this buffer is registered. </p>

</div>
</div>
<a class="anchor" id="acca74acdc0d58669b878bc0162cb8c8d"></a><!-- doxytag: member="IFramebuffer::requestResize" ref="acca74acdc0d58669b878bc0162cb8c8d" args="(in unsigned long screenId, in unsigned long pixelFormat, in octetPtr VRAM, in unsigned long bitsPerPixel, in unsigned long bytesPerLine, in unsigned long width, in unsigned long height,[retval] out boolean finished)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IFramebuffer::requestResize </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>screenId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>pixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in octetPtr&nbsp;</td>
          <td class="paramname"> <em>VRAM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>bitsPerPixel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>bytesPerLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out boolean&nbsp;</td>
          <td class="paramname"> <em>finished</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Requests a size and pixel format change. </p>
<p>There are two modes of working with the video buffer of the virtual machine. The <em>indirect</em> mode implies that the <a class="el" href="interface_i_framebuffer.html">IFramebuffer</a> implementation allocates a memory buffer for the requested display mode and provides it to the virtual machine. In <em>direct</em> mode, the <a class="el" href="interface_i_framebuffer.html">IFramebuffer</a> implementation uses the memory buffer allocated and owned by the virtual machine. This buffer represents the video memory of the emulated video adapter (so called <em>guest VRAM</em>). The direct mode is usually faster because the implementation gets a raw pointer to the guest VRAM buffer which it can directly use for visualizing the contents of the virtual display, as opposed to the indirect mode where the contents of guest VRAM are copied to the memory buffer provided by the implementation every time a display update occurs.</p>
<p>It is important to note that the direct mode is really fast only when the implementation uses the given guest VRAM buffer directly, for example, by blitting it to the window representing the virtual machine's display, which saves at least one copy operation comparing to the indirect mode. However, using the guest VRAM buffer directly is not always possible: the format and the color depth of this buffer may be not supported by the target window, or it may be unknown (opaque) as in case of text or non-linear multi-plane VGA video modes. In this case, the indirect mode (that is always available) should be used as a fallback: when the guest VRAM contents are copied to the implementation-provided memory buffer, color and format conversion is done automatically by the underlying code.</p>
<p>The <em>pixelFormat</em> parameter defines whether the direct mode is available or not. If <em>pixelFormat</em> is <a class="el" href="_virtual_box_8idl.html#a84c61ceeb099eea56755556569841556aea15858402d4c2420f44ddb442fbd640">FramebufferPixelFormat_Opaque</a><b></b> then direct access to the guest VRAM buffer is not available -- the <em>VRAM</em>, <em>bitsPerPixel</em> and <em>bytesPerLine</em> parameters must be ignored and the implementation must use the indirect mode (where it provides its own buffer in one of the supported formats). In all other cases, <em>pixelFormat</em> together with <em>bitsPerPixel</em> and <em>bytesPerLine</em> define the format of the video memory buffer pointed to by the <em>VRAM</em> parameter and the implementation is free to choose which mode to use. To indicate that this frame buffer uses the direct mode, the implementation of the <a class="el" href="interface_i_framebuffer.html#a8899610297a797c20c35b0fca3853d3f">usesGuestVRAM</a><b></b> attribute must return <code>true</code> and <a class="el" href="interface_i_framebuffer.html#afd0d7950ae0255bb219b6ab044649a6f">address</a><b></b> must return exactly the same address that is passed in the <em>VRAM</em> parameter of this method; otherwise it is assumed that the indirect strategy is chosen.</p>
<p>The <em>width</em> and <em>height</em> parameters represent the size of the requested display mode in both modes. In case of indirect mode, the provided memory buffer should be big enough to store data of the given display mode. In case of direct mode, it is guaranteed that the given <em>VRAM</em> buffer contains enough space to represent the display mode of the given size. Note that this frame buffer's <a class="el" href="interface_i_framebuffer.html#a27104dd7a42288a0b92eaf470c43c81f">width</a><b></b> and <a class="el" href="interface_i_framebuffer.html#ad37debf5af6d0a14631227aeb69d46ca">height</a><b></b> attributes must return exactly the same values as passed to this method after the resize is completed (see below).</p>
<p>The <em>finished</em> output parameter determines if the implementation has finished resizing the frame buffer or not. If, for some reason, the resize cannot be finished immediately during this call, <em>finished</em> must be set to <code>false</code>, and the implementation must call <a class="el" href="interface_i_display.html#a6800f95f283bec4fa1d2f9310222b702">IDisplay::resizeCompleted</a><b></b> after it has returned from this method as soon as possible. If <em>finished</em> is <code>false</code>, the machine will not call any frame buffer methods until <a class="el" href="interface_i_display.html#a6800f95f283bec4fa1d2f9310222b702">IDisplay::resizeCompleted</a><b></b> is called.</p>
<p>Note that if the direct mode is chosen, the <a class="el" href="interface_i_framebuffer.html#a3cd2d1ab05ce6341aae02e53639b4ef0">bitsPerPixel</a><b></b>, <a class="el" href="interface_i_framebuffer.html#a2902f985df6b5e223439c1a35e132166">bytesPerLine</a><b></b> and <a class="el" href="interface_i_framebuffer.html#ac6e02d790c59b14bbbfa3ee2415ed5db">pixelFormat</a><b></b> attributes of this frame buffer must return exactly the same values as specified in the parameters of this method, after the resize is completed. If the indirect mode is chosen, these attributes must return values describing the format of the implementation's own memory buffer <a class="el" href="interface_i_framebuffer.html#afd0d7950ae0255bb219b6ab044649a6f">address</a><b></b> points to. Note also that the <a class="el" href="interface_i_framebuffer.html#a3cd2d1ab05ce6341aae02e53639b4ef0">bitsPerPixel</a><b></b> value must always correlate with <a class="el" href="interface_i_framebuffer.html#ac6e02d790c59b14bbbfa3ee2415ed5db">pixelFormat</a><b></b>. Note that the <a class="el" href="interface_i_framebuffer.html#ac6e02d790c59b14bbbfa3ee2415ed5db">pixelFormat</a><b></b> attribute must never return <a class="el" href="_virtual_box_8idl.html#a84c61ceeb099eea56755556569841556aea15858402d4c2420f44ddb442fbd640">FramebufferPixelFormat_Opaque</a><b></b> regardless of the selected mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>screenId</em>&nbsp;</td><td>Logical screen number. Must be used in the corresponding call to <a class="el" href="interface_i_display.html#a6800f95f283bec4fa1d2f9310222b702">IDisplay::resizeCompleted</a><b></b> if this call is made.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixelFormat</em>&nbsp;</td><td>Pixel format of the memory buffer pointed to by <em>VRAM</em>. See also <a class="el" href="_virtual_box_8idl.html#a84c61ceeb099eea56755556569841556">FramebufferPixelFormat</a><b></b>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VRAM</em>&nbsp;</td><td>Pointer to the virtual video card's VRAM (may be <code>null</code>).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitsPerPixel</em>&nbsp;</td><td>Color depth, bits per pixel.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytesPerLine</em>&nbsp;</td><td>Size of one scan line, in bytes.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Width of the guest display, in pixels.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Height of the guest display, in pixels.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>finished</em>&nbsp;</td><td>Can the VM start using the new frame buffer immediately after this method returns or it should wait for <a class="el" href="interface_i_display.html#a6800f95f283bec4fa1d2f9310222b702">IDisplay::resizeCompleted</a><b></b>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This method is called by the <a class="el" href="interface_i_display.html" title="The IDisplay interface represents the virtual machine&#39;s display.">IDisplay</a> object under the <a class="el" href="interface_i_framebuffer.html#a6c8c55156546a623bac5a944098909fd">lock</a><b></b> provided by this <a class="el" href="interface_i_framebuffer.html">IFramebuffer</a> implementation. If this method returns <code>false</code> in <em>finished</em>, then this lock is not released until <a class="el" href="interface_i_display.html#a6800f95f283bec4fa1d2f9310222b702">IDisplay::resizeCompleted</a><b></b> is called.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This method is non-scriptable. In particular, this also means that an attempt to call it from a process other than the process that has created and owns the object will most likely fail or crash your application. </dd></dl>

</div>
</div>
<a class="anchor" id="a0684d1eb3ada2b8c4f3ed75975ddce37"></a><!-- doxytag: member="IFramebuffer::videoModeSupported" ref="a0684d1eb3ada2b8c4f3ed75975ddce37" args="(in unsigned long width, in unsigned long height, in unsigned long bpp,[retval] out boolean supported)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IFramebuffer::videoModeSupported </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>bpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out boolean&nbsp;</td>
          <td class="paramname"> <em>supported</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the frame buffer implementation is willing to support a given video mode. </p>
<p>In case it is not able to render the video mode (or for some reason not willing), it should return <code>false</code>. Usually this method is called when the guest asks the VMM device whether a given video mode is supported so the information returned is directly exposed to the guest. It is important that this method returns very quickly. </p>

</div>
</div>
<a class="anchor" id="a43c690a6a59e2b4792bf6016d8dab1dd"></a><!-- doxytag: member="IFramebuffer::getVisibleRegion" ref="a43c690a6a59e2b4792bf6016d8dab1dd" args="(in octetPtr rectangles, in unsigned long count,[retval] out unsigned long countCopied)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IFramebuffer::getVisibleRegion </td>
          <td>(</td>
          <td class="paramtype">in octetPtr&nbsp;</td>
          <td class="paramname"> <em>rectangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out unsigned long&nbsp;</td>
          <td class="paramname"> <em>countCopied</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the visible region of this frame buffer. </p>
<p>If the <em>rectangles</em> parameter is <code>null</code> then the value of the <em>count</em> parameter is ignored and the number of elements necessary to describe the current visible region is returned in <em>countCopied</em>.</p>
<p>If <em>rectangles</em> is not <code>null</code> but <em>count</em> is less than the required number of elements to store region data, the method will report a failure. If <em>count</em> is equal or greater than the required number of elements, then the actual number of elements copied to the provided array will be returned in <em>countCopied</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rectangles</em>&nbsp;</td><td>Pointer to the <code>RTRECT</code> array to receive region data.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of <code>RTRECT</code> elements in the <em>rectangles</em> array.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>countCopied</em>&nbsp;</td><td>Number of elements copied to the <em>rectangles</em> array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The address of the provided array must be in the process space of this <a class="el" href="interface_i_framebuffer.html">IFramebuffer</a> object.</dd>
<dd>
Method not yet implemented.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This method is non-scriptable. In particular, this also means that an attempt to call it from a process other than the process that has created and owns the object will most likely fail or crash your application. </dd></dl>

</div>
</div>
<a class="anchor" id="aac811856aac09ce54871faf9bf07950a"></a><!-- doxytag: member="IFramebuffer::setVisibleRegion" ref="aac811856aac09ce54871faf9bf07950a" args="(in octetPtr rectangles, in unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IFramebuffer::setVisibleRegion </td>
          <td>(</td>
          <td class="paramtype">in octetPtr&nbsp;</td>
          <td class="paramname"> <em>rectangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Suggests a new visible region to this frame buffer. </p>
<p>This region represents the area of the VM display which is a union of regions of all top-level windows of the guest operating system running inside the VM (if the Guest Additions for this system support this functionality). This information may be used by the frontends to implement the seamless desktop integration feature.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rectangles</em>&nbsp;</td><td>Pointer to the <code>RTRECT</code> array.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of <code>RTRECT</code> elements in the <em>rectangles</em> array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The address of the provided array must be in the process space of this <a class="el" href="interface_i_framebuffer.html">IFramebuffer</a> object.</dd>
<dd>
The <a class="el" href="interface_i_framebuffer.html">IFramebuffer</a> implementation must make a copy of the provided array of rectangles.</dd>
<dd>
Method not yet implemented.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This method is non-scriptable. In particular, this also means that an attempt to call it from a process other than the process that has created and owns the object will most likely fail or crash your application. </dd></dl>

</div>
</div>
<a class="anchor" id="a8160e287a864fa871511ebd812e6f74f"></a><!-- doxytag: member="IFramebuffer::processVHWACommand" ref="a8160e287a864fa871511ebd812e6f74f" args="(in octetPtr command)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IFramebuffer::processVHWACommand </td>
          <td>(</td>
          <td class="paramtype">in octetPtr&nbsp;</td>
          <td class="paramname"> <em>command</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Posts a Video HW Acceleration Command to the frame buffer for processing. </p>
<p>The commands used for 2D video acceleration (DDraw surface creation/destroying, blitting, scaling, color conversion, overlaying, etc.) are posted from quest to the host to be processed by the host hardware.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>command</em>&nbsp;</td><td>Pointer to VBOXVHWACMD containing the command to execute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The address of the provided command must be in the process space of this <a class="el" href="interface_i_framebuffer.html">IFramebuffer</a> object.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This method is non-scriptable. In particular, this also means that an attempt to call it from a process other than the process that has created and owns the object will most likely fail or crash your application. </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="afd0d7950ae0255bb219b6ab044649a6f"></a><!-- doxytag: member="IFramebuffer::address" ref="afd0d7950ae0255bb219b6ab044649a6f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute octetPtr <a class="el" href="interface_i_framebuffer.html#afd0d7950ae0255bb219b6ab044649a6f">IFramebuffer::address</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Address of the start byte of the frame buffer. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This attribute is non-scriptable. In particular, this also means that an attempt to get or set it from a process other than the process that has created and owns the object will most likely fail or crash your application. </dd></dl>

</div>
</div>
<a class="anchor" id="a27104dd7a42288a0b92eaf470c43c81f"></a><!-- doxytag: member="IFramebuffer::width" ref="a27104dd7a42288a0b92eaf470c43c81f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute unsigned long <a class="el" href="interface_i_framebuffer.html#a27104dd7a42288a0b92eaf470c43c81f">IFramebuffer::width</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frame buffer width, in pixels. </p>

</div>
</div>
<a class="anchor" id="ad37debf5af6d0a14631227aeb69d46ca"></a><!-- doxytag: member="IFramebuffer::height" ref="ad37debf5af6d0a14631227aeb69d46ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute unsigned long <a class="el" href="interface_i_framebuffer.html#ad37debf5af6d0a14631227aeb69d46ca">IFramebuffer::height</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frame buffer height, in pixels. </p>

</div>
</div>
<a class="anchor" id="a3cd2d1ab05ce6341aae02e53639b4ef0"></a><!-- doxytag: member="IFramebuffer::bitsPerPixel" ref="a3cd2d1ab05ce6341aae02e53639b4ef0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute unsigned long <a class="el" href="interface_i_framebuffer.html#a3cd2d1ab05ce6341aae02e53639b4ef0">IFramebuffer::bitsPerPixel</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Color depth, in bits per pixel. </p>
<p>When <a class="el" href="interface_i_framebuffer.html#ac6e02d790c59b14bbbfa3ee2415ed5db">pixelFormat</a><b></b> is <a class="el" href="_virtual_box_8idl.html#a84c61ceeb099eea56755556569841556a20600e949579db6ce7fd78e1a18e8ecc">FOURCC_RGB</a><b></b>, valid values are: 8, 15, 16, 24 and 32. </p>

</div>
</div>
<a class="anchor" id="a2902f985df6b5e223439c1a35e132166"></a><!-- doxytag: member="IFramebuffer::bytesPerLine" ref="a2902f985df6b5e223439c1a35e132166" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute unsigned long <a class="el" href="interface_i_framebuffer.html#a2902f985df6b5e223439c1a35e132166">IFramebuffer::bytesPerLine</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scan line size, in bytes. </p>
<p>When <a class="el" href="interface_i_framebuffer.html#ac6e02d790c59b14bbbfa3ee2415ed5db">pixelFormat</a><b></b> is <a class="el" href="_virtual_box_8idl.html#a84c61ceeb099eea56755556569841556a20600e949579db6ce7fd78e1a18e8ecc">FOURCC_RGB</a><b></b>, the size of the scan line must be aligned to 32 bits. </p>

</div>
</div>
<a class="anchor" id="ac6e02d790c59b14bbbfa3ee2415ed5db"></a><!-- doxytag: member="IFramebuffer::pixelFormat" ref="ac6e02d790c59b14bbbfa3ee2415ed5db" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute unsigned long <a class="el" href="interface_i_framebuffer.html#ac6e02d790c59b14bbbfa3ee2415ed5db">IFramebuffer::pixelFormat</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frame buffer pixel format. </p>
<p>It's either one of the values defined by <a class="el" href="_virtual_box_8idl.html#a84c61ceeb099eea56755556569841556">FramebufferPixelFormat</a><b></b> or a raw FOURCC code.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This attribute must never return <a class="el" href="_virtual_box_8idl.html#a84c61ceeb099eea56755556569841556aea15858402d4c2420f44ddb442fbd640">FramebufferPixelFormat_Opaque</a><b></b> -- the format of the buffer <a class="el" href="interface_i_framebuffer.html#afd0d7950ae0255bb219b6ab044649a6f">address</a><b></b> points to must be always known. </dd></dl>

</div>
</div>
<a class="anchor" id="a8899610297a797c20c35b0fca3853d3f"></a><!-- doxytag: member="IFramebuffer::usesGuestVRAM" ref="a8899610297a797c20c35b0fca3853d3f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute boolean <a class="el" href="interface_i_framebuffer.html#a8899610297a797c20c35b0fca3853d3f">IFramebuffer::usesGuestVRAM</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines whether this frame buffer uses the virtual video card's memory buffer (guest VRAM) directly or not. </p>
<p>See <a class="el" href="interface_i_framebuffer.html#acca74acdc0d58669b878bc0162cb8c8d">IFramebuffer::requestResize</a><b></b> for more information. </p>

</div>
</div>
<a class="anchor" id="af528ac47e505a5fbd3fb7016da0bfdb8"></a><!-- doxytag: member="IFramebuffer::heightReduction" ref="af528ac47e505a5fbd3fb7016da0bfdb8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute unsigned long <a class="el" href="interface_i_framebuffer.html#af528ac47e505a5fbd3fb7016da0bfdb8">IFramebuffer::heightReduction</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hint from the frame buffer about how much of the standard screen height it wants to use for itself. </p>
<p>This information is exposed to the guest through the VESA BIOS and VMMDev interface so that it can use it for determining its video mode table. It is not guaranteed that the guest respects the value. </p>

</div>
</div>
<a class="anchor" id="ac81446b93ab2d249cd3e83cdcf0e5610"></a><!-- doxytag: member="IFramebuffer::overlay" ref="ac81446b93ab2d249cd3e83cdcf0e5610" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_framebuffer_overlay.html">IFramebufferOverlay</a> <a class="el" href="interface_i_framebuffer.html#ac81446b93ab2d249cd3e83cdcf0e5610">IFramebuffer::overlay</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An alpha-blended overlay which is superposed over the frame buffer. </p>
<p>The initial purpose is to allow the display of icons providing information about the VM state, including disk activity, in front ends which do not have other means of doing that. The overlay is designed to controlled exclusively by <a class="el" href="interface_i_display.html" title="The IDisplay interface represents the virtual machine&#39;s display.">IDisplay</a>. It has no locking of its own, and any changes made to it are not guaranteed to be visible until the affected portion of <a class="el" href="interface_i_framebuffer.html">IFramebuffer</a> is updated. The overlay can be created lazily the first time it is requested. This attribute can also return <code>null</code> to signal that the overlay is not implemented. </p>

</div>
</div>
<a class="anchor" id="a718b9fa50e62fa4ca9c38673a17c3b12"></a><!-- doxytag: member="IFramebuffer::winId" ref="a718b9fa50e62fa4ca9c38673a17c3b12" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute long long <a class="el" href="interface_i_framebuffer.html#a718b9fa50e62fa4ca9c38673a17c3b12">IFramebuffer::winId</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent identifier of the window where context of this frame buffer is drawn, or zero if there's no such window. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Sep 13 2012 07:09:48 for VirtualBox Main API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
