<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VirtualBox Main API: IEvent Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<h1>IEvent Interface Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="IEvent" -->
<p>Abstract parent interface for VirtualBox events.  
<a href="#_details">More...</a></p>
<div class="dynheader">
Inheritance diagram for IEvent:</div>
<div class="dyncontent">
 <div class="center">
  <img src="interface_i_event.png" usemap="#IEvent_map" alt=""/>
  <map id="IEvent_map" name="IEvent_map">
<area href="interface_i_additions_state_changed_event.html" alt="IAdditionsStateChangedEvent" shape="rect" coords="226,56,442,80"/>
<area href="interface_i_bandwidth_group_changed_event.html" alt="IBandwidthGroupChangedEvent" shape="rect" coords="226,112,442,136"/>
<area href="interface_i_c_p_u_changed_event.html" alt="ICPUChangedEvent" shape="rect" coords="226,168,442,192"/>
<area href="interface_i_c_p_u_execution_cap_changed_event.html" alt="ICPUExecutionCapChangedEvent" shape="rect" coords="226,224,442,248"/>
<area href="interface_i_event_source_changed_event.html" alt="IEventSourceChangedEvent" shape="rect" coords="226,280,442,304"/>
<area href="interface_i_extra_data_changed_event.html" alt="IExtraDataChangedEvent" shape="rect" coords="226,336,442,360"/>
<area href="interface_i_guest_keyboard_event.html" alt="IGuestKeyboardEvent" shape="rect" coords="226,392,442,416"/>
<area href="interface_i_guest_monitor_changed_event.html" alt="IGuestMonitorChangedEvent" shape="rect" coords="226,448,442,472"/>
<area href="interface_i_keyboard_leds_changed_event.html" alt="IKeyboardLedsChangedEvent" shape="rect" coords="226,504,442,528"/>
<area href="interface_i_machine_event.html" alt="IMachineEvent" shape="rect" coords="226,560,442,584"/>
<area href="interface_i_medium_changed_event.html" alt="IMediumChangedEvent" shape="rect" coords="226,616,442,640"/>
<area href="interface_i_medium_registered_event.html" alt="IMediumRegisteredEvent" shape="rect" coords="226,672,442,696"/>
<area href="interface_i_mouse_capability_changed_event.html" alt="IMouseCapabilityChangedEvent" shape="rect" coords="226,728,442,752"/>
<area href="interface_i_mouse_pointer_shape_changed_event.html" alt="IMousePointerShapeChangedEvent" shape="rect" coords="226,784,442,808"/>
<area href="interface_i_network_adapter_changed_event.html" alt="INetworkAdapterChangedEvent" shape="rect" coords="226,840,442,864"/>
<area href="interface_i_parallel_port_changed_event.html" alt="IParallelPortChangedEvent" shape="rect" coords="226,896,442,920"/>
<area href="interface_i_reusable_event.html" alt="IReusableEvent" shape="rect" coords="226,952,442,976"/>
<area href="interface_i_runtime_error_event.html" alt="IRuntimeErrorEvent" shape="rect" coords="226,1008,442,1032"/>
<area href="interface_i_serial_port_changed_event.html" alt="ISerialPortChangedEvent" shape="rect" coords="226,1064,442,1088"/>
<area href="interface_i_shared_folder_changed_event.html" alt="ISharedFolderChangedEvent" shape="rect" coords="226,1120,442,1144"/>
<area href="interface_i_show_window_event.html" alt="IShowWindowEvent" shape="rect" coords="226,1176,442,1200"/>
<area href="interface_i_state_changed_event.html" alt="IStateChangedEvent" shape="rect" coords="226,1232,442,1256"/>
<area href="interface_i_storage_controller_changed_event.html" alt="IStorageControllerChangedEvent" shape="rect" coords="226,1288,442,1312"/>
<area href="interface_i_storage_device_changed_event.html" alt="IStorageDeviceChangedEvent" shape="rect" coords="226,1344,442,1368"/>
<area href="interface_i_u_s_b_controller_changed_event.html" alt="IUSBControllerChangedEvent" shape="rect" coords="226,1400,442,1424"/>
<area href="interface_i_u_s_b_device_state_changed_event.html" alt="IUSBDeviceStateChangedEvent" shape="rect" coords="226,1456,442,1480"/>
<area href="interface_i_v_box_s_v_c_availability_changed_event.html" alt="IVBoxSVCAvailabilityChangedEvent" shape="rect" coords="226,1512,442,1536"/>
<area href="interface_i_veto_event.html" alt="IVetoEvent" shape="rect" coords="226,1568,442,1592"/>
<area href="interface_i_v_r_d_e_server_changed_event.html" alt="IVRDEServerChangedEvent" shape="rect" coords="226,1624,442,1648"/>
<area href="interface_i_v_r_d_e_server_info_changed_event.html" alt="IVRDEServerInfoChangedEvent" shape="rect" coords="226,1680,442,1704"/>
</map>
</div>

<p><a href="interface_i_event-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_event.html#a3c6dca949a20f509a58eedb31462cf16">setProcessed</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method called by the system when all listeners of a particular event have called <a class="el" href="interface_i_event_source.html#abedc1e5401a7e8c762ea18a84b5609de">IEventSource::eventProcessed</a><b></b>.  <a href="#a3c6dca949a20f509a58eedb31462cf16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_event.html#a70f85e0a61260a5e84d3e7e4e0c7ece2">waitProcessed</a> (in long timeout,[retval] out boolean result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait until time outs, or this event is processed.  <a href="#a70f85e0a61260a5e84d3e7e4e0c7ece2"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="_virtual_box_8idl.html#ab869a099f4a40172d197c9adeffe4bd4">VBoxEventType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_event.html#a2df73794a587ecee06560493aa4b4e06">type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event type.  <a href="#a2df73794a587ecee06560493aa4b4e06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_event_source.html">IEventSource</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_event.html#a8ce56b1841f4756a9f8b77837e267ed1">source</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Source of this event.  <a href="#a8ce56b1841f4756a9f8b77837e267ed1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_event.html#ab0b1be852bdf0359ec175e5d81b2f0b7">waitable</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If we can wait for this event being processed.  <a href="#ab0b1be852bdf0359ec175e5d81b2f0b7"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Abstract parent interface for VirtualBox events. </p>
<p>Actual events will typically implement a more specific interface which derives from this (see below).</p>
<p><b>Introduction to VirtualBox events</b></p>
<p>Generally speaking, an event (represented by this interface) signals that something happened, while an event listener (see <a class="el" href="interface_i_event_listener.html">IEventListener</a><b></b>) represents an entity that is interested in certain events. In order for this to work with unidirectional protocols (i.e. web services), the concepts of passive and active listener are used.</p>
<p>Event consumers can register themselves as listeners, providing an array of events they are interested in (see <a class="el" href="interface_i_event_source.html#a663bc2d863defd427b09d0323e9cf0a5">IEventSource::registerListener</a><b></b>). When an event triggers, the listener is notified about the event. The exact mechanism of the notification depends on whether the listener was registered as an active or passive listener:</p>
<ul>
<li>
An active listener is very similar to a callback: it is a function invoked by the API. As opposed to the callbacks that were used in the API before VirtualBox 4.0 however, events are now objects with an interface hierarchy.  </li>
<li>
Passive listeners are somewhat trickier to implement, but do not require a client function to be callable, which is not an option with scripting languages or web service clients. Internally the <a class="el" href="interface_i_event_source.html">IEventSource</a><b></b> implementation maintains an event queue for each passive listener, and newly arrived events are put in this queue. When the listener calls <a class="el" href="interface_i_event_source.html#a059b6a2c6247ff1c13f0a16f1afea19f">IEventSource::getEvent</a><b></b>, first element from its internal event queue is returned. When the client completes processing of an event, the <a class="el" href="interface_i_event_source.html#abedc1e5401a7e8c762ea18a84b5609de">IEventSource::eventProcessed</a><b></b> function must be called, acknowledging that the event was processed. It supports implementing waitable events. On passive listener unregistration, all events from its queue are auto-acknowledged.  </li>
</ul>
<p>Waitable events are useful in situations where the event generator wants to track delivery or a party wants to wait until all listeners have completed the event. A typical example would be a vetoable event (see <a class="el" href="interface_i_veto_event.html">IVetoEvent</a><b></b>) where a listeners might veto a certain action, and thus the event producer has to make sure that all listeners have processed the event and not vetoed before taking the action.</p>
<p>A given event may have both passive and active listeners at the same time.</p>
<p><b>Using events</b></p>
<p>Any VirtualBox object capable of producing externally visible events provides an <code>eventSource</code> read-only attribute, which is of the type <a class="el" href="interface_i_event_source.html">IEventSource</a><b></b>. This event source object is notified by VirtualBox once something has happened, so consumers may register event listeners with this event source. To register a listener, an object implementing the <a class="el" href="interface_i_event_listener.html">IEventListener</a><b></b> interface must be provided. For active listeners, such an object is typically created by the consumer, while for passive listeners <a class="el" href="interface_i_event_source.html#aad89d43d3cbdc2e9201896c684cd25dc">IEventSource::createListener</a><b></b> should be used. Please note that a listener created with <a class="el" href="interface_i_event_source.html#aad89d43d3cbdc2e9201896c684cd25dc">IEventSource::createListener</a><b></b> must not be used as an active listener.</p>
<p>Once created, the listener must be registered to listen for the desired events (see <a class="el" href="interface_i_event_source.html#a663bc2d863defd427b09d0323e9cf0a5">IEventSource::registerListener</a><b></b>), providing an array of <a class="el" href="_virtual_box_8idl.html#ab869a099f4a40172d197c9adeffe4bd4">VBoxEventType</a><b></b> enums. Those elements can either be the individual event IDs or wildcards matching multiple event IDs.</p>
<p>After registration, the callback's <a class="el" href="interface_i_event_listener.html#aa85f785eed52ccbeec3b8dd573a294e2">IEventListener::handleEvent</a><b></b> method is called automatically when the event is triggered, while passive listeners have to call <a class="el" href="interface_i_event_source.html#a059b6a2c6247ff1c13f0a16f1afea19f">IEventSource::getEvent</a><b></b> and <a class="el" href="interface_i_event_source.html#abedc1e5401a7e8c762ea18a84b5609de">IEventSource::eventProcessed</a><b></b> in an event processing loop.</p>
<p>The <a class="el" href="interface_i_event.html" title="Abstract parent interface for VirtualBox events.">IEvent</a> interface is an abstract parent interface for all such VirtualBox events coming in. As a result, the standard use pattern inside <a class="el" href="interface_i_event_listener.html#aa85f785eed52ccbeec3b8dd573a294e2">IEventListener::handleEvent</a><b></b> or the event processing loop is to check the <a class="el" href="interface_i_event.html#a2df73794a587ecee06560493aa4b4e06">type</a><b></b> attribute of the event and then cast to the appropriate specific interface using <code>QueryInterface()</code>.</p>
<dl class="user"><dt><b>Interface ID:</b></dt><dd><code>{0CA2ADBA-8F30-401B-A8CD-FE31DBE839C0}</code> </dd></dl>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3c6dca949a20f509a58eedb31462cf16"></a><!-- doxytag: member="IEvent::setProcessed" ref="a3c6dca949a20f509a58eedb31462cf16" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IEvent::setProcessed </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal method called by the system when all listeners of a particular event have called <a class="el" href="interface_i_event_source.html#abedc1e5401a7e8c762ea18a84b5609de">IEventSource::eventProcessed</a><b></b>. </p>
<p>This should not be called by client code. </p>

</div>
</div>
<a class="anchor" id="a70f85e0a61260a5e84d3e7e4e0c7ece2"></a><!-- doxytag: member="IEvent::waitProcessed" ref="a70f85e0a61260a5e84d3e7e4e0c7ece2" args="(in long timeout,[retval] out boolean result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IEvent::waitProcessed </td>
          <td>(</td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out boolean&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait until time outs, or this event is processed. </p>
<p>Event must be waitable for this operation to have described semantics, for non-waitable returns true immediately.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Maximum time to wait for event processeing, in ms; 0 = no wait, -1 = indefinite wait.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>If this event was processed before timeout. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a2df73794a587ecee06560493aa4b4e06"></a><!-- doxytag: member="IEvent::type" ref="a2df73794a587ecee06560493aa4b4e06" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="_virtual_box_8idl.html#ab869a099f4a40172d197c9adeffe4bd4">VBoxEventType</a> <a class="el" href="interface_i_event.html#a2df73794a587ecee06560493aa4b4e06">IEvent::type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Event type. </p>

</div>
</div>
<a class="anchor" id="a8ce56b1841f4756a9f8b77837e267ed1"></a><!-- doxytag: member="IEvent::source" ref="a8ce56b1841f4756a9f8b77837e267ed1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_event_source.html">IEventSource</a> <a class="el" href="interface_i_event.html#a8ce56b1841f4756a9f8b77837e267ed1">IEvent::source</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Source of this event. </p>

</div>
</div>
<a class="anchor" id="ab0b1be852bdf0359ec175e5d81b2f0b7"></a><!-- doxytag: member="IEvent::waitable" ref="ab0b1be852bdf0359ec175e5d81b2f0b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute boolean <a class="el" href="interface_i_event.html#ab0b1be852bdf0359ec175e5d81b2f0b7">IEvent::waitable</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If we can wait for this event being processed. </p>
<p>If false, <a class="el" href="interface_i_event.html#a70f85e0a61260a5e84d3e7e4e0c7ece2">waitProcessed</a><b></b> returns immediately, and <a class="el" href="interface_i_event.html#a3c6dca949a20f509a58eedb31462cf16">setProcessed</a><b></b> doesn't make sense. Non-waitable events are generally better performing, as no additional overhead associated with waitability imposed. Waitable events are needed when one need to be able to wait for particular event processed, for example for vetoable changes, or if event refers to some resource which need to be kept immutable until all consumers confirmed events. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Apr 12 2012 16:55:01 for VirtualBox Main API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
