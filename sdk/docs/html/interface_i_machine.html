<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VirtualBox Main API: IMachine Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<h1>IMachine Interface Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="IMachine" -->
<p>The <a class="el" href="interface_i_machine.html" title="The IMachine interface represents a virtual machine, or guest, created in VirtualBox.">IMachine</a> interface represents a virtual machine, or guest, created in VirtualBox.  
<a href="#_details">More...</a></p>

<p><a href="interface_i_machine-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#af28da645b00a821547d9cb8e92f8b7b0">lockMachine</a> (in <a class="el" href="interface_i_session.html">ISession</a> session, in <a class="el" href="_virtual_box_8idl.html#a5893ac36dd21da7bcd19a505205ea180">LockType</a> lockType)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks the machine for the given session to enable the caller to make changes to the machine or start the VM or control VM execution.  <a href="#af28da645b00a821547d9cb8e92f8b7b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a5f6e112de89f7e1d300738c9a055d5c9">launchVMProcess</a> (in <a class="el" href="interface_i_session.html">ISession</a> session, in wstring type, in wstring environment,[retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spawns a new process that will execute the virtual machine and obtains a shared lock on the machine for the calling session.  <a href="#a5f6e112de89f7e1d300738c9a055d5c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#af21be3d39450fb895a1547c87636d40a">setBootOrder</a> (in unsigned long position, in <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9">DeviceType</a> device)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Puts the given device to the specified position in the boot order.  <a href="#af21be3d39450fb895a1547c87636d40a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a22d5030cb11670776845fe78ed13691e">getBootOrder</a> (in unsigned long position,[retval] out <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9">DeviceType</a> device)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the device type that occupies the specified position in the boot order.  <a href="#a22d5030cb11670776845fe78ed13691e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">attachDevice</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9">DeviceType</a> type, in <a class="el" href="interface_i_medium.html">IMedium</a> medium)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attaches a device and optionally mounts a medium to the given storage controller (<a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>, identified by <em>name</em>), at the indicated port and device.  <a href="#a8e51fafec7442a48a86a59edec5ec217"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ad4f8c3614866c1fe78c30357d6e70146">attachDeviceWithoutMedium</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9">DeviceType</a> type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attaches a device and optionally mounts a medium to the given storage controller (<a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>, identified by <em>name</em>), at the indicated port and device.  <a href="#ad4f8c3614866c1fe78c30357d6e70146"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a59a8e406027e901cc260488f8617fb22">detachDevice</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detaches the device attached to a device slot of the specified bus.  <a href="#a59a8e406027e901cc260488f8617fb22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#af0e34af9e99e5884bf0b2eb297344c92">passthroughDevice</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in boolean passthrough)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the passthrough mode of an existing DVD device.  <a href="#af0e34af9e99e5884bf0b2eb297344c92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ab2883fc2f65c753bdc1d0ba22cd773c8">temporaryEjectDevice</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in boolean temporaryEject)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the behavior for guest-triggered medium eject.  <a href="#ab2883fc2f65c753bdc1d0ba22cd773c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aa31ab8471f5076792487779533a26df0">nonRotationalDevice</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in boolean nonRotational)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a flag in the device information which indicates that the medium is not based on rotational technology, i.e.  <a href="#aa31ab8471f5076792487779533a26df0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aa02655252429d66d75188bcc56e41e7d">setAutoDiscardForDevice</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in boolean discard)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a flag in the device information which indicates that the medium supports discarding unsused blocks (called trimming for SATA or unmap for SCSI devices) .This may or may not be supported by a particular drive, and is silently ignored in the latter case.  <a href="#aa02655252429d66d75188bcc56e41e7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aa8ed8a03befa534d4df3c5342bf7fcf8">setBandwidthGroupForDevice</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in <a class="el" href="interface_i_bandwidth_group.html">IBandwidthGroup</a> bandwidthGroup)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the bandwidth group of an existing storage device.  <a href="#aa8ed8a03befa534d4df3c5342bf7fcf8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a94c2637db1f0f0fe4a687a4c2c245218">setNoBandwidthGroupForDevice</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets no bandwidth group for an existing storage device.  <a href="#a94c2637db1f0f0fe4a687a4c2c245218"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a1f3da9c7f26b4c630f3989f98b58515a">unmountMedium</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in boolean force)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmounts any currently mounted medium (<a class="el" href="interface_i_medium.html">IMedium</a><b></b>, identified by the given UUID <em>id</em>) to the given storage controller (<a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>, identified by <em>name</em>), at the indicated port and device.  <a href="#a1f3da9c7f26b4c630f3989f98b58515a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a1c82306d3603e3bb40f6ab7467d4ff18">mountMedium</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device, in <a class="el" href="interface_i_medium.html">IMedium</a> medium, in boolean force)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mounts a medium (<a class="el" href="interface_i_medium.html">IMedium</a><b></b>, identified by the given UUID <em>id</em>) to the given storage controller (<a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>, identified by <em>name</em>), at the indicated port and device.  <a href="#a1c82306d3603e3bb40f6ab7467d4ff18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a23f94c1e7ed8dcd36cf38ae5c7eec9ed">getMedium</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device,[retval] out <a class="el" href="interface_i_medium.html">IMedium</a> medium)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the virtual medium attached to a device slot of the specified bus.  <a href="#a23f94c1e7ed8dcd36cf38ae5c7eec9ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#adc6e0fd49e384552fc00f26ffc8f9e17">getMediumAttachmentsOfController</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>,[retval] out <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a>[] <a class="el" href="interface_i_machine.html#aef972b7f8785c3a3f98a592a246ca4b4">mediumAttachments</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an array of medium attachments which are attached to the the controller with the given name.  <a href="#adc6e0fd49e384552fc00f26ffc8f9e17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ac4ac5f0f020063c3d238d9536c56064f">getMediumAttachment</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in long controllerPort, in long device,[retval] out <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a> attachment)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a medium attachment which corresponds to the controller with the given name, on the given port and device slot.  <a href="#ac4ac5f0f020063c3d238d9536c56064f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a2640706ef6d61ac1d430199d162035ae">attachHostPCIDevice</a> (in long hostAddress, in long desiredGuestAddress, in boolean tryToUnbind)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attaches host PCI device with the given (host) PCI address to the PCI bus of the virtual machine.  <a href="#a2640706ef6d61ac1d430199d162035ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a6b94280b4763b7522c4003b095a463d2">detachHostPCIDevice</a> (in long hostAddress)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach host PCI device from the virtual machine.  <a href="#a6b94280b4763b7522c4003b095a463d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a8b3bd5ed7b0eb7ceda6339dfa27d379e">getNetworkAdapter</a> (in unsigned long slot,[retval] out <a class="el" href="interface_i_network_adapter.html">INetworkAdapter</a> adapter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the network adapter associated with the given slot.  <a href="#a8b3bd5ed7b0eb7ceda6339dfa27d379e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#adb3aeb9186d64c6d06118daae8302dbd">addStorageController</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in <a class="el" href="_virtual_box_8idl.html#ab955ac5f95964be27366be7bbc8f3cf0">StorageBus</a> connectionType,[retval] out <a class="el" href="interface_i_storage_controller.html">IStorageController</a> controller)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a new storage controller (SCSI, SAS or SATA controller) to the machine and returns it as an instance of <a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>.  <a href="#adb3aeb9186d64c6d06118daae8302dbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a0ea4bd5091b475d5692dd0363327cb82">getStorageControllerByName</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>,[retval] out <a class="el" href="interface_i_storage_controller.html">IStorageController</a> storageController)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a storage controller with the given name.  <a href="#a0ea4bd5091b475d5692dd0363327cb82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a8bf23af3c199e1c63fbbd62354c041f3">getStorageControllerByInstance</a> (in unsigned long instance,[retval] out <a class="el" href="interface_i_storage_controller.html">IStorageController</a> storageController)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a storage controller with the given instance number.  <a href="#a8bf23af3c199e1c63fbbd62354c041f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#af6cb6937da2196d9bc13d9670c6f6eaf">removeStorageController</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a storage controller from the machine with all devices attached to it.  <a href="#af6cb6937da2196d9bc13d9670c6f6eaf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a5d4d1c7791274f8baaef6e341f029cd2">setStorageControllerBootable</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in boolean bootable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the bootable flag of the storage controller with the given name.  <a href="#a5d4d1c7791274f8baaef6e341f029cd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ad69923a471cec43bb32a9e8ad54cfcd2">getSerialPort</a> (in unsigned long slot,[retval] out <a class="el" href="interface_i_serial_port.html">ISerialPort</a> port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the serial port associated with the given slot.  <a href="#ad69923a471cec43bb32a9e8ad54cfcd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a4182d2cf6c281b63e1112f5e9f327950">getParallelPort</a> (in unsigned long slot,[retval] out <a class="el" href="interface_i_parallel_port.html">IParallelPort</a> port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the parallel port associated with the given slot.  <a href="#a4182d2cf6c281b63e1112f5e9f327950"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a56092a8c40e53f8a9560157f217e388d">getExtraDataKeys</a> ([retval] out wstring[] value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an array representing the machine-specific extra data keys which currently have values defined.  <a href="#a56092a8c40e53f8a9560157f217e388d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a1c439f06e57cdff36d5d954f02a6d3e6">getExtraData</a> (in wstring key,[retval] out wstring value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns associated machine-specific extra data.  <a href="#a1c439f06e57cdff36d5d954f02a6d3e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a79f89295518cbfcd582c9a63602f795a">setExtraData</a> (in wstring key, in wstring value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets associated machine-specific extra data.  <a href="#a79f89295518cbfcd582c9a63602f795a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#af25832baa40d8e08fc976cddbb300ca5">getCPUProperty</a> (in <a class="el" href="_virtual_box_8idl.html#a5fa1ad8b7ea677aaf75dda650d27175a">CPUPropertyType</a> property,[retval] out boolean value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the virtual CPU boolean value of the specified property.  <a href="#af25832baa40d8e08fc976cddbb300ca5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a8953644f3d8072c4270c4caf0006c2ed">setCPUProperty</a> (in <a class="el" href="_virtual_box_8idl.html#a5fa1ad8b7ea677aaf75dda650d27175a">CPUPropertyType</a> property, in boolean value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the virtual CPU boolean value of the specified property.  <a href="#a8953644f3d8072c4270c4caf0006c2ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ab54fcd6c0b8424d40a543134f251e9de">getCPUIDLeaf</a> (in unsigned long <a class="el" href="interface_i_machine.html#a8c2872f28654d4cee4e8029bf6eaec60">id</a>, out unsigned long valEax, out unsigned long valEbx, out unsigned long valEcx, out unsigned long valEdx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the virtual CPU cpuid information for the specified leaf.  <a href="#ab54fcd6c0b8424d40a543134f251e9de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#addd00ff1038502cb30b5ca52c789c0f6">setCPUIDLeaf</a> (in unsigned long <a class="el" href="interface_i_machine.html#a8c2872f28654d4cee4e8029bf6eaec60">id</a>, in unsigned long valEax, in unsigned long valEbx, in unsigned long valEcx, in unsigned long valEdx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the virtual CPU cpuid information for the specified leaf.  <a href="#addd00ff1038502cb30b5ca52c789c0f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aaac9fbfebe854059cb2be61be968c568">removeCPUIDLeaf</a> (in unsigned long <a class="el" href="interface_i_machine.html#a8c2872f28654d4cee4e8029bf6eaec60">id</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the virtual CPU cpuid leaf for the specified index.  <a href="#aaac9fbfebe854059cb2be61be968c568"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aaae582c5edb838dfa96f62a48b496fe1">removeAllCPUIDLeaves</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all the virtual CPU cpuid leaves.  <a href="#aaae582c5edb838dfa96f62a48b496fe1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a00b69a5e62700f57b2204c7649e59efb">getHWVirtExProperty</a> (in <a class="el" href="_virtual_box_8idl.html#ae90b543d84f42a1e477aafa7303079cb">HWVirtExPropertyType</a> property,[retval] out boolean value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value of the specified hardware virtualization boolean property.  <a href="#a00b69a5e62700f57b2204c7649e59efb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a4e38cff5f3af00bdb490548a82ac7b44">setHWVirtExProperty</a> (in <a class="el" href="_virtual_box_8idl.html#ae90b543d84f42a1e477aafa7303079cb">HWVirtExPropertyType</a> property, in boolean value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a new value for the specified hardware virtualization boolean property.  <a href="#a4e38cff5f3af00bdb490548a82ac7b44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves any changes to machine settings made since the session has been opened or a new machine has been created, or since the last call to <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> or <a class="el" href="interface_i_machine.html#a341ac035501a0c168ad9571bbe86eb02">discardSettings</a><b></b>.  <a href="#a2eb47e1d878566569b26893cc12bd8e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a341ac035501a0c168ad9571bbe86eb02">discardSettings</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discards any changes to the machine settings made since the session has been opened or since the last call to <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> or <a class="el" href="interface_i_machine.html#a341ac035501a0c168ad9571bbe86eb02">discardSettings</a><b></b>.  <a href="#a341ac035501a0c168ad9571bbe86eb02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#accfecb34e04b20108c7bf8b469c32d5a">unregister</a> (in <a class="el" href="_virtual_box_8idl.html#a0381acf2db95fe7b709d78553346ea1c">CleanupMode</a> cleanupMode,[retval] out <a class="el" href="interface_i_medium.html">IMedium</a>[] aMedia)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregisters a machine previously registered with <a class="el" href="interface_i_virtual_box.html#a7a67d2e6643990d72949c8d6c806ed35">IVirtualBox::registerMachine</a><b></b> and optionally do additional cleanup before the machine is unregistered.  <a href="#accfecb34e04b20108c7bf8b469c32d5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aaea5212b6af18129d7f046ca317534ba">delete</a> (in <a class="el" href="interface_i_medium.html">IMedium</a>[] aMedia,[retval] out <a class="el" href="interface_i_progress.html">IProgress</a> aProgress)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the files associated with this machine from disk.  <a href="#aaea5212b6af18129d7f046ca317534ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a05a6111b53bf9c7e725c1d03bf92b12e">export</a> (in <a class="el" href="interface_i_appliance.html">IAppliance</a> aAppliance, in wstring location,[retval] out <a class="el" href="interface_i_virtual_system_description.html">IVirtualSystemDescription</a> aDescription)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exports the machine to an OVF appliance.  <a href="#a05a6111b53bf9c7e725c1d03bf92b12e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a93d4c50ba76cf7a8930d8364961ed60e">findSnapshot</a> (in wstring nameOrId,[retval] out <a class="el" href="interface_i_snapshot.html">ISnapshot</a> snapshot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a snapshot of this machine with the given name or UUID.  <a href="#a93d4c50ba76cf7a8930d8364961ed60e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ae49562a26a94c09044d8bdb9341d836b">createSharedFolder</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, in wstring hostPath, in boolean writable, in boolean automount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new permanent shared folder by associating the given logical name with the given host path, adds it to the collection of shared folders and starts sharing it.  <a href="#ae49562a26a94c09044d8bdb9341d836b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a30e6a10490fde39a3e97e2ae1d1fa3ce">removeSharedFolder</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the permanent shared folder with the given name previously created by <a class="el" href="interface_i_machine.html#ae49562a26a94c09044d8bdb9341d836b">createSharedFolder</a><b></b> from the collection of shared folders and stops sharing it.  <a href="#a30e6a10490fde39a3e97e2ae1d1fa3ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aebbda0c226bb18cd02f01e8492bbe3a1">canShowConsoleWindow</a> ([retval] out boolean canShow)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if the VM console process can activate the console window and bring it to foreground on the desktop of the host PC.  <a href="#aebbda0c226bb18cd02f01e8492bbe3a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ada877c47a8efa8a62967f8cb0387bfbc">showConsoleWindow</a> ([retval] out long long winId)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Activates the console window and brings it to foreground on the desktop of the host PC.  <a href="#ada877c47a8efa8a62967f8cb0387bfbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a9f2fffade4b897eb659cc4602694676d">getGuestProperty</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, out wstring value, out long long timestamp, out wstring flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads an entry from the machine's guest property store.  <a href="#a9f2fffade4b897eb659cc4602694676d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a06b232cfabaf8a59657498cc7154c6a8">getGuestPropertyValue</a> (in wstring property,[retval] out wstring value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a value from the machine's guest property store.  <a href="#a06b232cfabaf8a59657498cc7154c6a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ae97f4b047477f3803a88e57d80de97ef">getGuestPropertyTimestamp</a> (in wstring property,[retval] out long long value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a property timestamp from the machine's guest property store.  <a href="#ae97f4b047477f3803a88e57d80de97ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a526521a6479eeaf3067550417a7bb888">setGuestProperty</a> (in wstring property, in wstring value, in wstring flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets, changes or deletes an entry in the machine's guest property store.  <a href="#a526521a6479eeaf3067550417a7bb888"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a86db68f492c701d4fd323cf6aab633b9">setGuestPropertyValue</a> (in wstring property, in wstring value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets, changes or deletes a value in the machine's guest property store.  <a href="#a86db68f492c701d4fd323cf6aab633b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a2b5bc248ab2a58bdab899dd0ab0b6b10">deleteGuestProperty</a> (in wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes an entry from the machine's guest property store.  <a href="#a2b5bc248ab2a58bdab899dd0ab0b6b10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a4ca2935cbe0568ead81e6c12bb04ef27">enumerateGuestProperties</a> (in wstring patterns, out wstring[] <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a>, out wstring[] value, out long long[] timestamp, out wstring[] flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a list of the guest properties matching a set of patterns along with their values, time stamps and flags.  <a href="#a4ca2935cbe0568ead81e6c12bb04ef27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a854f70590d1680516cfd2e3ff0e2d7b6">querySavedGuestScreenInfo</a> (in unsigned long screenId, out unsigned long originX, out unsigned long originY, out unsigned long width, out unsigned long height, out boolean enabled)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the guest dimensions from the saved state.  <a href="#a854f70590d1680516cfd2e3ff0e2d7b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a7cb9b422207206f4c1918427cc33304c">querySavedThumbnailSize</a> (in unsigned long screenId, out unsigned long size, out unsigned long width, out unsigned long height)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns size in bytes and dimensions in pixels of a saved thumbnail bitmap from saved state.  <a href="#a7cb9b422207206f4c1918427cc33304c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a64040195c2b42178b7288d8bc48761c4">readSavedThumbnailToArray</a> (in unsigned long screenId, in boolean BGR, out unsigned long width, out unsigned long height,[retval] out octet[] data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thumbnail is retrieved to an array of bytes in uncompressed 32-bit BGRA or RGBA format.  <a href="#a64040195c2b42178b7288d8bc48761c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ac2a706ef07c004d9d4ddba0334077550">readSavedThumbnailPNGToArray</a> (in unsigned long screenId, out unsigned long width, out unsigned long height,[retval] out octet[] data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thumbnail in PNG format is retrieved to an array of bytes.  <a href="#ac2a706ef07c004d9d4ddba0334077550"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a80465cbf8932bfa94f857cef4010f45d">querySavedScreenshotPNGSize</a> (in unsigned long screenId, out unsigned long size, out unsigned long width, out unsigned long height)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns size in bytes and dimensions of a saved PNG image of screenshot from saved state.  <a href="#a80465cbf8932bfa94f857cef4010f45d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a10bf74b011dcfee33b52c0579d7e2d70">readSavedScreenshotPNGToArray</a> (in unsigned long screenId, out unsigned long width, out unsigned long height,[retval] out octet[] data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Screenshot in PNG format is retrieved to an array of bytes.  <a href="#a10bf74b011dcfee33b52c0579d7e2d70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aa561e166e64b11450803d0d981f2f093">hotPlugCPU</a> (in unsigned long cpu)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plugs a CPU into the machine.  <a href="#aa561e166e64b11450803d0d981f2f093"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a4b7f63a54fa7ef3250a0ad05528350dd">hotUnplugCPU</a> (in unsigned long cpu)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a CPU from the machine.  <a href="#a4b7f63a54fa7ef3250a0ad05528350dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aa3dbd8f5fcb134f0c2550b612034a654">getCPUStatus</a> (in unsigned long cpu,[retval] out boolean attached)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current status of the given CPU.  <a href="#aa3dbd8f5fcb134f0c2550b612034a654"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#acc7a2f42d66a2e9781855ca6f3eb7a43">queryLogFilename</a> (in unsigned long idx,[retval] out wstring filename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries for the VM log file name of an given index.  <a href="#acc7a2f42d66a2e9781855ca6f3eb7a43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a18dba7b39651237cb87f2bb9cf3291fa">readLog</a> (in unsigned long idx, in long long offset, in long long size,[retval] out octet[] data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads the VM log file.  <a href="#a18dba7b39651237cb87f2bb9cf3291fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a21f0811ae21e028b716037f2b68c42ff">cloneTo</a> (in <a class="el" href="interface_i_machine.html">IMachine</a> target, in <a class="el" href="_virtual_box_8idl.html#a16234ad9f11c851b50869d9718b664a2">CloneMode</a> mode, in <a class="el" href="_virtual_box_8idl.html#a15b096f772b66efdc6c998d70e575fc7">CloneOptions</a>[] options,[retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a clone of this machine, either as a full clone (which means creating independent copies of the hard disk media, save states and so on), or as a linked clone (which uses its own differencing media, sharing the parent media with the source machine).  <a href="#a21f0811ae21e028b716037f2b68c42ff"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_virtual_box.html">IVirtualBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a06bb12649ae1d59be7dcf982d7a55817">parent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associated parent object.  <a href="#a06bb12649ae1d59be7dcf982d7a55817"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a2b6c9cc91c11db18c5b6b870556355f2">accessible</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether this virtual machine is currently accessible or not.  <a href="#a2b6c9cc91c11db18c5b6b870556355f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute <br class="typebreak"/>
<a class="el" href="interface_i_virtual_box_error_info.html">IVirtualBoxErrorInfo</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a81cdf161d5d9f8e3e1491802768e533a">accessError</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Error information describing the reason of machine inaccessibility.  <a href="#a81cdf161d5d9f8e3e1491802768e533a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">name</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Name of the virtual machine.  <a href="#a0f8041e0562be7a0b32be686384285f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#af19c3adad1315ceb9bdac881e545e602">description</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Description of the virtual machine.  <a href="#af19c3adad1315ceb9bdac881e545e602"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute wstringUUID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a8c2872f28654d4cee4e8029bf6eaec60">id</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">UUID of the virtual machine.  <a href="#a8c2872f28654d4cee4e8029bf6eaec60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute wstring[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a27536e99a6b64ac628a9098037ab5d7c">groups</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of machine group names of which this machine is a member.  <a href="#a27536e99a6b64ac628a9098037ab5d7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a8b78acadfe037c9153080fb055f46a7d">OSTypeId</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User-defined identifier of the Guest OS type.  <a href="#a8b78acadfe037c9153080fb055f46a7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a40e9ec512ab94e9878a1f848c51c8832">hardwareVersion</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hardware version identifier.  <a href="#a40e9ec512ab94e9878a1f848c51c8832"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute wstringUUID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ab2573dd9ec7e316b4c3115e84db9cf83">hardwareUUID</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The UUID presented to the guest via memory tables, hardware and guest properties.  <a href="#ab2573dd9ec7e316b4c3115e84db9cf83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a78fd87584b8d5e02ccdf061c12e8e299">CPUCount</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of virtual CPUs in the VM.  <a href="#a78fd87584b8d5e02ccdf061c12e8e299"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a466c25d9049510f39c71f7bd75bad63b">CPUHotPlugEnabled</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This setting determines whether VirtualBox allows CPU hotplugging for this machine.  <a href="#a466c25d9049510f39c71f7bd75bad63b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a47753f3eaff825b684018a2f88be95f6">CPUExecutionCap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Means to limit the number of CPU cycles a guest can use.  <a href="#a47753f3eaff825b684018a2f88be95f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a5bb5f057419fdc8505882ed5be4d6876">memorySize</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">System memory size in megabytes.  <a href="#a5bb5f057419fdc8505882ed5be4d6876"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#af8340bf65bbf1a384b7902cfe65a6dd5">memoryBalloonSize</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory balloon size in megabytes.  <a href="#af8340bf65bbf1a384b7902cfe65a6dd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a29c0171d96c683d579974f4a508a7cf0">pageFusionEnabled</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This setting determines whether VirtualBox allows page fusion for this machine (64 bits host only).  <a href="#a29c0171d96c683d579974f4a508a7cf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a225e13b6d6a38f1feb07d9773548e14e">VRAMSize</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Video memory size in megabytes.  <a href="#a225e13b6d6a38f1feb07d9773548e14e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a29f8081e07baba47014d0aa1661a6de8">accelerate3DEnabled</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This setting determines whether VirtualBox allows this machine to make use of the 3D graphics support available on the host.  <a href="#a29f8081e07baba47014d0aa1661a6de8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a0bbb876d9ad8dbd1b312bc6d2d235d52">accelerate2DVideoEnabled</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This setting determines whether VirtualBox allows this machine to make use of the 2D video acceleration support available on the host.  <a href="#a0bbb876d9ad8dbd1b312bc6d2d235d52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#af0ffb20e866dfb40df1464def112f778">monitorCount</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of virtual monitors.  <a href="#af0ffb20e866dfb40df1464def112f778"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a6c074dd14205c40258cabe8371d7cf38">VideoCaptureEnabled</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This setting determines whether VirtualBox uses video recording to record VM session.  <a href="#a6c074dd14205c40258cabe8371d7cf38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a2a27190c7ff1a7c1f904b63755405291">VideoCaptureFile</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This setting determines what filename VirtualBox uses to save the recorded content.  <a href="#a2a27190c7ff1a7c1f904b63755405291"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ae040b6ed6411f583298902d6f312f558">VideoCaptureWidth</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This setting determines what should be the horizontal resolution of recorded video.  <a href="#ae040b6ed6411f583298902d6f312f558"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a03fed1419ff7c4fa8194a28bfb87fbf8">VideoCaptureHeight</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This setting determines what should be the vertical resolution of recorded video.  <a href="#a03fed1419ff7c4fa8194a28bfb87fbf8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_b_i_o_s_settings.html">IBIOSSettings</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a72dd7fe9c6a11670842c43d3e4b5736b">BIOSSettings</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Object containing all BIOS settings.  <a href="#a72dd7fe9c6a11670842c43d3e4b5736b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute <a class="el" href="_virtual_box_8idl.html#afddb85483810aea160a6bf2c90259b55">FirmwareType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#adc5c21a35eabc1db1d3157878a6d9ec6">firmwareType</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of firmware (such as legacy BIOS or EFI), used for initial bootstrap in this VM.  <a href="#adc5c21a35eabc1db1d3157878a6d9ec6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute <a class="el" href="_virtual_box_8idl.html#ae904ea9e2892b3cb117b076fdf4c8897">PointingHIDType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a169cccf5417aa6c90b4515f45b919d2e">pointingHIDType</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of pointing HID (such as mouse or tablet) used in this VM.  <a href="#a169cccf5417aa6c90b4515f45b919d2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute <a class="el" href="_virtual_box_8idl.html#af8b91ad2ad35847326c7d9d4c9587142">KeyboardHIDType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a837c6f223122e587ff00027346a9f148">keyboardHIDType</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of keyboard HID used in this VM.  <a href="#a837c6f223122e587ff00027346a9f148"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a80240bbec6fb99a78aa903c5e4047287">HPETEnabled</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This attribute controls if High Precision Event Timer (HPET) is enabled in this VM.  <a href="#a80240bbec6fb99a78aa903c5e4047287"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute <a class="el" href="_virtual_box_8idl.html#a0c8eff86d82f71a0a7f2e99a4a702ffa">ChipsetType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ad027bca4612b7bec68db5eb591230e9e">chipsetType</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Chipset type used in this VM.  <a href="#ad027bca4612b7bec68db5eb591230e9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#adfcf2b4359a54f318fa9f17ee521fd50">snapshotFolder</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Full path to the directory used to store snapshot data (differencing media and saved state files) of this machine.  <a href="#adfcf2b4359a54f318fa9f17ee521fd50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_v_r_d_e_server.html">IVRDEServer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a74fe661f18e88069711241ca227c1708">VRDEServer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">VirtualBox Remote Desktop Extension (VRDE) server object.  <a href="#a74fe661f18e88069711241ca227c1708"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ae034d22cc2d2dc4998337b945f772251">emulatedUSBWebcameraEnabled</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a31970f365eecc56cbf754eb0b1cf51a5">emulatedUSBCardReaderEnabled</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute <br class="typebreak"/>
<a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a>[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aef972b7f8785c3a3f98a592a246ca4b4">mediumAttachments</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of media attached to this machine.  <a href="#aef972b7f8785c3a3f98a592a246ca4b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_u_s_b_controller.html">IUSBController</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a8894b6628a62bffc1394c4d09c0dbb6d">USBController</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associated USB controller object.  <a href="#a8894b6628a62bffc1394c4d09c0dbb6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_audio_adapter.html">IAudioAdapter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a3f283749ee3227e25c624298a57976e9">audioAdapter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associated audio adapter, always present.  <a href="#a3f283749ee3227e25c624298a57976e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute <br class="typebreak"/>
<a class="el" href="interface_i_storage_controller.html">IStorageController</a>[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ac5638e205ed8f8a1473d3b866e9a7d4f">storageControllers</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of storage controllers attached to this machine.  <a href="#ac5638e205ed8f8a1473d3b866e9a7d4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a7e7b7939c050afa7475e249e06961e75">settingsFilePath</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Full name of the file containing machine settings data.  <a href="#a7e7b7939c050afa7475e249e06961e75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a7fa04613f860573400ba570fcf80f3ef">settingsModified</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether the settings of this machine have been modified (but neither yet saved nor discarded).  <a href="#a7fa04613f860573400ba570fcf80f3ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="_virtual_box_8idl.html#ac82c179a797c0d7c249d1b98a8e3aa8f">SessionState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aecc00e3c014d4548a025e4eafff7056e">sessionState</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current session state for this machine.  <a href="#aecc00e3c014d4548a025e4eafff7056e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a7f8692397b0743822a9be4dd81be9019">sessionType</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of the session.  <a href="#a7f8692397b0743822a9be4dd81be9019"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a7380f79a10f9813dbced54f51004c6b5">sessionPID</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identifier of the session process.  <a href="#a7380f79a10f9813dbced54f51004c6b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="_virtual_box_8idl.html#a80b08f71210afe16038e904a656ed9eb">MachineState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a9653e9d996d60fc54e8bed22179d92b2">state</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current execution state of this machine.  <a href="#a9653e9d996d60fc54e8bed22179d92b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a3a96e177095b0f13c2fc43f425d9a45d">lastStateChange</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time stamp of the last execution state change, in milliseconds since 1970-01-01 UTC.  <a href="#a3a96e177095b0f13c2fc43f425d9a45d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a6bf84094ff47ad0f8f2517ee513eed02">stateFilePath</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Full path to the file that stores the execution state of the machine when it is in the <a class="el" href="_virtual_box_8idl.html#a80b08f71210afe16038e904a656ed9ebac8fa7577db141baf9cc06279665f122b">MachineState_Saved</a><b></b> state.  <a href="#a6bf84094ff47ad0f8f2517ee513eed02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a27636df01fde10102799eec13416ab51">logFolder</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Full path to the folder that stores a set of rotated log files recorded during machine execution.  <a href="#a27636df01fde10102799eec13416ab51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_snapshot.html">ISnapshot</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ac785dbe04eccc0793d949d6940202767">currentSnapshot</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current snapshot of this machine.  <a href="#ac785dbe04eccc0793d949d6940202767"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a1946d487a58f17cf4ee78a28c64a50da">snapshotCount</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of snapshots taken on this machine.  <a href="#a1946d487a58f17cf4ee78a28c64a50da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a141d87506c33bd09d7fad144ca52c871">currentStateModified</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if the current state of the machine is not identical to the state stored in the current snapshot.  <a href="#a141d87506c33bd09d7fad144ca52c871"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute <a class="el" href="interface_i_shared_folder.html">ISharedFolder</a>[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ab9d48e83d2a8b245afa00116b1e7ca37">sharedFolders</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Collection of shared folders for this machine (permanent shared folders).  <a href="#ab9d48e83d2a8b245afa00116b1e7ca37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute <a class="el" href="_virtual_box_8idl.html#a096d8cfa9dea55360b7d50c70176a222">ClipboardMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ab21aa593375c45dcd5a7b4c3a2a73b5f">clipboardMode</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Synchronization mode between the host OS clipboard and the guest OS clipboard.  <a href="#ab21aa593375c45dcd5a7b4c3a2a73b5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute <a class="el" href="_virtual_box_8idl.html#a37d006b98a1330f12bc97f781d87b346">DragAndDropMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ab72d980217139256ae5601d2e6350d2a">dragAndDropMode</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Which mode is allowed for drag'n'drop.  <a href="#ab72d980217139256ae5601d2e6350d2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ae173701527dc449099b9681da27999ff">guestPropertyNotificationPatterns</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A comma-separated list of simple glob patterns.  <a href="#ae173701527dc449099b9681da27999ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a662d92a1c47ac75f15a4660ae5247d22">teleporterEnabled</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When set to <em>true</em>, the virtual machine becomes a target teleporter the next time it is powered on.  <a href="#a662d92a1c47ac75f15a4660ae5247d22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a45fb6bfa8fc01e46728d3c7ee716a237">teleporterPort</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The TCP port the target teleporter will listen for incoming teleportations on.  <a href="#a45fb6bfa8fc01e46728d3c7ee716a237"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a0f8a33069ddcde81ba6928f11584cb3b">teleporterAddress</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The address the target teleporter will listen on.  <a href="#a0f8a33069ddcde81ba6928f11584cb3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a7df9bcd55c58f6565e20833e50643e79">teleporterPassword</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The password to check for on the target teleporter.  <a href="#a7df9bcd55c58f6565e20833e50643e79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute <a class="el" href="_virtual_box_8idl.html#af7bf1134499ce00177105e69908fba29">FaultToleranceState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a2ab837621c5d3770b234c8d3b695cc0c">faultToleranceState</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fault tolerance state; disabled, source or target.  <a href="#a2ab837621c5d3770b234c8d3b695cc0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a97d9e6325ba7778568ce7142a7d246f7">faultTolerancePort</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The TCP port the fault tolerance source or target will use for communication.  <a href="#a97d9e6325ba7778568ce7142a7d246f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a3cd50b855a14f679f863f0f31a9a201e">faultToleranceAddress</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The address the fault tolerance source or target.  <a href="#a3cd50b855a14f679f863f0f31a9a201e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a09574d93988af20a756e702429737e57">faultTolerancePassword</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The password to check for on the standby VM.  <a href="#a09574d93988af20a756e702429737e57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#acf5c1a4cdeb81e28f33b92efad526f58">faultToleranceSyncInterval</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The interval in ms used for syncing the state between source and target.  <a href="#acf5c1a4cdeb81e28f33b92efad526f58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#ae1ec62f64a126aa9645ba55e78089f6e">RTCUseUTC</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When set to <em>true</em>, the RTC device of the virtual machine will run in UTC time, otherwise in local time.  <a href="#ae1ec62f64a126aa9645ba55e78089f6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a9999c5c9eb8eecac98a45bde62fc3bce">IOCacheEnabled</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When set to <em>true</em>, the builtin I/O cache of the virtual machine will be enabled.  <a href="#a9999c5c9eb8eecac98a45bde62fc3bce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a596ae3cdd7eea9f92c79dddd4c738f6f">IOCacheSize</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum size of the I/O cache in MB.  <a href="#a596ae3cdd7eea9f92c79dddd4c738f6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute <br class="typebreak"/>
<a class="el" href="interface_i_p_c_i_device_attachment.html">IPCIDeviceAttachment</a>[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a38a5c9476de084724b89fda4ea26ae12">PCIDeviceAssignments</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of PCI devices assigned to this machine, to get list of all PCI devices attached to the machine use <a class="el" href="interface_i_console.html#a6d41c200e67a37cdbc9c270317831774">IConsole::attachedPCIDevices</a><b></b> attribute, as this attribute is intended to list only devices additional to what described in virtual hardware config.  <a href="#a38a5c9476de084724b89fda4ea26ae12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">readonly attribute <br class="typebreak"/>
<a class="el" href="interface_i_bandwidth_control.html">IBandwidthControl</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a15c8725d2d0bf1bc99d3fc2048dfe98a">bandwidthControl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bandwidth control manager.  <a href="#a15c8725d2d0bf1bc99d3fc2048dfe98a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a08618a97a181c10f9113b3844d6ae577">tracingEnabled</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables the tracing facility in the VMM (including PDM devices + drivers).  <a href="#a08618a97a181c10f9113b3844d6ae577"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a2f4ec9af3f5705deed580ccba5a2e142">tracingConfig</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tracepoint configuration to apply at startup when <a class="el" href="interface_i_machine.html#a08618a97a181c10f9113b3844d6ae577">IMachine::tracingEnabled</a><b></b> is true.  <a href="#a2f4ec9af3f5705deed580ccba5a2e142"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#acfa33f6952f420c0163dd2eefccc62ed">allowTracingToAccessVM</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables tracepoints in PDM devices and drivers to use the VMCPU or VM structures when firing off trace points.  <a href="#acfa33f6952f420c0163dd2eefccc62ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#aca5154cad0ba95af8d3ce358571222bc">autostartEnabled</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables autostart of the VM during system boot.  <a href="#aca5154cad0ba95af8d3ce358571222bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a9d371d975c607f0d3f81ab57459149df">autostartDelay</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of seconds to wait until the VM should be started during system boot.  <a href="#a9d371d975c607f0d3f81ab57459149df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">attribute <a class="el" href="_virtual_box_8idl.html#a03ad7f2af3ceb813a15cdc614db93c73">AutostopType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_machine.html#a724adf774f12d25744bbac488c7fe26e">autostopType</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Action type to do when the system is shutting down.  <a href="#a724adf774f12d25744bbac488c7fe26e"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The <a class="el" href="interface_i_machine.html" title="The IMachine interface represents a virtual machine, or guest, created in VirtualBox.">IMachine</a> interface represents a virtual machine, or guest, created in VirtualBox. </p>
<p>This interface is used in two contexts. First of all, a collection of objects implementing this interface is stored in the <a class="el" href="interface_i_virtual_box.html#aad58f4626e004e340e418dae6f4cd1c0">IVirtualBox::machines</a><b></b> attribute which lists all the virtual machines that are currently registered with this VirtualBox installation. Also, once a session has been opened for the given virtual machine (e.g. the virtual machine is running), the machine object associated with the open session can be queried from the session object; see <a class="el" href="interface_i_session.html">ISession</a><b></b> for details.</p>
<p>The main role of this interface is to expose the settings of the virtual machine and provide methods to change various aspects of the virtual machine's configuration. For machine objects stored in the <a class="el" href="interface_i_virtual_box.html#aad58f4626e004e340e418dae6f4cd1c0">IVirtualBox::machines</a><b></b> collection, all attributes are read-only unless explicitly stated otherwise in individual attribute and method descriptions.</p>
<p>In order to change a machine setting, a session for this machine must be opened using one of the <a class="el" href="interface_i_machine.html#af28da645b00a821547d9cb8e92f8b7b0">IMachine::lockMachine</a><b></b> or <a class="el" href="interface_i_machine.html#a5f6e112de89f7e1d300738c9a055d5c9">IMachine::launchVMProcess</a><b></b> methods. After the machine has been successfully locked for a session, a mutable machine object needs to be queried from the session object and then the desired settings changes can be applied to the returned object using <a class="el" href="interface_i_machine.html" title="The IMachine interface represents a virtual machine, or guest, created in VirtualBox.">IMachine</a> attributes and methods. See the <a class="el" href="interface_i_session.html">ISession</a><b></b> interface description for more information about sessions.</p>
<p>Note that <a class="el" href="interface_i_machine.html" title="The IMachine interface represents a virtual machine, or guest, created in VirtualBox.">IMachine</a> does not provide methods to control virtual machine execution (such as start the machine, or power it down) -- these methods are grouped in a separate interface called <a class="el" href="interface_i_console.html">IConsole</a><b></b>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="interface_i_session.html">ISession</a><b></b>, <a class="el" href="interface_i_console.html">IConsole</a><b></b></dd></dl>
<dl class="user"><dt><b>Interface ID:</b></dt><dd><code>{22781AF3-1C96-4126-9EDF-67A020E0E858}</code> </dd></dl>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af28da645b00a821547d9cb8e92f8b7b0"></a><!-- doxytag: member="IMachine::lockMachine" ref="af28da645b00a821547d9cb8e92f8b7b0" args="(in ISession session, in LockType lockType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::lockMachine </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="interface_i_session.html">ISession</a>&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#a5893ac36dd21da7bcd19a505205ea180">LockType</a>&nbsp;</td>
          <td class="paramname"> <em>lockType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locks the machine for the given session to enable the caller to make changes to the machine or start the VM or control VM execution. </p>
<p>There are two ways to lock a machine for such uses:</p>
<ul>
<li>
<p class="startli">If you want to make changes to the machine settings, you must obtain an exclusive write lock on the machine by setting <em>lockType</em> to <code>Write</code>.</p>
<p>This will only succeed if no other process has locked the machine to prevent conflicting changes. Only after an exclusive write lock has been obtained using this method, one can change all VM settings or execute the VM in the process space of the session object. (Note that the latter is only of interest if you actually want to write a new front-end for virtual machines; but this API gets called internally by the existing front-ends such as VBoxHeadless and the VirtualBox GUI to acquire a write lock on the machine that they are running.)</p>
<p class="endli">On success, write-locking the machine for a session creates a second copy of the <a class="el" href="interface_i_machine.html" title="The IMachine interface represents a virtual machine, or guest, created in VirtualBox.">IMachine</a> object. It is this second object upon which changes can be made; in VirtualBox terminology, the second copy is "mutable". It is only this second, mutable machine object upon which you can call methods that change the machine state. After having called this method, you can obtain this second, mutable machine object using the <a class="el" href="interface_i_session.html#a83d8f53d35e522599b192cac168c3495">ISession::machine</a><b></b> attribute.  </p>
</li>
<li>
<p class="startli">If you only want to check the machine state or control machine execution without actually changing machine settings (e.g. to get access to VM statistics or take a snapshot or save the machine state), then set the <em>lockType</em> argument to <code>Shared</code>.</p>
<p>If no other session has obtained a lock, you will obtain an exclusive write lock as described above. However, if another session has already obtained such a lock, then a link to that existing session will be established which allows you to control that existing session.</p>
<p class="endli">To find out which type of lock was obtained, you can inspect <a class="el" href="interface_i_session.html#ac3ce0abc5951d6e244c456518d7574b1">ISession::type</a><b></b>, which will have been set to either <code>WriteLock</code> or <code>Shared</code>.  </p>
</li>
</ul>
<p>In either case, you can get access to the <a class="el" href="interface_i_console.html">IConsole</a><b></b> object which controls VM execution.</p>
<p>Also in all of the above cases, one must always call <a class="el" href="interface_i_session.html#a87571b3c87d705ee013b24f135f43715">ISession::unlockMachine</a><b></b> to release the lock on the machine, or the machine's state will eventually be set to "Aborted".</p>
<p>To change settings on a machine, the following sequence is typically performed:</p>
<ol>
<li>
Call this method to obtain an exclusive write lock for the current session. </li>
<li>
Obtain a mutable <a class="el" href="interface_i_machine.html" title="The IMachine interface represents a virtual machine, or guest, created in VirtualBox.">IMachine</a> object from <a class="el" href="interface_i_session.html#a83d8f53d35e522599b192cac168c3495">ISession::machine</a><b></b>. </li>
<li>
Change the settings of the machine by invoking <a class="el" href="interface_i_machine.html" title="The IMachine interface represents a virtual machine, or guest, created in VirtualBox.">IMachine</a> methods. </li>
<li>
Call <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">IMachine::saveSettings</a><b></b>. </li>
<li>
Release the write lock by calling <a class="el" href="interface_i_session.html#a87571b3c87d705ee013b24f135f43715">ISession::unlockMachine</a><b></b>. </li>
</ol>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>Session object for which the machine will be locked.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lockType</em>&nbsp;</td><td>If set to <code>Write</code>, then attempt to acquire an exclusive write lock or fail. If set to <code>Shared</code>, then either acquire an exclusive write lock or establish a link to an existing session.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_UNEXPECTED </td><td>Virtual machine not registered.   </td></tr>
<tr>
<td>E_ACCESSDENIED </td><td>Process not started by OpenRemoteSession.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Session already open or being opened.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga20b372463e8e5a2b0474fbb0e2d70c4e">VBOX_E_VM_ERROR </a> </td><td>Failed to assign machine to session.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5f6e112de89f7e1d300738c9a055d5c9"></a><!-- doxytag: member="IMachine::launchVMProcess" ref="a5f6e112de89f7e1d300738c9a055d5c9" args="(in ISession session, in wstring type, in wstring environment,[retval] out IProgress progress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::launchVMProcess </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="interface_i_session.html">ISession</a>&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>environment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&nbsp;</td>
          <td class="paramname"> <em>progress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Spawns a new process that will execute the virtual machine and obtains a shared lock on the machine for the calling session. </p>
<p>If launching the VM succeeds, the new VM process will create its own session and write-lock the machine for it, preventing conflicting changes from other processes. If the machine is already locked (because it is already running or because another session has a write lock), launching the VM process will therefore fail. Reversely, future attempts to obtain a write lock will also fail while the machine is running.</p>
<p>The caller's session object remains separate from the session opened by the new VM process. It receives its own <a class="el" href="interface_i_console.html">IConsole</a><b></b> object which can be used to control machine execution, but it cannot be used to change all VM settings which would be available after a <a class="el" href="interface_i_machine.html#af28da645b00a821547d9cb8e92f8b7b0">lockMachine</a><b></b> call.</p>
<p>The caller must eventually release the session's shared lock by calling <a class="el" href="interface_i_session.html#a87571b3c87d705ee013b24f135f43715">ISession::unlockMachine</a><b></b> on the local session object once this call has returned. However, the session's state (see <a class="el" href="interface_i_session.html#aac4763cc59a693a81170ed9d1118d571">ISession::state</a><b></b>) will not return to "Unlocked" until the remote session has also unlocked the machine (i.e. the machine has stopped running).</p>
<p>Launching a VM process can take some time (a new VM is started in a new process, for which memory and other resources need to be set up). Because of this, an <a class="el" href="interface_i_progress.html">IProgress</a><b></b> object is returned to allow the caller to wait for this asynchronous operation to be completed. Until then, the caller's session object remains in the "Unlocked" state, and its <a class="el" href="interface_i_session.html#a83d8f53d35e522599b192cac168c3495">ISession::machine</a><b></b> and <a class="el" href="interface_i_session.html#a9e36ef0b77cc8ef17fbe480f39492fad">ISession::console</a><b></b> attributes cannot be accessed. It is recommended to use <a class="el" href="interface_i_progress.html#a77f58c52e91008021222943dccff35b1">IProgress::waitForCompletion</a><b></b> or similar calls to wait for completion. Completion is signalled when the VM is powered on. If launching the VM fails, error messages can be queried via the progress object, if available.</p>
<p>The progress object will have at least 2 sub-operations. The first operation covers the period up to the new VM process calls powerUp. The subsequent operations mirror the <a class="el" href="interface_i_console.html#a0191f0ffb739504065c05f6e33a65a7c">IConsole::powerUp</a><b></b> progress object. Because <a class="el" href="interface_i_console.html#a0191f0ffb739504065c05f6e33a65a7c">IConsole::powerUp</a><b></b> may require some extra sub-operations, the <a class="el" href="interface_i_progress.html#a38681d42e827d029c89587269ab76845">IProgress::operationCount</a><b></b> may change at the completion of operation.</p>
<p>For details on the teleportation progress operation, see <a class="el" href="interface_i_console.html#a0191f0ffb739504065c05f6e33a65a7c">IConsole::powerUp</a><b></b>.</p>
<p>The <em>environment</em> argument is a string containing definitions of environment variables in the following format: </p>
<pre>
        NAME[=VALUE]<br/>

        NAME[=VALUE]<br/>

        ...
        </pre><p> where <code>\n</code> is the new line character. These environment variables will be appended to the environment of the VirtualBox server process. If an environment variable exists both in the server process and in this list, the value from this list takes precedence over the server's variable. If the value of the environment variable is omitted, this variable will be removed from the resulting environment. If the environment string is <code>null</code> or empty, the server environment is inherited by the started process as is.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>Client session object to which the VM process will be connected (this must be in "Unlocked" state).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Front-end to use for the new VM process. The following are currently supported: </p>
<ul>
<li>
<code>"gui"</code>: VirtualBox Qt GUI front-end </li>
<li>
<code>"headless"</code>: VBoxHeadless (VRDE Server) front-end </li>
<li>
<code>"sdl"</code>: VirtualBox SDL front-end </li>
<li>
<code>"emergencystop"</code>: reserved value, used for aborting the currently running VM or session owner. In this case the <em>session</em> parameter may be <code>null</code> (if it is non-null it isn't used in any way), and the <em>progress</em> return value will be always <code>null</code>. The operation completes immediately. </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>environment</em>&nbsp;</td><td>Environment to pass to the VM process.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>progress</em>&nbsp;</td><td>Progress object to track the operation completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_UNEXPECTED </td><td>Virtual machine not registered.   </td></tr>
<tr>
<td>E_INVALIDARG </td><td>Invalid session type <em>type</em>.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga80982f93e26785a807034131de6cfba5">VBOX_E_OBJECT_NOT_FOUND </a> </td><td>No machine matching <em>machineId</em> found.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Session already open or being opened.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga95e965b219ae7d16a8dee5eca6267ce5">VBOX_E_IPRT_ERROR </a> </td><td>Launching process for machine failed.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga20b372463e8e5a2b0474fbb0e2d70c4e">VBOX_E_VM_ERROR </a> </td><td>Failed to assign machine to session.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="af21be3d39450fb895a1547c87636d40a"></a><!-- doxytag: member="IMachine::setBootOrder" ref="af21be3d39450fb895a1547c87636d40a" args="(in unsigned long position, in DeviceType device)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setBootOrder </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9">DeviceType</a>&nbsp;</td>
          <td class="paramname"> <em>device</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Puts the given device to the specified position in the boot order. </p>
<p>To indicate that no device is associated with the given position, <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9adcea7b56c801ff3aecd5e54d0f24c8cb">DeviceType_Null</a><b></b> should be used.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>setHardDiskBootOrder(), setNetworkBootOrder()</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Position in the boot order (<code>1</code> to the total number of devices the machine can boot from, as returned by <a class="el" href="interface_i_system_properties.html#a056418a5095fdb892039b01f9521feb0">ISystemProperties::maxBootPosition</a><b></b>).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>The type of the device used to boot at the given position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>Boot <em>position</em> out of range.   </td></tr>
<tr>
<td>E_NOTIMPL </td><td>Booting from USB <em>device</em> currently not supported.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a22d5030cb11670776845fe78ed13691e"></a><!-- doxytag: member="IMachine::getBootOrder" ref="a22d5030cb11670776845fe78ed13691e" args="(in unsigned long position,[retval] out DeviceType device)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getBootOrder </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9">DeviceType</a>&nbsp;</td>
          <td class="paramname"> <em>device</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the device type that occupies the specified position in the boot order. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>[remove?] If the machine can have more than one device of the returned type (such as hard disks), then a separate method should be used to retrieve the individual device that occupies the given position.</dd></dl>
<p>If here are no devices at the given position, then <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9adcea7b56c801ff3aecd5e54d0f24c8cb">DeviceType_Null</a><b></b> is returned.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>getHardDiskBootOrder(), getNetworkBootOrder()</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>Position in the boot order (<code>1</code> to the total number of devices the machine can boot from, as returned by <a class="el" href="interface_i_system_properties.html#a056418a5095fdb892039b01f9521feb0">ISystemProperties::maxBootPosition</a><b></b>).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>Device at the given position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>Boot <em>position</em> out of range.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8e51fafec7442a48a86a59edec5ec217"></a><!-- doxytag: member="IMachine::attachDevice" ref="a8e51fafec7442a48a86a59edec5ec217" args="(in wstring name, in long controllerPort, in long device, in DeviceType type, in IMedium medium)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::attachDevice </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9">DeviceType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="interface_i_medium.html">IMedium</a>&nbsp;</td>
          <td class="paramname"> <em>medium</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attaches a device and optionally mounts a medium to the given storage controller (<a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>, identified by <em>name</em>), at the indicated port and device. </p>
<p>This method is intended for managing storage devices in general while a machine is powered off. It can be used to attach and detach fixed and removable media. The following kind of media can be attached to a machine:</p>
<ul>
<li>
For fixed and removable media, you can pass in a medium that was previously opened using <a class="el" href="interface_i_virtual_box.html#ae67fffa98f9a73b7f6b4365978658d9e">IVirtualBox::openMedium</a><b></b>.  </li>
<li>
Only for storage devices supporting removable media (such as DVDs and floppies), you can also specify a null pointer to indicate an empty drive or one of the medium objects listed in the <a class="el" href="interface_i_host.html#a285b1b89c35b67a0bb52b547f5d3ebb3">IHost::DVDDrives</a><b></b> and <a class="el" href="interface_i_host.html#ade0e3923823c0c8d96e7eac39748122c">IHost::floppyDrives</a><b></b> arrays to indicate a host drive. For removable devices, you can also use <a class="el" href="interface_i_machine.html#a1c82306d3603e3bb40f6ab7467d4ff18">IMachine::mountMedium</a><b></b> to change the media while the machine is running.  </li>
</ul>
<p>In a VM's default configuration of virtual machines, the secondary master of the IDE controller is used for a CD/DVD drive.</p>
<p>After calling this returns successfully, a new instance of <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a><b></b> will appear in the machine's list of medium attachments (see <a class="el" href="interface_i_machine.html#aef972b7f8785c3a3f98a592a246ca4b4">IMachine::mediumAttachments</a><b></b>).</p>
<p>See <a class="el" href="interface_i_medium.html">IMedium</a><b></b> and <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a><b></b> for more information about attaching media.</p>
<p>The specified device slot must not have a device attached to it, or this method will fail.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the storage controller to attach the device to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>controllerPort</em>&nbsp;</td><td>Port to attach the device to. For an IDE controller, 0 specifies the primary controller and 1 specifies the secondary controller. For a SCSI controller, this must range from 0 to 15; for a SATA controller, from 0 to 29; for an SAS controller, from 0 to 7.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>Device slot in the given port to attach the device to. This is only relevant for IDE controllers, for which 0 specifies the master device and 1 specifies the slave device. For all other controller types, this must be 0.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Device type of the attached device. For media opened by <a class="el" href="interface_i_virtual_box.html#ae67fffa98f9a73b7f6b4365978658d9e">IVirtualBox::openMedium</a><b></b>, this must match the device type specified there.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>medium</em>&nbsp;</td><td>Medium to mount or <code>null</code> for an empty drive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>SATA device, SATA port, IDE port or IDE slot out of range, or file or UUID not found.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Machine must be registered before media can be attached.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Invalid machine state.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga81aa5d056e6fdac2d4f2fc4089957253">VBOX_E_OBJECT_IN_USE </a> </td><td>A medium is already attached to this or another virtual machine.   </td></tr>
</table>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>You cannot attach a device to a newly created machine until this machine's settings are saved to disk using <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b>.</dd>
<dd>
If the medium is being attached indirectly, a new differencing medium will implicitly be created for it and attached instead. If the changes made to the machine settings (including this indirect attachment) are later cancelled using <a class="el" href="interface_i_machine.html#a341ac035501a0c168ad9571bbe86eb02">discardSettings</a><b></b>, this implicitly created differencing medium will implicitly be deleted. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4f8c3614866c1fe78c30357d6e70146"></a><!-- doxytag: member="IMachine::attachDeviceWithoutMedium" ref="ad4f8c3614866c1fe78c30357d6e70146" args="(in wstring name, in long controllerPort, in long device, in DeviceType type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::attachDeviceWithoutMedium </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#ad258d4c51629346fceac4679b3209ad9">DeviceType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attaches a device and optionally mounts a medium to the given storage controller (<a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>, identified by <em>name</em>), at the indicated port and device. </p>
<p>This method is intended for managing storage devices in general while a machine is powered off. It can be used to attach and detach fixed and removable media. The following kind of media can be attached to a machine: </p>
<ul>
<li>
For fixed and removable media, you can pass in a medium that was previously opened using <a class="el" href="interface_i_virtual_box.html#ae67fffa98f9a73b7f6b4365978658d9e">IVirtualBox::openMedium</a><b></b>.  </li>
<li>
Only for storage devices supporting removable media (such as DVDs and floppies) with an empty drive or one of the medium objects listed in the <a class="el" href="interface_i_host.html#a285b1b89c35b67a0bb52b547f5d3ebb3">IHost::DVDDrives</a><b></b> and <a class="el" href="interface_i_host.html#ade0e3923823c0c8d96e7eac39748122c">IHost::floppyDrives</a><b></b> arrays to indicate a host drive. For removable devices, you can also use <a class="el" href="interface_i_machine.html#a1c82306d3603e3bb40f6ab7467d4ff18">IMachine::mountMedium</a><b></b> to change the media while the machine is running.  </li>
</ul>
<p>In a VM's default configuration of virtual machines, the secondary master of the IDE controller is used for a CD/DVD drive. <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a><b></b> will appear in the machine's list of medium attachments (see <a class="el" href="interface_i_machine.html#aef972b7f8785c3a3f98a592a246ca4b4">IMachine::mediumAttachments</a><b></b>).</p>
<p>See <a class="el" href="interface_i_medium.html">IMedium</a><b></b> and <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a><b></b> for more information about attaching media.</p>
<p>The specified device slot must not have a device attached to it, or this method will fail.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the storage controller to attach the device to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>controllerPort</em>&nbsp;</td><td>Port to attach the device to. For an IDE controller, 0 specifies the primary controller and 1 specifies the secondary controller. For a SCSI controller, this must range from 0 to 15; for a SATA controller, from 0 to 29; for an SAS controller, from 0 to 7.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>Device slot in the given port to attach the device to. This is only relevant for IDE controllers, for which 0 specifies the master device and 1 specifies the slave device. For all other controller types, this must be 0.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Device type of the attached device. For media opened by <a class="el" href="interface_i_virtual_box.html#ae67fffa98f9a73b7f6b4365978658d9e">IVirtualBox::openMedium</a><b></b>, this must match the device type specified there.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>SATA device, SATA port, IDE port or IDE slot out of range, or file or UUID not found.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Machine must be registered before media can be attached.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Invalid machine state.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga81aa5d056e6fdac2d4f2fc4089957253">VBOX_E_OBJECT_IN_USE </a> </td><td>A medium is already attached to this or another virtual machine.   </td></tr>
</table>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>You cannot attach a device to a newly created machine until this machine's settings are saved to disk using <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b>.</dd>
<dd>
If the medium is being attached indirectly, a new differencing medium will implicitly be created for it and attached instead. If the changes made to the machine settings (including this indirect attachment) are later cancelled using <a class="el" href="interface_i_machine.html#a341ac035501a0c168ad9571bbe86eb02">discardSettings</a><b></b>, this implicitly created differencing medium will implicitly be deleted. </dd></dl>

</div>
</div>
<a class="anchor" id="a59a8e406027e901cc260488f8617fb22"></a><!-- doxytag: member="IMachine::detachDevice" ref="a59a8e406027e901cc260488f8617fb22" args="(in wstring name, in long controllerPort, in long device)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::detachDevice </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>device</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detaches the device attached to a device slot of the specified bus. </p>
<p>Detaching the device from the virtual machine is deferred. This means that the medium remains associated with the machine when this method returns and gets actually de-associated only after a successful <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> call. See <a class="el" href="interface_i_medium.html">IMedium</a><b></b> for more detailed information about attaching media.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the storage controller to detach the medium from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>controllerPort</em>&nbsp;</td><td>Port number to detach the medium from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>Device slot number to detach the medium from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Attempt to detach medium from a running virtual machine.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga80982f93e26785a807034131de6cfba5">VBOX_E_OBJECT_NOT_FOUND </a> </td><td>No medium attached to given slot/bus.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#gaa4ba5e3fab3fe318c790d9d0b500c102">VBOX_E_NOT_SUPPORTED </a> </td><td>Medium format does not support storage deletion (only for implicitly created differencing media, should not happen).   </td></tr>
</table>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>You cannot detach a device from a running machine.</dd>
<dd>
Detaching differencing media implicitly created by <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">attachDevice</a><b></b> for the indirect attachment using this method will <b>not</b> implicitly delete them. The <a class="el" href="interface_i_medium.html#a94d118ff3f2ad05638d4c705532f0dce">IMedium::deleteStorage</a><b></b> operation should be explicitly performed by the caller after the medium is successfully detached and the settings are saved with <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b>, if it is the desired action. </dd></dl>

</div>
</div>
<a class="anchor" id="af0e34af9e99e5884bf0b2eb297344c92"></a><!-- doxytag: member="IMachine::passthroughDevice" ref="af0e34af9e99e5884bf0b2eb297344c92" args="(in wstring name, in long controllerPort, in long device, in boolean passthrough)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::passthroughDevice </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&nbsp;</td>
          <td class="paramname"> <em>passthrough</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the passthrough mode of an existing DVD device. </p>
<p>Changing the setting while the VM is running is forbidden. The setting is only used if at VM start the device is configured as a host DVD drive, in all other cases it is ignored. The device must already exist; see <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b> for how to attach a new device.</p>
<p>The <em>controllerPort</em> and <em>device</em> parameters specify the device slot and have have the same meaning as with <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the storage controller.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>controllerPort</em>&nbsp;</td><td>Storage controller port.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>Device slot in the given port.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>passthrough</em>&nbsp;</td><td>New value for the passthrough setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>SATA device, SATA port, IDE port or IDE slot out of range.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Attempt to modify an unregistered virtual machine.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Invalid machine state.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab2883fc2f65c753bdc1d0ba22cd773c8"></a><!-- doxytag: member="IMachine::temporaryEjectDevice" ref="ab2883fc2f65c753bdc1d0ba22cd773c8" args="(in wstring name, in long controllerPort, in long device, in boolean temporaryEject)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::temporaryEjectDevice </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&nbsp;</td>
          <td class="paramname"> <em>temporaryEject</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the behavior for guest-triggered medium eject. </p>
<p>In some situations it is desirable that such ejects update the VM configuration, and in others the eject should keep the VM configuration. The device must already exist; see <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b> for how to attach a new device.</p>
<p>The <em>controllerPort</em> and <em>device</em> parameters specify the device slot and have have the same meaning as with <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the storage controller.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>controllerPort</em>&nbsp;</td><td>Storage controller port.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>Device slot in the given port.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>temporaryEject</em>&nbsp;</td><td>New value for the eject behavior.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>SATA device, SATA port, IDE port or IDE slot out of range.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Attempt to modify an unregistered virtual machine.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Invalid machine state.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa31ab8471f5076792487779533a26df0"></a><!-- doxytag: member="IMachine::nonRotationalDevice" ref="aa31ab8471f5076792487779533a26df0" args="(in wstring name, in long controllerPort, in long device, in boolean nonRotational)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::nonRotationalDevice </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&nbsp;</td>
          <td class="paramname"> <em>nonRotational</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a flag in the device information which indicates that the medium is not based on rotational technology, i.e. </p>
<p>that the access times are more or less independent of the position on the medium. This may or may not be supported by a particular drive, and is silently ignored in the latter case. At the moment only hard disks (which is a misnomer in this context) accept this setting. Changing the setting while the VM is running is forbidden. The device must already exist; see <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b> for how to attach a new device.</p>
<p>The <em>controllerPort</em> and <em>device</em> parameters specify the device slot and have have the same meaning as with <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the storage controller.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>controllerPort</em>&nbsp;</td><td>Storage controller port.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>Device slot in the given port.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nonRotational</em>&nbsp;</td><td>New value for the non-rotational device flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>SATA device, SATA port, IDE port or IDE slot out of range.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Attempt to modify an unregistered virtual machine.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Invalid machine state.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa02655252429d66d75188bcc56e41e7d"></a><!-- doxytag: member="IMachine::setAutoDiscardForDevice" ref="aa02655252429d66d75188bcc56e41e7d" args="(in wstring name, in long controllerPort, in long device, in boolean discard)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setAutoDiscardForDevice </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&nbsp;</td>
          <td class="paramname"> <em>discard</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a flag in the device information which indicates that the medium supports discarding unsused blocks (called trimming for SATA or unmap for SCSI devices) .This may or may not be supported by a particular drive, and is silently ignored in the latter case. </p>
<p>At the moment only hard disks (which is a misnomer in this context) accept this setting. Changing the setting while the VM is running is forbidden. The device must already exist; see <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b> for how to attach a new device.</p>
<p>The <em>controllerPort</em> and <em>device</em> parameters specify the device slot and have have the same meaning as with <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the storage controller.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>controllerPort</em>&nbsp;</td><td>Storage controller port.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>Device slot in the given port.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>discard</em>&nbsp;</td><td>New value for the discard device flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>SATA device, SATA port, SCSI port out of range.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Attempt to modify an unregistered virtual machine.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Invalid machine state.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa8ed8a03befa534d4df3c5342bf7fcf8"></a><!-- doxytag: member="IMachine::setBandwidthGroupForDevice" ref="aa8ed8a03befa534d4df3c5342bf7fcf8" args="(in wstring name, in long controllerPort, in long device, in IBandwidthGroup bandwidthGroup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setBandwidthGroupForDevice </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="interface_i_bandwidth_group.html">IBandwidthGroup</a>&nbsp;</td>
          <td class="paramname"> <em>bandwidthGroup</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the bandwidth group of an existing storage device. </p>
<p>The device must already exist; see <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b> for how to attach a new device.</p>
<p>The <em>controllerPort</em> and <em>device</em> parameters specify the device slot and have have the same meaning as with <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the storage controller.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>controllerPort</em>&nbsp;</td><td>Storage controller port.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>Device slot in the given port.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bandwidthGroup</em>&nbsp;</td><td>New value for the bandwidth group or <code>null</code> for no group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>SATA device, SATA port, IDE port or IDE slot out of range.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Attempt to modify an unregistered virtual machine.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Invalid machine state.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a94c2637db1f0f0fe4a687a4c2c245218"></a><!-- doxytag: member="IMachine::setNoBandwidthGroupForDevice" ref="a94c2637db1f0f0fe4a687a4c2c245218" args="(in wstring name, in long controllerPort, in long device)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setNoBandwidthGroupForDevice </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>device</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets no bandwidth group for an existing storage device. </p>
<p>The device must already exist; see <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b> for how to attach a new device. The <em>controllerPort</em> and <em>device</em> parameters specify the device slot and have have the same meaning as with <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the storage controller.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>controllerPort</em>&nbsp;</td><td>Storage controller port.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>Device slot in the given port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>SATA device, SATA port, IDE port or IDE slot out of range.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Attempt to modify an unregistered virtual machine.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Invalid machine state.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1f3da9c7f26b4c630f3989f98b58515a"></a><!-- doxytag: member="IMachine::unmountMedium" ref="a1f3da9c7f26b4c630f3989f98b58515a" args="(in wstring name, in long controllerPort, in long device, in boolean force)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::unmountMedium </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&nbsp;</td>
          <td class="paramname"> <em>force</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmounts any currently mounted medium (<a class="el" href="interface_i_medium.html">IMedium</a><b></b>, identified by the given UUID <em>id</em>) to the given storage controller (<a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>, identified by <em>name</em>), at the indicated port and device. </p>
<p>The device must already exist;</p>
<p>This method is intended only for managing removable media, where the device is fixed but media is changeable at runtime (such as DVDs and floppies). It cannot be used for fixed media such as hard disks.</p>
<p>The <em>controllerPort</em> and <em>device</em> parameters specify the device slot and have have the same meaning as with <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b>.</p>
<p>The specified device slot must have a medium mounted, which will be unmounted. If there is no mounted medium it will do nothing. See <a class="el" href="interface_i_medium.html">IMedium</a><b></b> for more detailed information about attaching/unmounting media.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the storage controller to unmount the medium from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>controllerPort</em>&nbsp;</td><td>Port to unmount the medium from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>Device slot in the given port to unmount the medium from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>force</em>&nbsp;</td><td>Allows to force unmount of a medium which is locked by the device slot in the given port medium is attached to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>SATA device, SATA port, IDE port or IDE slot out of range.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Attempt to unmount medium that is not removeable - not dvd or floppy.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Invalid machine state.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga81aa5d056e6fdac2d4f2fc4089957253">VBOX_E_OBJECT_IN_USE </a> </td><td>Medium already attached to this or another virtual machine.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga80982f93e26785a807034131de6cfba5">VBOX_E_OBJECT_NOT_FOUND </a> </td><td>Medium not attached to specified port, device, controller.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1c82306d3603e3bb40f6ab7467d4ff18"></a><!-- doxytag: member="IMachine::mountMedium" ref="a1c82306d3603e3bb40f6ab7467d4ff18" args="(in wstring name, in long controllerPort, in long device, in IMedium medium, in boolean force)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::mountMedium </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="interface_i_medium.html">IMedium</a>&nbsp;</td>
          <td class="paramname"> <em>medium</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&nbsp;</td>
          <td class="paramname"> <em>force</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mounts a medium (<a class="el" href="interface_i_medium.html">IMedium</a><b></b>, identified by the given UUID <em>id</em>) to the given storage controller (<a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>, identified by <em>name</em>), at the indicated port and device. </p>
<p>The device must already exist; see <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b> for how to attach a new device.</p>
<p>This method is intended only for managing removable media, where the device is fixed but media is changeable at runtime (such as DVDs and floppies). It cannot be used for fixed media such as hard disks.</p>
<p>The <em>controllerPort</em> and <em>device</em> parameters specify the device slot and have have the same meaning as with <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">IMachine::attachDevice</a><b></b>.</p>
<p>The specified device slot can have a medium mounted, which will be unmounted first. Specifying a zero UUID (or an empty string) for <em>medium</em> does just an unmount.</p>
<p>See <a class="el" href="interface_i_medium.html">IMedium</a><b></b> for more detailed information about attaching media.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the storage controller to attach the medium to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>controllerPort</em>&nbsp;</td><td>Port to attach the medium to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>Device slot in the given port to attach the medium to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>medium</em>&nbsp;</td><td>Medium to mount or <code>null</code> for an empty drive.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>force</em>&nbsp;</td><td>Allows to force unmount/mount of a medium which is locked by the device slot in the given port to attach the medium to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>SATA device, SATA port, IDE port or IDE slot out of range.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Attempt to attach medium to an unregistered virtual machine.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Invalid machine state.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga81aa5d056e6fdac2d4f2fc4089957253">VBOX_E_OBJECT_IN_USE </a> </td><td>Medium already attached to this or another virtual machine.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a23f94c1e7ed8dcd36cf38ae5c7eec9ed"></a><!-- doxytag: member="IMachine::getMedium" ref="a23f94c1e7ed8dcd36cf38ae5c7eec9ed" args="(in wstring name, in long controllerPort, in long device,[retval] out IMedium medium)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getMedium </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_medium.html">IMedium</a>&nbsp;</td>
          <td class="paramname"> <em>medium</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the virtual medium attached to a device slot of the specified bus. </p>
<p>Note that if the medium was indirectly attached by <a class="el" href="interface_i_machine.html#a1c82306d3603e3bb40f6ab7467d4ff18">mountMedium</a><b></b> to the given device slot then this method will return not the same object as passed to the <a class="el" href="interface_i_machine.html#a1c82306d3603e3bb40f6ab7467d4ff18">mountMedium</a><b></b> call. See <a class="el" href="interface_i_medium.html">IMedium</a><b></b> for more detailed information about mounting a medium.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the storage controller the medium is attached to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>controllerPort</em>&nbsp;</td><td>Port to query.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>Device slot in the given port to query.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>medium</em>&nbsp;</td><td>Attached medium object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga80982f93e26785a807034131de6cfba5">VBOX_E_OBJECT_NOT_FOUND </a> </td><td>No medium attached to given slot/bus.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="adc6e0fd49e384552fc00f26ffc8f9e17"></a><!-- doxytag: member="IMachine::getMediumAttachmentsOfController" ref="adc6e0fd49e384552fc00f26ffc8f9e17" args="(in wstring name,[retval] out IMediumAttachment[] mediumAttachments)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getMediumAttachmentsOfController </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a>[]&nbsp;</td>
          <td class="paramname"> <em>mediumAttachments</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an array of medium attachments which are attached to the the controller with the given name. </p>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga80982f93e26785a807034131de6cfba5">VBOX_E_OBJECT_NOT_FOUND </a> </td><td>A storage controller with given name doesn't exist.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac4ac5f0f020063c3d238d9536c56064f"></a><!-- doxytag: member="IMachine::getMediumAttachment" ref="ac4ac5f0f020063c3d238d9536c56064f" args="(in wstring name, in long controllerPort, in long device,[retval] out IMediumAttachment attachment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getMediumAttachment </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>controllerPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a>&nbsp;</td>
          <td class="paramname"> <em>attachment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a medium attachment which corresponds to the controller with the given name, on the given port and device slot. </p>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga80982f93e26785a807034131de6cfba5">VBOX_E_OBJECT_NOT_FOUND </a> </td><td>No attachment exists for the given controller/port/device combination.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a2640706ef6d61ac1d430199d162035ae"></a><!-- doxytag: member="IMachine::attachHostPCIDevice" ref="a2640706ef6d61ac1d430199d162035ae" args="(in long hostAddress, in long desiredGuestAddress, in boolean tryToUnbind)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::attachHostPCIDevice </td>
          <td>(</td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>hostAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>desiredGuestAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&nbsp;</td>
          <td class="paramname"> <em>tryToUnbind</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attaches host PCI device with the given (host) PCI address to the PCI bus of the virtual machine. </p>
<p>Please note, that this operation is two phase, as real attachment will happen when VM will start, and most information will be delivered as <a class="el" href="interface_i_host_p_c_i_device_plug_event.html" title="Notification when host PCI device is plugged/unplugged.">IHostPCIDevicePlugEvent</a> on <a class="el" href="interface_i_virtual_box.html" title="The IVirtualBox interface represents the main interface exposed by the product that provides virtual ...">IVirtualBox</a> event source.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hostAddress</em>&nbsp;</td><td>Address of the host PCI device.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>desiredGuestAddress</em>&nbsp;</td><td>Desired position of this device on guest PCI bus.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tryToUnbind</em>&nbsp;</td><td>If VMM shall try to unbind existing drivers from the device before attaching it to the guest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Virtual machine state is not stopped (PCI hotplug not yet implemented).   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga654d6c24b0595b844eb49353aee57a6c">VBOX_E_PDM_ERROR </a> </td><td>Virtual machine does not have a PCI controller allowing attachment of physical devices.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#gaa4ba5e3fab3fe318c790d9d0b500c102">VBOX_E_NOT_SUPPORTED </a> </td><td>Hardware or host OS doesn't allow PCI device passthrought.   </td></tr>
</table>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="interface_i_host_p_c_i_device_plug_event.html">IHostPCIDevicePlugEvent</a><b></b> </dd></dl>

</div>
</div>
<a class="anchor" id="a6b94280b4763b7522c4003b095a463d2"></a><!-- doxytag: member="IMachine::detachHostPCIDevice" ref="a6b94280b4763b7522c4003b095a463d2" args="(in long hostAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::detachHostPCIDevice </td>
          <td>(</td>
          <td class="paramtype">in long&nbsp;</td>
          <td class="paramname"> <em>hostAddress</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detach host PCI device from the virtual machine. </p>
<p>Also HostPCIDevicePlugEvent on <a class="el" href="interface_i_virtual_box.html" title="The IVirtualBox interface represents the main interface exposed by the product that provides virtual ...">IVirtualBox</a> event source will be delivered. As currently we don't support hot device unplug, <a class="el" href="interface_i_host_p_c_i_device_plug_event.html" title="Notification when host PCI device is plugged/unplugged.">IHostPCIDevicePlugEvent</a> event is delivered immediately.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hostAddress</em>&nbsp;</td><td>Address of the host PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Virtual machine state is not stopped (PCI hotplug not yet implemented).   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga80982f93e26785a807034131de6cfba5">VBOX_E_OBJECT_NOT_FOUND </a> </td><td>This host device is not attached to this machine.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga654d6c24b0595b844eb49353aee57a6c">VBOX_E_PDM_ERROR </a> </td><td>Virtual machine does not have a PCI controller allowing attachment of physical devices.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#gaa4ba5e3fab3fe318c790d9d0b500c102">VBOX_E_NOT_SUPPORTED </a> </td><td>Hardware or host OS doesn't allow PCI device passthrought.   </td></tr>
</table>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="interface_i_host_p_c_i_device_plug_event.html">IHostPCIDevicePlugEvent</a><b></b> </dd></dl>

</div>
</div>
<a class="anchor" id="a8b3bd5ed7b0eb7ceda6339dfa27d379e"></a><!-- doxytag: member="IMachine::getNetworkAdapter" ref="a8b3bd5ed7b0eb7ceda6339dfa27d379e" args="(in unsigned long slot,[retval] out INetworkAdapter adapter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getNetworkAdapter </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_network_adapter.html">INetworkAdapter</a>&nbsp;</td>
          <td class="paramname"> <em>adapter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the network adapter associated with the given slot. </p>
<p>Slots are numbered sequentially, starting with zero. The total number of adapters per machine is defined by the <a class="el" href="interface_i_system_properties.html#add727d139554f0fc57388570f32841ce">ISystemProperties::getMaxNetworkAdapters</a><b></b> property, so the maximum slot number is one less than that property's value.</p>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>Invalid <em>slot</em> number.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="adb3aeb9186d64c6d06118daae8302dbd"></a><!-- doxytag: member="IMachine::addStorageController" ref="adb3aeb9186d64c6d06118daae8302dbd" args="(in wstring name, in StorageBus connectionType,[retval] out IStorageController controller)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::addStorageController </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#ab955ac5f95964be27366be7bbc8f3cf0">StorageBus</a>&nbsp;</td>
          <td class="paramname"> <em>connectionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_storage_controller.html">IStorageController</a>&nbsp;</td>
          <td class="paramname"> <em>controller</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a new storage controller (SCSI, SAS or SATA controller) to the machine and returns it as an instance of <a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>. </p>
<p><em>name</em> identifies the controller for subsequent calls such as <a class="el" href="interface_i_machine.html#a0ea4bd5091b475d5692dd0363327cb82">getStorageControllerByName</a><b></b>, <a class="el" href="interface_i_machine.html#a8bf23af3c199e1c63fbbd62354c041f3">getStorageControllerByInstance</a><b></b>, <a class="el" href="interface_i_machine.html#af6cb6937da2196d9bc13d9670c6f6eaf">removeStorageController</a><b></b>, <a class="el" href="interface_i_machine.html#a8e51fafec7442a48a86a59edec5ec217">attachDevice</a><b></b> or <a class="el" href="interface_i_machine.html#a1c82306d3603e3bb40f6ab7467d4ff18">mountMedium</a><b></b>.</p>
<p>After the controller has been added, you can set its exact type by setting the <a class="el" href="interface_i_storage_controller.html#ae1bd486ff9df74163e79d63dae96bd8c">IStorageController::controllerType</a><b></b>.</p>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga81aa5d056e6fdac2d4f2fc4089957253">VBOX_E_OBJECT_IN_USE </a> </td><td>A storage controller with given name exists already.   </td></tr>
<tr>
<td>E_INVALIDARG </td><td>Invalid <em>controllerType</em>.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0ea4bd5091b475d5692dd0363327cb82"></a><!-- doxytag: member="IMachine::getStorageControllerByName" ref="a0ea4bd5091b475d5692dd0363327cb82" args="(in wstring name,[retval] out IStorageController storageController)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getStorageControllerByName </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_storage_controller.html">IStorageController</a>&nbsp;</td>
          <td class="paramname"> <em>storageController</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a storage controller with the given name. </p>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga80982f93e26785a807034131de6cfba5">VBOX_E_OBJECT_NOT_FOUND </a> </td><td>A storage controller with given name doesn't exist.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8bf23af3c199e1c63fbbd62354c041f3"></a><!-- doxytag: member="IMachine::getStorageControllerByInstance" ref="a8bf23af3c199e1c63fbbd62354c041f3" args="(in unsigned long instance,[retval] out IStorageController storageController)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getStorageControllerByInstance </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_storage_controller.html">IStorageController</a>&nbsp;</td>
          <td class="paramname"> <em>storageController</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a storage controller with the given instance number. </p>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga80982f93e26785a807034131de6cfba5">VBOX_E_OBJECT_NOT_FOUND </a> </td><td>A storage controller with given instance number doesn't exist.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="af6cb6937da2196d9bc13d9670c6f6eaf"></a><!-- doxytag: member="IMachine::removeStorageController" ref="af6cb6937da2196d9bc13d9670c6f6eaf" args="(in wstring name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::removeStorageController </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a storage controller from the machine with all devices attached to it. </p>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga80982f93e26785a807034131de6cfba5">VBOX_E_OBJECT_NOT_FOUND </a> </td><td>A storage controller with given name doesn't exist.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#gaa4ba5e3fab3fe318c790d9d0b500c102">VBOX_E_NOT_SUPPORTED </a> </td><td>Medium format does not support storage deletion (only for implicitly created differencing media, should not happen).   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5d4d1c7791274f8baaef6e341f029cd2"></a><!-- doxytag: member="IMachine::setStorageControllerBootable" ref="a5d4d1c7791274f8baaef6e341f029cd2" args="(in wstring name, in boolean bootable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setStorageControllerBootable </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&nbsp;</td>
          <td class="paramname"> <em>bootable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the bootable flag of the storage controller with the given name. </p>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga80982f93e26785a807034131de6cfba5">VBOX_E_OBJECT_NOT_FOUND </a> </td><td>A storage controller with given name doesn't exist.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga81aa5d056e6fdac2d4f2fc4089957253">VBOX_E_OBJECT_IN_USE </a> </td><td>Another storage controller is marked as bootable already.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad69923a471cec43bb32a9e8ad54cfcd2"></a><!-- doxytag: member="IMachine::getSerialPort" ref="ad69923a471cec43bb32a9e8ad54cfcd2" args="(in unsigned long slot,[retval] out ISerialPort port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getSerialPort </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_serial_port.html">ISerialPort</a>&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the serial port associated with the given slot. </p>
<p>Slots are numbered sequentially, starting with zero. The total number of serial ports per machine is defined by the <a class="el" href="interface_i_system_properties.html#a072c31ebdafd2d179cc9d849a92d4040">ISystemProperties::serialPortCount</a><b></b> property, so the maximum slot number is one less than that property's value.</p>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>Invalid <em>slot</em> number.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4182d2cf6c281b63e1112f5e9f327950"></a><!-- doxytag: member="IMachine::getParallelPort" ref="a4182d2cf6c281b63e1112f5e9f327950" args="(in unsigned long slot,[retval] out IParallelPort port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getParallelPort </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_parallel_port.html">IParallelPort</a>&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the parallel port associated with the given slot. </p>
<p>Slots are numbered sequentially, starting with zero. The total number of parallel ports per machine is defined by the <a class="el" href="interface_i_system_properties.html#a60b8b79900e9643db74fad08f6063aea">ISystemProperties::parallelPortCount</a><b></b> property, so the maximum slot number is one less than that property's value.</p>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>Invalid <em>slot</em> number.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a56092a8c40e53f8a9560157f217e388d"></a><!-- doxytag: member="IMachine::getExtraDataKeys" ref="a56092a8c40e53f8a9560157f217e388d" args="([retval] out wstring[] value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getExtraDataKeys </td>
          <td>(</td>
          <td class="paramtype">[retval] out wstring[]&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an array representing the machine-specific extra data keys which currently have values defined. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Array of extra data keys. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c439f06e57cdff36d5d954f02a6d3e6"></a><!-- doxytag: member="IMachine::getExtraData" ref="a1c439f06e57cdff36d5d954f02a6d3e6" args="(in wstring key,[retval] out wstring value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getExtraData </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out wstring&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns associated machine-specific extra data. </p>
<p>If the requested data <em>key</em> does not exist, this function will succeed and return an empty string in the <em>value</em> argument.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Name of the data key to get.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value of the requested data key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga1b9c9362e6dbe4403c321c0e6f1a28ad">VBOX_E_FILE_ERROR </a> </td><td>Settings file not accessible.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga6f99ff1b7776c89e6433f7c827eaef67">VBOX_E_XML_ERROR </a> </td><td>Could not parse the settings file.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a79f89295518cbfcd582c9a63602f795a"></a><!-- doxytag: member="IMachine::setExtraData" ref="a79f89295518cbfcd582c9a63602f795a" args="(in wstring key, in wstring value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setExtraData </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets associated machine-specific extra data. </p>
<p>If you pass <code>null</code> or an empty string as a key <em>value</em>, the given <em>key</em> will be deleted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Name of the data key to set.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Value to assign to the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga1b9c9362e6dbe4403c321c0e6f1a28ad">VBOX_E_FILE_ERROR </a> </td><td>Settings file not accessible.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga6f99ff1b7776c89e6433f7c827eaef67">VBOX_E_XML_ERROR </a> </td><td>Could not parse the settings file.   </td></tr>
</table>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Before performing the actual data change, this method will ask all registered listeners using the <a class="el" href="interface_i_extra_data_can_change_event.html">IExtraDataCanChangeEvent</a><b></b> notification for a permission. If one of the listeners refuses the new value, the change will not be performed.</dd>
<dd>
On success, the <a class="el" href="interface_i_extra_data_changed_event.html">IExtraDataChangedEvent</a><b></b> notification is called to inform all registered listeners about a successful data change.</dd>
<dd>
This method can be called outside the machine session and therefore it's a caller's responsibility to handle possible race conditions when several clients change the same key at the same time. </dd></dl>

</div>
</div>
<a class="anchor" id="af25832baa40d8e08fc976cddbb300ca5"></a><!-- doxytag: member="IMachine::getCPUProperty" ref="af25832baa40d8e08fc976cddbb300ca5" args="(in CPUPropertyType property,[retval] out boolean value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getCPUProperty </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#a5fa1ad8b7ea677aaf75dda650d27175a">CPUPropertyType</a>&nbsp;</td>
          <td class="paramname"> <em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out boolean&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the virtual CPU boolean value of the specified property. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>property</em>&nbsp;</td><td>Property type to query.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Property value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>Invalid property.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8953644f3d8072c4270c4caf0006c2ed"></a><!-- doxytag: member="IMachine::setCPUProperty" ref="a8953644f3d8072c4270c4caf0006c2ed" args="(in CPUPropertyType property, in boolean value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setCPUProperty </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#a5fa1ad8b7ea677aaf75dda650d27175a">CPUPropertyType</a>&nbsp;</td>
          <td class="paramname"> <em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the virtual CPU boolean value of the specified property. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>property</em>&nbsp;</td><td>Property type to query.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Property value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>Invalid property.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab54fcd6c0b8424d40a543134f251e9de"></a><!-- doxytag: member="IMachine::getCPUIDLeaf" ref="ab54fcd6c0b8424d40a543134f251e9de" args="(in unsigned long id, out unsigned long valEax, out unsigned long valEbx, out unsigned long valEcx, out unsigned long valEdx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getCPUIDLeaf </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>valEax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>valEbx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>valEcx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>valEdx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the virtual CPU cpuid information for the specified leaf. </p>
<p>Currently supported index values for cpuid: Standard CPUID leafs: 0 - 0xA Extended CPUID leafs: 0x80000000 - 0x8000000A</p>
<p>See the Intel and AMD programmer's manuals for detailed information about the cpuid instruction and its leafs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>CPUID leaf index.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>valEax</em>&nbsp;</td><td>CPUID leaf value for register eax.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>valEbx</em>&nbsp;</td><td>CPUID leaf value for register ebx.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>valEcx</em>&nbsp;</td><td>CPUID leaf value for register ecx.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>valEdx</em>&nbsp;</td><td>CPUID leaf value for register edx.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>Invalid id.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="addd00ff1038502cb30b5ca52c789c0f6"></a><!-- doxytag: member="IMachine::setCPUIDLeaf" ref="addd00ff1038502cb30b5ca52c789c0f6" args="(in unsigned long id, in unsigned long valEax, in unsigned long valEbx, in unsigned long valEcx, in unsigned long valEdx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setCPUIDLeaf </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>valEax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>valEbx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>valEcx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>valEdx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the virtual CPU cpuid information for the specified leaf. </p>
<p>Note that these values are not passed unmodified. VirtualBox clears features that it doesn't support.</p>
<p>Currently supported index values for cpuid: Standard CPUID leafs: 0 - 0xA Extended CPUID leafs: 0x80000000 - 0x8000000A</p>
<p>See the Intel and AMD programmer's manuals for detailed information about the cpuid instruction and its leafs.</p>
<p>Do not use this method unless you know exactly what you're doing. Misuse can lead to random crashes inside VMs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>CPUID leaf index.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>valEax</em>&nbsp;</td><td>CPUID leaf value for register eax.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>valEbx</em>&nbsp;</td><td>CPUID leaf value for register ebx.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>valEcx</em>&nbsp;</td><td>CPUID leaf value for register ecx.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>valEdx</em>&nbsp;</td><td>CPUID leaf value for register edx.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>Invalid id.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="aaac9fbfebe854059cb2be61be968c568"></a><!-- doxytag: member="IMachine::removeCPUIDLeaf" ref="aaac9fbfebe854059cb2be61be968c568" args="(in unsigned long id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::removeCPUIDLeaf </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the virtual CPU cpuid leaf for the specified index. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>CPUID leaf index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>Invalid id.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="aaae582c5edb838dfa96f62a48b496fe1"></a><!-- doxytag: member="IMachine::removeAllCPUIDLeaves" ref="aaae582c5edb838dfa96f62a48b496fe1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::removeAllCPUIDLeaves </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all the virtual CPU cpuid leaves. </p>

</div>
</div>
<a class="anchor" id="a00b69a5e62700f57b2204c7649e59efb"></a><!-- doxytag: member="IMachine::getHWVirtExProperty" ref="a00b69a5e62700f57b2204c7649e59efb" args="(in HWVirtExPropertyType property,[retval] out boolean value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getHWVirtExProperty </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#ae90b543d84f42a1e477aafa7303079cb">HWVirtExPropertyType</a>&nbsp;</td>
          <td class="paramname"> <em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out boolean&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the value of the specified hardware virtualization boolean property. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>property</em>&nbsp;</td><td>Property type to query.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Property value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>Invalid property.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4e38cff5f3af00bdb490548a82ac7b44"></a><!-- doxytag: member="IMachine::setHWVirtExProperty" ref="a4e38cff5f3af00bdb490548a82ac7b44" args="(in HWVirtExPropertyType property, in boolean value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setHWVirtExProperty </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#ae90b543d84f42a1e477aafa7303079cb">HWVirtExPropertyType</a>&nbsp;</td>
          <td class="paramname"> <em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a new value for the specified hardware virtualization boolean property. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>property</em>&nbsp;</td><td>Property type to set.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>New property value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td>Invalid property.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a2eb47e1d878566569b26893cc12bd8e1"></a><!-- doxytag: member="IMachine::saveSettings" ref="a2eb47e1d878566569b26893cc12bd8e1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::saveSettings </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Saves any changes to machine settings made since the session has been opened or a new machine has been created, or since the last call to <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> or <a class="el" href="interface_i_machine.html#a341ac035501a0c168ad9571bbe86eb02">discardSettings</a><b></b>. </p>
<p>For registered machines, new settings become visible to all other VirtualBox clients after successful invocation of this method.</p>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga1b9c9362e6dbe4403c321c0e6f1a28ad">VBOX_E_FILE_ERROR </a> </td><td>Settings file not accessible.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga6f99ff1b7776c89e6433f7c827eaef67">VBOX_E_XML_ERROR </a> </td><td>Could not parse the settings file.   </td></tr>
<tr>
<td>E_ACCESSDENIED </td><td>Modification request refused.   </td></tr>
</table>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The method sends <a class="el" href="interface_i_machine_data_changed_event.html">IMachineDataChangedEvent</a><b></b> notification event after the configuration has been successfully saved (only for registered machines).</dd>
<dd>
Calling this method is only valid on instances returned by <a class="el" href="interface_i_session.html#a83d8f53d35e522599b192cac168c3495">ISession::machine</a><b></b> and on new machines created by <a class="el" href="interface_i_virtual_box.html#aabb76f2d305052b305ccd78d18b05ab8">IVirtualBox::createMachine</a><b></b> but not yet registered, or on unregistered machines after calling <a class="el" href="interface_i_machine.html#accfecb34e04b20108c7bf8b469c32d5a">IMachine::unregister</a><b></b>. </dd></dl>

</div>
</div>
<a class="anchor" id="a341ac035501a0c168ad9571bbe86eb02"></a><!-- doxytag: member="IMachine::discardSettings" ref="a341ac035501a0c168ad9571bbe86eb02" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::discardSettings </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Discards any changes to the machine settings made since the session has been opened or since the last call to <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> or <a class="el" href="interface_i_machine.html#a341ac035501a0c168ad9571bbe86eb02">discardSettings</a><b></b>. </p>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Virtual machine is not mutable.  </td></tr>
</table>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Calling this method is only valid on instances returned by <a class="el" href="interface_i_session.html#a83d8f53d35e522599b192cac168c3495">ISession::machine</a><b></b> and on new machines created by <a class="el" href="interface_i_virtual_box.html#aabb76f2d305052b305ccd78d18b05ab8">IVirtualBox::createMachine</a><b></b> or opened by <a class="el" href="interface_i_virtual_box.html#a4b44e306db59ce580ae54d9f50a0686a">IVirtualBox::openMachine</a><b></b> but not yet registered, or on unregistered machines after calling <a class="el" href="interface_i_machine.html#accfecb34e04b20108c7bf8b469c32d5a">IMachine::unregister</a><b></b>. </dd></dl>

</div>
</div>
<a class="anchor" id="accfecb34e04b20108c7bf8b469c32d5a"></a><!-- doxytag: member="IMachine::unregister" ref="accfecb34e04b20108c7bf8b469c32d5a" args="(in CleanupMode cleanupMode,[retval] out IMedium[] aMedia)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::unregister </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#a0381acf2db95fe7b709d78553346ea1c">CleanupMode</a>&nbsp;</td>
          <td class="paramname"> <em>cleanupMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_medium.html">IMedium</a>[]&nbsp;</td>
          <td class="paramname"> <em>aMedia</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregisters a machine previously registered with <a class="el" href="interface_i_virtual_box.html#a7a67d2e6643990d72949c8d6c806ed35">IVirtualBox::registerMachine</a><b></b> and optionally do additional cleanup before the machine is unregistered. </p>
<p>This method does not delete any files. It only changes the machine configuration and the list of registered machines in the VirtualBox object. To delete the files which belonged to the machine, including the XML file of the machine itself, call <a class="el" href="interface_i_machine.html#aaea5212b6af18129d7f046ca317534ba">delete</a><b></b>, optionally with the array of <a class="el" href="interface_i_medium.html" title="The IMedium interface represents virtual storage for a machine&#39;s hard disks, CD/DVD or floppy dri...">IMedium</a> objects which was returned from this method.</p>
<p>How thoroughly this method cleans up the machine configuration before unregistering the machine depends on the <em>cleanupMode</em> argument.</p>
<ul>
<li>
With "UnregisterOnly", the machine will only be unregistered, but no additional cleanup will be performed. The call will fail if the machine is in "Saved" state or has any snapshots or any media attached (see <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a><b></b>). It is the responsibility of the caller to delete all such configuration in this mode. In this mode, the API behaves like the former <code>IVirtualBox::unregisterMachine()</code> API which it replaces. </li>
<li>
With "DetachAllReturnNone", the call will succeed even if the machine is in "Saved" state or if it has snapshots or media attached. All media attached to the current machine state or in snapshots will be detached. No medium objects will be returned; all of the machine's media will remain open. </li>
<li>
With "DetachAllReturnHardDisksOnly", the call will behave like with "DetachAllReturnNone", except that all the hard disk medium objects which were detached from the machine will be returned as an array. This allows for quickly passing them to the <a class="el" href="interface_i_machine.html#aaea5212b6af18129d7f046ca317534ba">delete</a><b></b> API for closing and deletion. </li>
<li>
With "Full", the call will behave like with "DetachAllReturnHardDisksOnly", except that all media will be returned in the array, including removable media like DVDs and floppies. This might be useful if the user wants to inspect in detail which media were attached to the machine. Be careful when passing the media array to <a class="el" href="interface_i_machine.html#aaea5212b6af18129d7f046ca317534ba">delete</a><b></b> in that case because users will typically want to preserve ISO and RAW image files. </li>
</ul>
<p>A typical implementation will use "DetachAllReturnHardDisksOnly" and then pass the resulting <a class="el" href="interface_i_medium.html" title="The IMedium interface represents virtual storage for a machine&#39;s hard disks, CD/DVD or floppy dri...">IMedium</a> array to <a class="el" href="interface_i_machine.html#aaea5212b6af18129d7f046ca317534ba">delete</a><b></b>. This way, the machine is completely deleted with all its saved states and hard disk images, but images for removable drives (such as ISO and RAW files) will remain on disk.</p>
<p>This API does not verify whether the media files returned in the array are still attached to other machines (i.e. shared between several machines). If such a shared image is passed to <a class="el" href="interface_i_machine.html#aaea5212b6af18129d7f046ca317534ba">delete</a><b></b> however, closing the image will fail there and the image will be silently skipped.</p>
<p>This API may, however, move media from this machine's media registry to other media registries (see <a class="el" href="interface_i_medium.html">IMedium</a><b></b> for details on media registries). For machines created with VirtualBox 4.0 or later, if media from this machine's media registry are also attached to another machine (shared attachments), each such medium will be moved to another machine's registry. This is because without this machine's media registry, the other machine cannot find its media any more and would become inaccessible.</p>
<p>This API implicitly calls <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> to save all current machine settings before unregistering it. It may also silently call <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> on other machines if media are moved to other machines' media registries.</p>
<p>After successful method invocation, the <a class="el" href="interface_i_machine_registered_event.html">IMachineRegisteredEvent</a><b></b> event is fired.</p>
<p>The call will fail if the machine is currently locked (see <a class="el" href="interface_i_session.html">ISession</a><b></b>).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cleanupMode</em>&nbsp;</td><td>How to clean up after the machine has been unregistered.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aMedia</em>&nbsp;</td><td>List of media detached from the machine, depending on the <em>cleanupMode</em> parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Machine is currently locked for a session.  </td></tr>
</table>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If the given machine is inaccessible (see <a class="el" href="interface_i_machine.html#a2b6c9cc91c11db18c5b6b870556355f2">accessible</a><b></b>), it will be unregistered and fully uninitialized right afterwards. As a result, the returned machine object will be unusable and an attempt to call <b>any</b> method will return the "Object not ready" error. </dd></dl>

</div>
</div>
<a class="anchor" id="aaea5212b6af18129d7f046ca317534ba"></a><!-- doxytag: member="IMachine::delete" ref="aaea5212b6af18129d7f046ca317534ba" args="(in IMedium[] aMedia,[retval] out IProgress aProgress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::delete </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="interface_i_medium.html">IMedium</a>[]&nbsp;</td>
          <td class="paramname"> <em>aMedia</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&nbsp;</td>
          <td class="paramname"> <em>aProgress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes the files associated with this machine from disk. </p>
<p>If medium objects are passed in with the <em>aMedia</em> argument, they are closed and, if closing was successful, their storage files are deleted as well. For convenience, this array of media files can be the same as the one returned from a previous <a class="el" href="interface_i_machine.html#accfecb34e04b20108c7bf8b469c32d5a">unregister</a><b></b> call.</p>
<p>This method must only be called on machines which are either write-locked (i.e. on instances returned by <a class="el" href="interface_i_session.html#a83d8f53d35e522599b192cac168c3495">ISession::machine</a><b></b>) or on unregistered machines (i.e. not yet registered machines created by <a class="el" href="interface_i_virtual_box.html#aabb76f2d305052b305ccd78d18b05ab8">IVirtualBox::createMachine</a><b></b> or opened by <a class="el" href="interface_i_virtual_box.html#a4b44e306db59ce580ae54d9f50a0686a">IVirtualBox::openMachine</a><b></b>, or after having called <a class="el" href="interface_i_machine.html#accfecb34e04b20108c7bf8b469c32d5a">unregister</a><b></b>).</p>
<p>The following files will be deleted by this method: </p>
<ul>
<li>
If <a class="el" href="interface_i_machine.html#accfecb34e04b20108c7bf8b469c32d5a">unregister</a><b></b> had been previously called with a <em>cleanupMode</em> argument other than "UnregisterOnly", this will delete all saved state files that the machine had in use; possibly one if the machine was in "Saved" state and one for each online snapshot that the machine had. </li>
<li>
On each medium object passed in the <em>aMedia</em> array, this will call <a class="el" href="interface_i_medium.html#a8e006ecc7b5bc8d9d8cb281b237a8e23">IMedium::close</a><b></b>. If that succeeds, this will attempt to delete the medium's storage on disk. Since the <a class="el" href="interface_i_medium.html#a8e006ecc7b5bc8d9d8cb281b237a8e23">IMedium::close</a><b></b> call will fail if the medium is still in use, e.g. because it is still attached to a second machine; in that case the storage will not be deleted. </li>
<li>
Finally, the machine's own XML file will be deleted. </li>
</ul>
<p>Since deleting large disk image files can be a time-consuming I/O operation, this method operates asynchronously and returns an <a class="el" href="interface_i_progress.html" title="The IProgress interface is used to track and control asynchronous tasks within VirtualBox.">IProgress</a> object to allow the caller to monitor the progress. There will be one sub-operation for each file that is being deleted (saved state or medium storage file).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aMedia</em>&nbsp;</td><td>List of media to be closed and whose storage files will be deleted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aProgress</em>&nbsp;</td><td>Progress object to track the operation completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Machine is registered but not write-locked.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga95e965b219ae7d16a8dee5eca6267ce5">VBOX_E_IPRT_ERROR </a> </td><td>Could not delete the settings file.   </td></tr>
</table>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="interface_i_machine.html#a7fa04613f860573400ba570fcf80f3ef">settingsModified</a><b></b> will return <code>true</code> after this method successfully returns. </dd></dl>

</div>
</div>
<a class="anchor" id="a05a6111b53bf9c7e725c1d03bf92b12e"></a><!-- doxytag: member="IMachine::export" ref="a05a6111b53bf9c7e725c1d03bf92b12e" args="(in IAppliance aAppliance, in wstring location,[retval] out IVirtualSystemDescription aDescription)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::export </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="interface_i_appliance.html">IAppliance</a>&nbsp;</td>
          <td class="paramname"> <em>aAppliance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_virtual_system_description.html">IVirtualSystemDescription</a>&nbsp;</td>
          <td class="paramname"> <em>aDescription</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exports the machine to an OVF appliance. </p>
<p>See <a class="el" href="interface_i_appliance.html">IAppliance</a><b></b> for the steps required to export VirtualBox machines to OVF.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aAppliance</em>&nbsp;</td><td>Appliance to export this machine to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>location</em>&nbsp;</td><td>The target location.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aDescription</em>&nbsp;</td><td>VirtualSystemDescription object which is created for this machine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93d4c50ba76cf7a8930d8364961ed60e"></a><!-- doxytag: member="IMachine::findSnapshot" ref="a93d4c50ba76cf7a8930d8364961ed60e" args="(in wstring nameOrId,[retval] out ISnapshot snapshot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::findSnapshot </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>nameOrId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_snapshot.html">ISnapshot</a>&nbsp;</td>
          <td class="paramname"> <em>snapshot</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a snapshot of this machine with the given name or UUID. </p>
<p>Returns a snapshot of this machine with the given UUID. A <code>null</code> argument can be used to obtain the first snapshot taken on this machine. To traverse the whole tree of snapshots starting from the root, inspect the root snapshot's <a class="el" href="interface_i_snapshot.html#a7864167d1b7c440cc3bb49c1a8626354">ISnapshot::children</a><b></b> attribute and recurse over those children.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nameOrId</em>&nbsp;</td><td>What to search for. Name or UUID of the snapshot to find</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>snapshot</em>&nbsp;</td><td>Snapshot object with the given name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga80982f93e26785a807034131de6cfba5">VBOX_E_OBJECT_NOT_FOUND </a> </td><td>Virtual machine has no snapshots or snapshot not found.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae49562a26a94c09044d8bdb9341d836b"></a><!-- doxytag: member="IMachine::createSharedFolder" ref="ae49562a26a94c09044d8bdb9341d836b" args="(in wstring name, in wstring hostPath, in boolean writable, in boolean automount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::createSharedFolder </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>hostPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&nbsp;</td>
          <td class="paramname"> <em>writable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&nbsp;</td>
          <td class="paramname"> <em>automount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new permanent shared folder by associating the given logical name with the given host path, adds it to the collection of shared folders and starts sharing it. </p>
<p>Refer to the description of <a class="el" href="interface_i_shared_folder.html">ISharedFolder</a><b></b> to read more about logical names.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Unique logical name of the shared folder.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hostPath</em>&nbsp;</td><td>Full path to the shared folder in the host file system.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>writable</em>&nbsp;</td><td>Whether the share is writable or readonly.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>automount</em>&nbsp;</td><td>Whether the share gets automatically mounted by the guest or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga81aa5d056e6fdac2d4f2fc4089957253">VBOX_E_OBJECT_IN_USE </a> </td><td>Shared folder already exists.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga1b9c9362e6dbe4403c321c0e6f1a28ad">VBOX_E_FILE_ERROR </a> </td><td>Shared folder <em>hostPath</em> not accessible.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a30e6a10490fde39a3e97e2ae1d1fa3ce"></a><!-- doxytag: member="IMachine::removeSharedFolder" ref="a30e6a10490fde39a3e97e2ae1d1fa3ce" args="(in wstring name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::removeSharedFolder </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the permanent shared folder with the given name previously created by <a class="el" href="interface_i_machine.html#ae49562a26a94c09044d8bdb9341d836b">createSharedFolder</a><b></b> from the collection of shared folders and stops sharing it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Logical name of the shared folder to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Virtual machine is not mutable.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga80982f93e26785a807034131de6cfba5">VBOX_E_OBJECT_NOT_FOUND </a> </td><td>Shared folder <em>name</em> does not exist.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="aebbda0c226bb18cd02f01e8492bbe3a1"></a><!-- doxytag: member="IMachine::canShowConsoleWindow" ref="aebbda0c226bb18cd02f01e8492bbe3a1" args="([retval] out boolean canShow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::canShowConsoleWindow </td>
          <td>(</td>
          <td class="paramtype">[retval] out boolean&nbsp;</td>
          <td class="paramname"> <em>canShow</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if the VM console process can activate the console window and bring it to foreground on the desktop of the host PC. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>canShow</em>&nbsp;</td><td><code>true</code> if the console window can be shown and <code>false</code> otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Machine session is not open.  </td></tr>
</table>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This method will fail if a session for this machine is not currently open. </dd></dl>

</div>
</div>
<a class="anchor" id="ada877c47a8efa8a62967f8cb0387bfbc"></a><!-- doxytag: member="IMachine::showConsoleWindow" ref="ada877c47a8efa8a62967f8cb0387bfbc" args="([retval] out long long winId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::showConsoleWindow </td>
          <td>(</td>
          <td class="paramtype">[retval] out long long&nbsp;</td>
          <td class="paramname"> <em>winId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Activates the console window and brings it to foreground on the desktop of the host PC. </p>
<p>Many modern window managers on many platforms implement some sort of focus stealing prevention logic, so that it may be impossible to activate a window without the help of the currently active application. In this case, this method will return a non-zero identifier that represents the top-level window of the VM console process. The caller, if it represents a currently active process, is responsible to use this identifier (in a platform-dependent manner) to perform actual window activation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>winId</em>&nbsp;</td><td>Platform-dependent identifier of the top-level VM console window, or zero if this method has performed all actions necessary to implement the <em>show window</em> semantics for the given platform and/or VirtualBox front-end.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Machine session is not open.  </td></tr>
</table>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This method will fail if a session for this machine is not currently open. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f2fffade4b897eb659cc4602694676d"></a><!-- doxytag: member="IMachine::getGuestProperty" ref="a9f2fffade4b897eb659cc4602694676d" args="(in wstring name, out wstring value, out long long timestamp, out wstring flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getGuestProperty </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out wstring&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out long long&nbsp;</td>
          <td class="paramname"> <em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out wstring&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads an entry from the machine's guest property store. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the property to read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the property. If the property does not exist then this will be empty.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>The time at which the property was last modified, as seen by the server process.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Additional property parameters, passed as a comma-separated list of "name=value" type entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Machine session is not open.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a06b232cfabaf8a59657498cc7154c6a8"></a><!-- doxytag: member="IMachine::getGuestPropertyValue" ref="a06b232cfabaf8a59657498cc7154c6a8" args="(in wstring property,[retval] out wstring value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getGuestPropertyValue </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out wstring&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a value from the machine's guest property store. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>property</em>&nbsp;</td><td>The name of the property to read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the property. If the property does not exist then this will be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Machine session is not open.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae97f4b047477f3803a88e57d80de97ef"></a><!-- doxytag: member="IMachine::getGuestPropertyTimestamp" ref="ae97f4b047477f3803a88e57d80de97ef" args="(in wstring property,[retval] out long long value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getGuestPropertyTimestamp </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out long long&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a property timestamp from the machine's guest property store. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>property</em>&nbsp;</td><td>The name of the property to read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The timestamp. If the property does not exist then this will be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Machine session is not open.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a526521a6479eeaf3067550417a7bb888"></a><!-- doxytag: member="IMachine::setGuestProperty" ref="a526521a6479eeaf3067550417a7bb888" args="(in wstring property, in wstring value, in wstring flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setGuestProperty </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets, changes or deletes an entry in the machine's guest property store. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>property</em>&nbsp;</td><td>The name of the property to set, change or delete.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The new value of the property to set, change or delete. If the property does not yet exist and value is non-empty, it will be created. If the value is <code>null</code> or empty, the property will be deleted if it exists.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Additional property parameters, passed as a comma-separated list of "name=value" type entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_ACCESSDENIED </td><td>Property cannot be changed.   </td></tr>
<tr>
<td>E_INVALIDARG </td><td>Invalid <em>flags</em>.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Virtual machine is not mutable or session not open.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Cannot set transient property when machine not running.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a86db68f492c701d4fd323cf6aab633b9"></a><!-- doxytag: member="IMachine::setGuestPropertyValue" ref="a86db68f492c701d4fd323cf6aab633b9" args="(in wstring property, in wstring value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::setGuestPropertyValue </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets, changes or deletes a value in the machine's guest property store. </p>
<p>The flags field will be left unchanged or created empty for a new property.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>property</em>&nbsp;</td><td>The name of the property to set, change or delete.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The new value of the property to set, change or delete. If the property does not yet exist and value is non-empty, it will be created. If the value is <code>null</code> or empty, the property will be deleted if it exists.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_ACCESSDENIED </td><td>Property cannot be changed.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Virtual machine is not mutable or session not open.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Cannot set transient property when machine not running.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a2b5bc248ab2a58bdab899dd0ab0b6b10"></a><!-- doxytag: member="IMachine::deleteGuestProperty" ref="a2b5bc248ab2a58bdab899dd0ab0b6b10" args="(in wstring name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::deleteGuestProperty </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes an entry from the machine's guest property store. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the property to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga299db1dfa415a02742a11db2a544e364">VBOX_E_INVALID_VM_STATE </a> </td><td>Machine session is not open.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4ca2935cbe0568ead81e6c12bb04ef27"></a><!-- doxytag: member="IMachine::enumerateGuestProperties" ref="a4ca2935cbe0568ead81e6c12bb04ef27" args="(in wstring patterns, out wstring[] name, out wstring[] value, out long long[] timestamp, out wstring[] flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::enumerateGuestProperties </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out wstring[]&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out wstring[]&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out long long[]&nbsp;</td>
          <td class="paramname"> <em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out wstring[]&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a list of the guest properties matching a set of patterns along with their values, time stamps and flags. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>patterns</em>&nbsp;</td><td>The patterns to match the properties against, separated by '|' characters. If this is empty or <code>null</code>, all properties will match.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The names of the properties returned.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The values of the properties returned. The array entries match the corresponding entries in the <em>name</em> array.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>The time stamps of the properties returned. The array entries match the corresponding entries in the <em>name</em> array.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>The flags of the properties returned. The array entries match the corresponding entries in the <em>name</em> array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a854f70590d1680516cfd2e3ff0e2d7b6"></a><!-- doxytag: member="IMachine::querySavedGuestScreenInfo" ref="a854f70590d1680516cfd2e3ff0e2d7b6" args="(in unsigned long screenId, out unsigned long originX, out unsigned long originY, out unsigned long width, out unsigned long height, out boolean enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::querySavedGuestScreenInfo </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>screenId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>originX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>originY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out boolean&nbsp;</td>
          <td class="paramname"> <em>enabled</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the guest dimensions from the saved state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>screenId</em>&nbsp;</td><td>Saved guest screen to query info from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>originX</em>&nbsp;</td><td>The X position of the guest monitor top left corner.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>originY</em>&nbsp;</td><td>The Y position of the guest monitor top left corner.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Guest width at the time of the saved state was taken.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Guest height at the time of the saved state was taken.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enabled</em>&nbsp;</td><td>Whether the monitor is enabled in the guest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cb9b422207206f4c1918427cc33304c"></a><!-- doxytag: member="IMachine::querySavedThumbnailSize" ref="a7cb9b422207206f4c1918427cc33304c" args="(in unsigned long screenId, out unsigned long size, out unsigned long width, out unsigned long height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::querySavedThumbnailSize </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>screenId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns size in bytes and dimensions in pixels of a saved thumbnail bitmap from saved state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>screenId</em>&nbsp;</td><td>Saved guest screen to query info from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of buffer required to store the bitmap.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Bitmap width.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Bitmap height. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64040195c2b42178b7288d8bc48761c4"></a><!-- doxytag: member="IMachine::readSavedThumbnailToArray" ref="a64040195c2b42178b7288d8bc48761c4" args="(in unsigned long screenId, in boolean BGR, out unsigned long width, out unsigned long height,[retval] out octet[] data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::readSavedThumbnailToArray </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>screenId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in boolean&nbsp;</td>
          <td class="paramname"> <em>BGR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out octet[]&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Thumbnail is retrieved to an array of bytes in uncompressed 32-bit BGRA or RGBA format. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>screenId</em>&nbsp;</td><td>Saved guest screen to read from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BGR</em>&nbsp;</td><td>How to order bytes in the pixel. A pixel consists of 4 bytes. If this parameter is true, then bytes order is: B, G, R, 0xFF. If this parameter is false, then bytes order is: R, G, B, 0xFF.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Bitmap width.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Bitmap height.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Array with resulting bitmap data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2a706ef07c004d9d4ddba0334077550"></a><!-- doxytag: member="IMachine::readSavedThumbnailPNGToArray" ref="ac2a706ef07c004d9d4ddba0334077550" args="(in unsigned long screenId, out unsigned long width, out unsigned long height,[retval] out octet[] data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::readSavedThumbnailPNGToArray </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>screenId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out octet[]&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Thumbnail in PNG format is retrieved to an array of bytes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>screenId</em>&nbsp;</td><td>Saved guest screen to read from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Image width.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Image height.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Array with resulting PNG data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80465cbf8932bfa94f857cef4010f45d"></a><!-- doxytag: member="IMachine::querySavedScreenshotPNGSize" ref="a80465cbf8932bfa94f857cef4010f45d" args="(in unsigned long screenId, out unsigned long size, out unsigned long width, out unsigned long height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::querySavedScreenshotPNGSize </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>screenId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns size in bytes and dimensions of a saved PNG image of screenshot from saved state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>screenId</em>&nbsp;</td><td>Saved guest screen to query info from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of buffer required to store the PNG binary data.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Image width.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Image height. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10bf74b011dcfee33b52c0579d7e2d70"></a><!-- doxytag: member="IMachine::readSavedScreenshotPNGToArray" ref="a10bf74b011dcfee33b52c0579d7e2d70" args="(in unsigned long screenId, out unsigned long width, out unsigned long height,[retval] out octet[] data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::readSavedScreenshotPNGToArray </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>screenId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out unsigned long&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out octet[]&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Screenshot in PNG format is retrieved to an array of bytes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>screenId</em>&nbsp;</td><td>Saved guest screen to read from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>Image width.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>Image height.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Array with resulting PNG data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa561e166e64b11450803d0d981f2f093"></a><!-- doxytag: member="IMachine::hotPlugCPU" ref="aa561e166e64b11450803d0d981f2f093" args="(in unsigned long cpu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::hotPlugCPU </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>cpu</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Plugs a CPU into the machine. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu</em>&nbsp;</td><td>The CPU id to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b7f63a54fa7ef3250a0ad05528350dd"></a><!-- doxytag: member="IMachine::hotUnplugCPU" ref="a4b7f63a54fa7ef3250a0ad05528350dd" args="(in unsigned long cpu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::hotUnplugCPU </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>cpu</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a CPU from the machine. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu</em>&nbsp;</td><td>The CPU id to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3dbd8f5fcb134f0c2550b612034a654"></a><!-- doxytag: member="IMachine::getCPUStatus" ref="aa3dbd8f5fcb134f0c2550b612034a654" args="(in unsigned long cpu,[retval] out boolean attached)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::getCPUStatus </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out boolean&nbsp;</td>
          <td class="paramname"> <em>attached</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current status of the given CPU. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu</em>&nbsp;</td><td>The CPU id to check for.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attached</em>&nbsp;</td><td>Status of the CPU. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc7a2f42d66a2e9781855ca6f3eb7a43"></a><!-- doxytag: member="IMachine::queryLogFilename" ref="acc7a2f42d66a2e9781855ca6f3eb7a43" args="(in unsigned long idx,[retval] out wstring filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::queryLogFilename </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out wstring&nbsp;</td>
          <td class="paramname"> <em>filename</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Queries for the VM log file name of an given index. </p>
<p>Returns an empty string if a log file with that index doesn't exists.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>idx</em>&nbsp;</td><td>Which log file name to query. 0=current log file.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>On return the full path to the log file or an empty string on error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18dba7b39651237cb87f2bb9cf3291fa"></a><!-- doxytag: member="IMachine::readLog" ref="a18dba7b39651237cb87f2bb9cf3291fa" args="(in unsigned long idx, in long long offset, in long long size,[retval] out octet[] data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::readLog </td>
          <td>(</td>
          <td class="paramtype">in unsigned long&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long long&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in long long&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out octet[]&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads the VM log file. </p>
<p>The chunk size is limited, so even if you ask for a big piece there might be less data returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>idx</em>&nbsp;</td><td>Which log file to read. 0=current log file.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>Offset in the log file.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Chunk size to read in the log file.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Data read from the log file. A data size of 0 means end of file if the requested chunk size was not 0. This is the unprocessed file data, i.e. the line ending style depends on the platform of the system the server is running on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21f0811ae21e028b716037f2b68c42ff"></a><!-- doxytag: member="IMachine::cloneTo" ref="a21f0811ae21e028b716037f2b68c42ff" args="(in IMachine target, in CloneMode mode, in CloneOptions[] options,[retval] out IProgress progress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMachine::cloneTo </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="interface_i_machine.html">IMachine</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#a16234ad9f11c851b50869d9718b664a2">CloneMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#a15b096f772b66efdc6c998d70e575fc7">CloneOptions</a>[]&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&nbsp;</td>
          <td class="paramname"> <em>progress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a clone of this machine, either as a full clone (which means creating independent copies of the hard disk media, save states and so on), or as a linked clone (which uses its own differencing media, sharing the parent media with the source machine). </p>
<p>The target machine object must have been created previously with <a class="el" href="interface_i_virtual_box.html#aabb76f2d305052b305ccd78d18b05ab8">IVirtualBox::createMachine</a><b></b>, and all the settings will be transferred except the VM name and the hardware UUID. You can set the VM name and the new hardware UUID when creating the target machine. The network MAC addresses are newly created for all newtwork adapters. You can change that behaviour with the options parameter. The operation is performed asynchronously, so the machine object will be not be usable until the <em>progress</em> object signals completion.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>Target machine object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Which states should be cloned.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>Options for the cloning operation.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>progress</em>&nbsp;</td><td>Progress object to track the operation completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Expected result codes:</b></dt><dd><table class="doxtable">
<tr>
<td>E_INVALIDARG </td><td><em>target</em> is <code>null</code>.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a06bb12649ae1d59be7dcf982d7a55817"></a><!-- doxytag: member="IMachine::parent" ref="a06bb12649ae1d59be7dcf982d7a55817" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_virtual_box.html">IVirtualBox</a> <a class="el" href="interface_i_machine.html#a06bb12649ae1d59be7dcf982d7a55817">IMachine::parent</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Associated parent object. </p>

</div>
</div>
<a class="anchor" id="a2b6c9cc91c11db18c5b6b870556355f2"></a><!-- doxytag: member="IMachine::accessible" ref="a2b6c9cc91c11db18c5b6b870556355f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute boolean <a class="el" href="interface_i_machine.html#a2b6c9cc91c11db18c5b6b870556355f2">IMachine::accessible</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether this virtual machine is currently accessible or not. </p>
<p>A machine is always deemed accessible unless it is registered <em>and</em> its settings file cannot be read or parsed (either because the file itself is unavailable or has invalid XML contents).</p>
<p>Every time this property is read, the accessibility state of this machine is re-evaluated. If the returned value is <code>false</code>, the <a class="el" href="interface_i_machine.html#a81cdf161d5d9f8e3e1491802768e533a">accessError</a><b></b> property may be used to get the detailed error information describing the reason of inaccessibility, including XML error messages.</p>
<p>When the machine is inaccessible, only the following properties can be used on it: </p>
<ul>
<li>
<a class="el" href="interface_i_machine.html#a06bb12649ae1d59be7dcf982d7a55817">parent</a><b></b>  </li>
<li>
<a class="el" href="interface_i_machine.html#a8c2872f28654d4cee4e8029bf6eaec60">id</a><b></b>  </li>
<li>
<a class="el" href="interface_i_machine.html#a7e7b7939c050afa7475e249e06961e75">settingsFilePath</a><b></b>  </li>
<li>
<a class="el" href="interface_i_machine.html#a2b6c9cc91c11db18c5b6b870556355f2">accessible</a><b></b>  </li>
<li>
<a class="el" href="interface_i_machine.html#a81cdf161d5d9f8e3e1491802768e533a">accessError</a><b></b>  </li>
</ul>
<p>An attempt to access any other property or method will return an error.</p>
<p>The only possible action you can perform on an inaccessible machine is to unregister it using the <a class="el" href="interface_i_machine.html#accfecb34e04b20108c7bf8b469c32d5a">IMachine::unregister</a><b></b> call (or, to check for the accessibility state once more by querying this property).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>In the current implementation, once this property returns <code>true</code>, the machine will never become inaccessible later, even if its settings file cannot be successfully read/written any more (at least, until the VirtualBox server is restarted). This limitation may be removed in future releases. </dd></dl>

</div>
</div>
<a class="anchor" id="a81cdf161d5d9f8e3e1491802768e533a"></a><!-- doxytag: member="IMachine::accessError" ref="a81cdf161d5d9f8e3e1491802768e533a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_virtual_box_error_info.html">IVirtualBoxErrorInfo</a> <a class="el" href="interface_i_machine.html#a81cdf161d5d9f8e3e1491802768e533a">IMachine::accessError</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Error information describing the reason of machine inaccessibility. </p>
<p>Reading this property is only valid after the last call to <a class="el" href="interface_i_machine.html#a2b6c9cc91c11db18c5b6b870556355f2">accessible</a><b></b> returned <code>false</code> (i.e. the machine is currently inaccessible). Otherwise, a <code>null</code> <a class="el" href="interface_i_virtual_box_error_info.html" title="The IVirtualBoxErrorInfo interface represents extended error information.">IVirtualBoxErrorInfo</a> object will be returned. </p>

</div>
</div>
<a class="anchor" id="a0f8041e0562be7a0b32be686384285f5"></a><!-- doxytag: member="IMachine::name" ref="a0f8041e0562be7a0b32be686384285f5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring <a class="el" href="interface_i_machine.html#a0f8041e0562be7a0b32be686384285f5">IMachine::name</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Name of the virtual machine. </p>
<p>Besides being used for human-readable identification purposes everywhere in VirtualBox, the virtual machine name is also used as a name of the machine's settings file and as a name of the subdirectory this settings file resides in. Thus, every time you change the value of this property, the settings file will be renamed once you call <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> to confirm the change. The containing subdirectory will be also renamed, but only if it has exactly the same name as the settings file itself prior to changing this property (for backward compatibility with previous API releases). The above implies the following limitations: </p>
<ul>
<li>
The machine name cannot be empty. </li>
<li>
The machine name can contain only characters that are valid file name characters according to the rules of the file system used to store VirtualBox configuration. </li>
<li>
You cannot have two or more machines with the same name if they use the same subdirectory for storing the machine settings files. </li>
<li>
You cannot change the name of the machine if it is running, or if any file in the directory containing the settings file is being used by another running machine or by any other process in the host operating system at a time when <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> is called.  </li>
</ul>
<p>If any of the above limitations are hit, <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> will return an appropriate error message explaining the exact reason and the changes you made to this machine will not be saved.</p>
<p>Starting with VirtualBox 4.0, a ".vbox" extension of the settings file is recommended, but not enforced. (Previous versions always used a generic ".xml" extension.) </p>

</div>
</div>
<a class="anchor" id="af19c3adad1315ceb9bdac881e545e602"></a><!-- doxytag: member="IMachine::description" ref="af19c3adad1315ceb9bdac881e545e602" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring <a class="el" href="interface_i_machine.html#af19c3adad1315ceb9bdac881e545e602">IMachine::description</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Description of the virtual machine. </p>
<p>The description attribute can contain any text and is typically used to describe the hardware and software configuration of the virtual machine in detail (i.e. network settings, versions of the installed software and so on). </p>

</div>
</div>
<a class="anchor" id="a8c2872f28654d4cee4e8029bf6eaec60"></a><!-- doxytag: member="IMachine::id" ref="a8c2872f28654d4cee4e8029bf6eaec60" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstringUUID <a class="el" href="interface_i_machine.html#a8c2872f28654d4cee4e8029bf6eaec60">IMachine::id</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>UUID of the virtual machine. </p>

</div>
</div>
<a class="anchor" id="a27536e99a6b64ac628a9098037ab5d7c"></a><!-- doxytag: member="IMachine::groups" ref="a27536e99a6b64ac628a9098037ab5d7c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring [] <a class="el" href="interface_i_machine.html#a27536e99a6b64ac628a9098037ab5d7c">IMachine::groups</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Array of machine group names of which this machine is a member. </p>
<p><code>""</code> and <code>"/"</code> are synonyms for the toplevel group. Each group is only listed once, however they are listed in no particular order and there is no guarantee that there are no gaps in the group hierarchy (i.e. <code>"/group"</code>, <code>"/group/subgroup/subsubgroup"</code> is a valid result). </p>

</div>
</div>
<a class="anchor" id="a8b78acadfe037c9153080fb055f46a7d"></a><!-- doxytag: member="IMachine::OSTypeId" ref="a8b78acadfe037c9153080fb055f46a7d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring <a class="el" href="interface_i_machine.html#a8b78acadfe037c9153080fb055f46a7d">IMachine::OSTypeId</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>User-defined identifier of the Guest OS type. </p>
<p>You may use <a class="el" href="interface_i_virtual_box.html#a59008a50b8352e70b968450a4748ec39">IVirtualBox::getGuestOSType</a><b></b> to obtain an <a class="el" href="interface_i_guest_o_s_type.html">IGuestOSType</a> object representing details about the given Guest OS type.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This value may differ from the value returned by <a class="el" href="interface_i_guest.html#a1836d4706baed01b5de022ac2ca25ab6">IGuest::OSTypeId</a><b></b> if Guest Additions are installed to the guest OS. </dd></dl>

</div>
</div>
<a class="anchor" id="a40e9ec512ab94e9878a1f848c51c8832"></a><!-- doxytag: member="IMachine::hardwareVersion" ref="a40e9ec512ab94e9878a1f848c51c8832" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring <a class="el" href="interface_i_machine.html#a40e9ec512ab94e9878a1f848c51c8832">IMachine::hardwareVersion</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hardware version identifier. </p>
<p>Internal use only for now. </p>

</div>
</div>
<a class="anchor" id="ab2573dd9ec7e316b4c3115e84db9cf83"></a><!-- doxytag: member="IMachine::hardwareUUID" ref="ab2573dd9ec7e316b4c3115e84db9cf83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstringUUID <a class="el" href="interface_i_machine.html#ab2573dd9ec7e316b4c3115e84db9cf83">IMachine::hardwareUUID</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The UUID presented to the guest via memory tables, hardware and guest properties. </p>
<p>For most VMs this is the same as the <em>id</em>, but for VMs which have been cloned or teleported it may be the same as the source VM. The latter is because the guest shouldn't notice that it was cloned or teleported. </p>

</div>
</div>
<a class="anchor" id="a78fd87584b8d5e02ccdf061c12e8e299"></a><!-- doxytag: member="IMachine::CPUCount" ref="a78fd87584b8d5e02ccdf061c12e8e299" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long <a class="el" href="interface_i_machine.html#a78fd87584b8d5e02ccdf061c12e8e299">IMachine::CPUCount</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of virtual CPUs in the VM. </p>

</div>
</div>
<a class="anchor" id="a466c25d9049510f39c71f7bd75bad63b"></a><!-- doxytag: member="IMachine::CPUHotPlugEnabled" ref="a466c25d9049510f39c71f7bd75bad63b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean <a class="el" href="interface_i_machine.html#a466c25d9049510f39c71f7bd75bad63b">IMachine::CPUHotPlugEnabled</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This setting determines whether VirtualBox allows CPU hotplugging for this machine. </p>

</div>
</div>
<a class="anchor" id="a47753f3eaff825b684018a2f88be95f6"></a><!-- doxytag: member="IMachine::CPUExecutionCap" ref="a47753f3eaff825b684018a2f88be95f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long <a class="el" href="interface_i_machine.html#a47753f3eaff825b684018a2f88be95f6">IMachine::CPUExecutionCap</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Means to limit the number of CPU cycles a guest can use. </p>
<p>The unit is percentage of host CPU cycles per second. The valid range is 1 - 100. 100 (the default) implies no limit. </p>

</div>
</div>
<a class="anchor" id="a5bb5f057419fdc8505882ed5be4d6876"></a><!-- doxytag: member="IMachine::memorySize" ref="a5bb5f057419fdc8505882ed5be4d6876" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long <a class="el" href="interface_i_machine.html#a5bb5f057419fdc8505882ed5be4d6876">IMachine::memorySize</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>System memory size in megabytes. </p>

</div>
</div>
<a class="anchor" id="af8340bf65bbf1a384b7902cfe65a6dd5"></a><!-- doxytag: member="IMachine::memoryBalloonSize" ref="af8340bf65bbf1a384b7902cfe65a6dd5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long <a class="el" href="interface_i_machine.html#af8340bf65bbf1a384b7902cfe65a6dd5">IMachine::memoryBalloonSize</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Memory balloon size in megabytes. </p>

</div>
</div>
<a class="anchor" id="a29c0171d96c683d579974f4a508a7cf0"></a><!-- doxytag: member="IMachine::pageFusionEnabled" ref="a29c0171d96c683d579974f4a508a7cf0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean <a class="el" href="interface_i_machine.html#a29c0171d96c683d579974f4a508a7cf0">IMachine::pageFusionEnabled</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This setting determines whether VirtualBox allows page fusion for this machine (64 bits host only). </p>

</div>
</div>
<a class="anchor" id="a225e13b6d6a38f1feb07d9773548e14e"></a><!-- doxytag: member="IMachine::VRAMSize" ref="a225e13b6d6a38f1feb07d9773548e14e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long <a class="el" href="interface_i_machine.html#a225e13b6d6a38f1feb07d9773548e14e">IMachine::VRAMSize</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Video memory size in megabytes. </p>

</div>
</div>
<a class="anchor" id="a29f8081e07baba47014d0aa1661a6de8"></a><!-- doxytag: member="IMachine::accelerate3DEnabled" ref="a29f8081e07baba47014d0aa1661a6de8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean <a class="el" href="interface_i_machine.html#a29f8081e07baba47014d0aa1661a6de8">IMachine::accelerate3DEnabled</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This setting determines whether VirtualBox allows this machine to make use of the 3D graphics support available on the host. </p>

</div>
</div>
<a class="anchor" id="a0bbb876d9ad8dbd1b312bc6d2d235d52"></a><!-- doxytag: member="IMachine::accelerate2DVideoEnabled" ref="a0bbb876d9ad8dbd1b312bc6d2d235d52" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean <a class="el" href="interface_i_machine.html#a0bbb876d9ad8dbd1b312bc6d2d235d52">IMachine::accelerate2DVideoEnabled</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This setting determines whether VirtualBox allows this machine to make use of the 2D video acceleration support available on the host. </p>

</div>
</div>
<a class="anchor" id="af0ffb20e866dfb40df1464def112f778"></a><!-- doxytag: member="IMachine::monitorCount" ref="af0ffb20e866dfb40df1464def112f778" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long <a class="el" href="interface_i_machine.html#af0ffb20e866dfb40df1464def112f778">IMachine::monitorCount</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of virtual monitors. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Only effective on Windows XP and later guests with Guest Additions installed. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c074dd14205c40258cabe8371d7cf38"></a><!-- doxytag: member="IMachine::VideoCaptureEnabled" ref="a6c074dd14205c40258cabe8371d7cf38" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean <a class="el" href="interface_i_machine.html#a6c074dd14205c40258cabe8371d7cf38">IMachine::VideoCaptureEnabled</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This setting determines whether VirtualBox uses video recording to record VM session. </p>

</div>
</div>
<a class="anchor" id="a2a27190c7ff1a7c1f904b63755405291"></a><!-- doxytag: member="IMachine::VideoCaptureFile" ref="a2a27190c7ff1a7c1f904b63755405291" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring <a class="el" href="interface_i_machine.html#a2a27190c7ff1a7c1f904b63755405291">IMachine::VideoCaptureFile</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This setting determines what filename VirtualBox uses to save the recorded content. </p>

</div>
</div>
<a class="anchor" id="ae040b6ed6411f583298902d6f312f558"></a><!-- doxytag: member="IMachine::VideoCaptureWidth" ref="ae040b6ed6411f583298902d6f312f558" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long <a class="el" href="interface_i_machine.html#ae040b6ed6411f583298902d6f312f558">IMachine::VideoCaptureWidth</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This setting determines what should be the horizontal resolution of recorded video. </p>

</div>
</div>
<a class="anchor" id="a03fed1419ff7c4fa8194a28bfb87fbf8"></a><!-- doxytag: member="IMachine::VideoCaptureHeight" ref="a03fed1419ff7c4fa8194a28bfb87fbf8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long <a class="el" href="interface_i_machine.html#a03fed1419ff7c4fa8194a28bfb87fbf8">IMachine::VideoCaptureHeight</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This setting determines what should be the vertical resolution of recorded video. </p>

</div>
</div>
<a class="anchor" id="a72dd7fe9c6a11670842c43d3e4b5736b"></a><!-- doxytag: member="IMachine::BIOSSettings" ref="a72dd7fe9c6a11670842c43d3e4b5736b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_b_i_o_s_settings.html">IBIOSSettings</a> <a class="el" href="interface_i_machine.html#a72dd7fe9c6a11670842c43d3e4b5736b">IMachine::BIOSSettings</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Object containing all BIOS settings. </p>

</div>
</div>
<a class="anchor" id="adc5c21a35eabc1db1d3157878a6d9ec6"></a><!-- doxytag: member="IMachine::firmwareType" ref="adc5c21a35eabc1db1d3157878a6d9ec6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute <a class="el" href="_virtual_box_8idl.html#afddb85483810aea160a6bf2c90259b55">FirmwareType</a> <a class="el" href="interface_i_machine.html#adc5c21a35eabc1db1d3157878a6d9ec6">IMachine::firmwareType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of firmware (such as legacy BIOS or EFI), used for initial bootstrap in this VM. </p>

</div>
</div>
<a class="anchor" id="a169cccf5417aa6c90b4515f45b919d2e"></a><!-- doxytag: member="IMachine::pointingHIDType" ref="a169cccf5417aa6c90b4515f45b919d2e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute <a class="el" href="_virtual_box_8idl.html#ae904ea9e2892b3cb117b076fdf4c8897">PointingHIDType</a> <a class="el" href="interface_i_machine.html#a169cccf5417aa6c90b4515f45b919d2e">IMachine::pointingHIDType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of pointing HID (such as mouse or tablet) used in this VM. </p>
<p>The default is typically "PS2Mouse" but can vary depending on the requirements of the guest operating system. </p>

</div>
</div>
<a class="anchor" id="a837c6f223122e587ff00027346a9f148"></a><!-- doxytag: member="IMachine::keyboardHIDType" ref="a837c6f223122e587ff00027346a9f148" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute <a class="el" href="_virtual_box_8idl.html#af8b91ad2ad35847326c7d9d4c9587142">KeyboardHIDType</a> <a class="el" href="interface_i_machine.html#a837c6f223122e587ff00027346a9f148">IMachine::keyboardHIDType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of keyboard HID used in this VM. </p>
<p>The default is typically "PS2Keyboard" but can vary depending on the requirements of the guest operating system. </p>

</div>
</div>
<a class="anchor" id="a80240bbec6fb99a78aa903c5e4047287"></a><!-- doxytag: member="IMachine::HPETEnabled" ref="a80240bbec6fb99a78aa903c5e4047287" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean <a class="el" href="interface_i_machine.html#a80240bbec6fb99a78aa903c5e4047287">IMachine::HPETEnabled</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This attribute controls if High Precision Event Timer (HPET) is enabled in this VM. </p>
<p>Use this property if you want to provide guests with additional time source, or if guest requires HPET to function correctly. Default is false. </p>

</div>
</div>
<a class="anchor" id="ad027bca4612b7bec68db5eb591230e9e"></a><!-- doxytag: member="IMachine::chipsetType" ref="ad027bca4612b7bec68db5eb591230e9e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute <a class="el" href="_virtual_box_8idl.html#a0c8eff86d82f71a0a7f2e99a4a702ffa">ChipsetType</a> <a class="el" href="interface_i_machine.html#ad027bca4612b7bec68db5eb591230e9e">IMachine::chipsetType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Chipset type used in this VM. </p>

</div>
</div>
<a class="anchor" id="adfcf2b4359a54f318fa9f17ee521fd50"></a><!-- doxytag: member="IMachine::snapshotFolder" ref="adfcf2b4359a54f318fa9f17ee521fd50" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring <a class="el" href="interface_i_machine.html#adfcf2b4359a54f318fa9f17ee521fd50">IMachine::snapshotFolder</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Full path to the directory used to store snapshot data (differencing media and saved state files) of this machine. </p>
<p>The initial value of this property is <code>&lt;</code><a class="el" href="interface_i_machine.html#a7e7b7939c050afa7475e249e06961e75">path_to_settings_file</a><b></b><code>&gt;/&lt;</code><a class="el" href="interface_i_machine.html#a8c2872f28654d4cee4e8029bf6eaec60">machine_uuid</a><b></b><code>&gt;</code>.</p>
<p>Currently, it is an error to try to change this property on a machine that has snapshots (because this would require to move possibly large files to a different location). A separate method will be available for this purpose later.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Setting this property to <code>null</code> or to an empty string will restore the initial value.</dd>
<dd>
When setting this property, the specified path can be absolute (full path) or relative to the directory where the <a class="el" href="interface_i_machine.html#a7e7b7939c050afa7475e249e06961e75">machine settings file</a><b></b> is located. When reading this property, a full path is always returned.</dd>
<dd>
The specified path may not exist, it will be created when necessary. </dd></dl>

</div>
</div>
<a class="anchor" id="a74fe661f18e88069711241ca227c1708"></a><!-- doxytag: member="IMachine::VRDEServer" ref="a74fe661f18e88069711241ca227c1708" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_v_r_d_e_server.html">IVRDEServer</a> <a class="el" href="interface_i_machine.html#a74fe661f18e88069711241ca227c1708">IMachine::VRDEServer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>VirtualBox Remote Desktop Extension (VRDE) server object. </p>

</div>
</div>
<a class="anchor" id="ae034d22cc2d2dc4998337b945f772251"></a><!-- doxytag: member="IMachine::emulatedUSBWebcameraEnabled" ref="ae034d22cc2d2dc4998337b945f772251" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean <a class="el" href="interface_i_machine.html#ae034d22cc2d2dc4998337b945f772251">IMachine::emulatedUSBWebcameraEnabled</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a31970f365eecc56cbf754eb0b1cf51a5"></a><!-- doxytag: member="IMachine::emulatedUSBCardReaderEnabled" ref="a31970f365eecc56cbf754eb0b1cf51a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean <a class="el" href="interface_i_machine.html#a31970f365eecc56cbf754eb0b1cf51a5">IMachine::emulatedUSBCardReaderEnabled</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aef972b7f8785c3a3f98a592a246ca4b4"></a><!-- doxytag: member="IMachine::mediumAttachments" ref="aef972b7f8785c3a3f98a592a246ca4b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a> [] <a class="el" href="interface_i_machine.html#aef972b7f8785c3a3f98a592a246ca4b4">IMachine::mediumAttachments</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Array of media attached to this machine. </p>

</div>
</div>
<a class="anchor" id="a8894b6628a62bffc1394c4d09c0dbb6d"></a><!-- doxytag: member="IMachine::USBController" ref="a8894b6628a62bffc1394c4d09c0dbb6d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_u_s_b_controller.html">IUSBController</a> <a class="el" href="interface_i_machine.html#a8894b6628a62bffc1394c4d09c0dbb6d">IMachine::USBController</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Associated USB controller object. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>If USB functionality is not available in the given edition of VirtualBox, this method will set the result code to <code>E_NOTIMPL</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f283749ee3227e25c624298a57976e9"></a><!-- doxytag: member="IMachine::audioAdapter" ref="a3f283749ee3227e25c624298a57976e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_audio_adapter.html">IAudioAdapter</a> <a class="el" href="interface_i_machine.html#a3f283749ee3227e25c624298a57976e9">IMachine::audioAdapter</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Associated audio adapter, always present. </p>

</div>
</div>
<a class="anchor" id="ac5638e205ed8f8a1473d3b866e9a7d4f"></a><!-- doxytag: member="IMachine::storageControllers" ref="ac5638e205ed8f8a1473d3b866e9a7d4f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_storage_controller.html">IStorageController</a> [] <a class="el" href="interface_i_machine.html#ac5638e205ed8f8a1473d3b866e9a7d4f">IMachine::storageControllers</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Array of storage controllers attached to this machine. </p>

</div>
</div>
<a class="anchor" id="a7e7b7939c050afa7475e249e06961e75"></a><!-- doxytag: member="IMachine::settingsFilePath" ref="a7e7b7939c050afa7475e249e06961e75" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstring <a class="el" href="interface_i_machine.html#a7e7b7939c050afa7475e249e06961e75">IMachine::settingsFilePath</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Full name of the file containing machine settings data. </p>

</div>
</div>
<a class="anchor" id="a7fa04613f860573400ba570fcf80f3ef"></a><!-- doxytag: member="IMachine::settingsModified" ref="a7fa04613f860573400ba570fcf80f3ef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute boolean <a class="el" href="interface_i_machine.html#a7fa04613f860573400ba570fcf80f3ef">IMachine::settingsModified</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whether the settings of this machine have been modified (but neither yet saved nor discarded). </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Reading this property is only valid on instances returned by <a class="el" href="interface_i_session.html#a83d8f53d35e522599b192cac168c3495">ISession::machine</a><b></b> and on new machines created by <a class="el" href="interface_i_virtual_box.html#aabb76f2d305052b305ccd78d18b05ab8">IVirtualBox::createMachine</a><b></b> or opened by <a class="el" href="interface_i_virtual_box.html#a4b44e306db59ce580ae54d9f50a0686a">IVirtualBox::openMachine</a><b></b> but not yet registered, or on unregistered machines after calling <a class="el" href="interface_i_machine.html#accfecb34e04b20108c7bf8b469c32d5a">IMachine::unregister</a><b></b>. For all other cases, the settings can never be modified.</dd>
<dd>
For newly created unregistered machines, the value of this property is always <code>true</code> until <a class="el" href="interface_i_machine.html#a2eb47e1d878566569b26893cc12bd8e1">saveSettings</a><b></b> is called (no matter if any machine settings have been changed after the creation or not). For opened machines the value is set to <code>false</code> (and then follows to normal rules). </dd></dl>

</div>
</div>
<a class="anchor" id="aecc00e3c014d4548a025e4eafff7056e"></a><!-- doxytag: member="IMachine::sessionState" ref="aecc00e3c014d4548a025e4eafff7056e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="_virtual_box_8idl.html#ac82c179a797c0d7c249d1b98a8e3aa8f">SessionState</a> <a class="el" href="interface_i_machine.html#aecc00e3c014d4548a025e4eafff7056e">IMachine::sessionState</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Current session state for this machine. </p>

</div>
</div>
<a class="anchor" id="a7f8692397b0743822a9be4dd81be9019"></a><!-- doxytag: member="IMachine::sessionType" ref="a7f8692397b0743822a9be4dd81be9019" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstring <a class="el" href="interface_i_machine.html#a7f8692397b0743822a9be4dd81be9019">IMachine::sessionType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of the session. </p>
<p>If <a class="el" href="interface_i_machine.html#aecc00e3c014d4548a025e4eafff7056e">sessionState</a><b></b> is Spawning or Locked, this attribute contains the same value as passed to the <a class="el" href="interface_i_machine.html#a5f6e112de89f7e1d300738c9a055d5c9">IMachine::launchVMProcess</a><b></b> method in the <em>type</em> parameter. If the session was used with <a class="el" href="interface_i_machine.html#af28da645b00a821547d9cb8e92f8b7b0">IMachine::lockMachine</a><b></b>, or if <a class="el" href="interface_i_machine.html#aecc00e3c014d4548a025e4eafff7056e">sessionState</a><b></b> is SessionClosed, the value of this attribute is an empty string. </p>

</div>
</div>
<a class="anchor" id="a7380f79a10f9813dbced54f51004c6b5"></a><!-- doxytag: member="IMachine::sessionPID" ref="a7380f79a10f9813dbced54f51004c6b5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute unsigned long <a class="el" href="interface_i_machine.html#a7380f79a10f9813dbced54f51004c6b5">IMachine::sessionPID</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Identifier of the session process. </p>
<p>This attribute contains the platform-dependent identifier of the process whose session was used with <a class="el" href="interface_i_machine.html#af28da645b00a821547d9cb8e92f8b7b0">IMachine::lockMachine</a><b></b> call. The returned value is only valid if <a class="el" href="interface_i_machine.html#aecc00e3c014d4548a025e4eafff7056e">sessionState</a><b></b> is Locked or Unlocking by the time this property is read. </p>

</div>
</div>
<a class="anchor" id="a9653e9d996d60fc54e8bed22179d92b2"></a><!-- doxytag: member="IMachine::state" ref="a9653e9d996d60fc54e8bed22179d92b2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="_virtual_box_8idl.html#a80b08f71210afe16038e904a656ed9eb">MachineState</a> <a class="el" href="interface_i_machine.html#a9653e9d996d60fc54e8bed22179d92b2">IMachine::state</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Current execution state of this machine. </p>

</div>
</div>
<a class="anchor" id="a3a96e177095b0f13c2fc43f425d9a45d"></a><!-- doxytag: member="IMachine::lastStateChange" ref="a3a96e177095b0f13c2fc43f425d9a45d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute long long <a class="el" href="interface_i_machine.html#a3a96e177095b0f13c2fc43f425d9a45d">IMachine::lastStateChange</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Time stamp of the last execution state change, in milliseconds since 1970-01-01 UTC. </p>

</div>
</div>
<a class="anchor" id="a6bf84094ff47ad0f8f2517ee513eed02"></a><!-- doxytag: member="IMachine::stateFilePath" ref="a6bf84094ff47ad0f8f2517ee513eed02" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstring <a class="el" href="interface_i_machine.html#a6bf84094ff47ad0f8f2517ee513eed02">IMachine::stateFilePath</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Full path to the file that stores the execution state of the machine when it is in the <a class="el" href="_virtual_box_8idl.html#a80b08f71210afe16038e904a656ed9ebac8fa7577db141baf9cc06279665f122b">MachineState_Saved</a><b></b> state. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>When the machine is not in the Saved state, this attribute is an empty string. </dd></dl>

</div>
</div>
<a class="anchor" id="a27636df01fde10102799eec13416ab51"></a><!-- doxytag: member="IMachine::logFolder" ref="a27636df01fde10102799eec13416ab51" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstring <a class="el" href="interface_i_machine.html#a27636df01fde10102799eec13416ab51">IMachine::logFolder</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Full path to the folder that stores a set of rotated log files recorded during machine execution. </p>
<p>The most recent log file is named <code>VBox.log</code>, the previous log file is named <code>VBox.log.1</code> and so on (up to <code>VBox.log.3</code> in the current version). </p>

</div>
</div>
<a class="anchor" id="ac785dbe04eccc0793d949d6940202767"></a><!-- doxytag: member="IMachine::currentSnapshot" ref="ac785dbe04eccc0793d949d6940202767" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_snapshot.html">ISnapshot</a> <a class="el" href="interface_i_machine.html#ac785dbe04eccc0793d949d6940202767">IMachine::currentSnapshot</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Current snapshot of this machine. </p>
<p>This is <code>null</code> if the machine currently has no snapshots. If it is not <code>null</code>, then it was set by one of <a class="el" href="interface_i_console.html#a2bf8c3d28f9d8782db8c4098b1bc5c7e">IConsole::takeSnapshot</a><b></b>, <a class="el" href="interface_i_console.html#aae96e7c62ee31ae37f88c94293dc9bfe">IConsole::deleteSnapshot</a><b></b> or <a class="el" href="interface_i_console.html#aa310049a3d86b48c9c8b5ddd39094342">IConsole::restoreSnapshot</a><b></b>, depending on which was called last. See <a class="el" href="interface_i_snapshot.html">ISnapshot</a><b></b> for details. </p>

</div>
</div>
<a class="anchor" id="a1946d487a58f17cf4ee78a28c64a50da"></a><!-- doxytag: member="IMachine::snapshotCount" ref="a1946d487a58f17cf4ee78a28c64a50da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute unsigned long <a class="el" href="interface_i_machine.html#a1946d487a58f17cf4ee78a28c64a50da">IMachine::snapshotCount</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of snapshots taken on this machine. </p>
<p>Zero means the machine doesn't have any snapshots. </p>

</div>
</div>
<a class="anchor" id="a141d87506c33bd09d7fad144ca52c871"></a><!-- doxytag: member="IMachine::currentStateModified" ref="a141d87506c33bd09d7fad144ca52c871" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute boolean <a class="el" href="interface_i_machine.html#a141d87506c33bd09d7fad144ca52c871">IMachine::currentStateModified</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if the current state of the machine is not identical to the state stored in the current snapshot. </p>
<p>The current state is identical to the current snapshot only directly after one of the following calls are made:</p>
<ul>
<li>
<a class="el" href="interface_i_console.html#aa310049a3d86b48c9c8b5ddd39094342">IConsole::restoreSnapshot</a><b></b>  </li>
<li>
<a class="el" href="interface_i_console.html#a2bf8c3d28f9d8782db8c4098b1bc5c7e">IConsole::takeSnapshot</a><b></b> (issued on a "powered off" or "saved" machine, for which <a class="el" href="interface_i_machine.html#a7fa04613f860573400ba570fcf80f3ef">settingsModified</a><b></b> returns <code>false</code>)  </li>
</ul>
<p>The current state remains identical until one of the following happens: </p>
<ul>
<li>
settings of the machine are changed </li>
<li>
the saved state is deleted </li>
<li>
the current snapshot is deleted </li>
<li>
an attempt to execute the machine is made </li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>For machines that don't have snapshots, this property is always <code>false</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9d48e83d2a8b245afa00116b1e7ca37"></a><!-- doxytag: member="IMachine::sharedFolders" ref="ab9d48e83d2a8b245afa00116b1e7ca37" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_shared_folder.html">ISharedFolder</a> [] <a class="el" href="interface_i_machine.html#ab9d48e83d2a8b245afa00116b1e7ca37">IMachine::sharedFolders</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Collection of shared folders for this machine (permanent shared folders). </p>
<p>These folders are shared automatically at machine startup and available only to the guest OS installed within this machine.</p>
<p>New shared folders are added to the collection using <a class="el" href="interface_i_machine.html#ae49562a26a94c09044d8bdb9341d836b">createSharedFolder</a><b></b>. Existing shared folders can be removed using <a class="el" href="interface_i_machine.html#a30e6a10490fde39a3e97e2ae1d1fa3ce">removeSharedFolder</a><b></b>. </p>

</div>
</div>
<a class="anchor" id="ab21aa593375c45dcd5a7b4c3a2a73b5f"></a><!-- doxytag: member="IMachine::clipboardMode" ref="ab21aa593375c45dcd5a7b4c3a2a73b5f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute <a class="el" href="_virtual_box_8idl.html#a096d8cfa9dea55360b7d50c70176a222">ClipboardMode</a> <a class="el" href="interface_i_machine.html#ab21aa593375c45dcd5a7b4c3a2a73b5f">IMachine::clipboardMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Synchronization mode between the host OS clipboard and the guest OS clipboard. </p>

</div>
</div>
<a class="anchor" id="ab72d980217139256ae5601d2e6350d2a"></a><!-- doxytag: member="IMachine::dragAndDropMode" ref="ab72d980217139256ae5601d2e6350d2a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute <a class="el" href="_virtual_box_8idl.html#a37d006b98a1330f12bc97f781d87b346">DragAndDropMode</a> <a class="el" href="interface_i_machine.html#ab72d980217139256ae5601d2e6350d2a">IMachine::dragAndDropMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Which mode is allowed for drag'n'drop. </p>

</div>
</div>
<a class="anchor" id="ae173701527dc449099b9681da27999ff"></a><!-- doxytag: member="IMachine::guestPropertyNotificationPatterns" ref="ae173701527dc449099b9681da27999ff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring <a class="el" href="interface_i_machine.html#ae173701527dc449099b9681da27999ff">IMachine::guestPropertyNotificationPatterns</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A comma-separated list of simple glob patterns. </p>
<p>Changes to guest properties whose name matches one of the patterns will generate an <a class="el" href="interface_i_guest_property_changed_event.html">IGuestPropertyChangedEvent</a><b></b> signal. </p>

</div>
</div>
<a class="anchor" id="a662d92a1c47ac75f15a4660ae5247d22"></a><!-- doxytag: member="IMachine::teleporterEnabled" ref="a662d92a1c47ac75f15a4660ae5247d22" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean <a class="el" href="interface_i_machine.html#a662d92a1c47ac75f15a4660ae5247d22">IMachine::teleporterEnabled</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When set to <em>true</em>, the virtual machine becomes a target teleporter the next time it is powered on. </p>
<p>This can only set to <em>true</em> when the VM is in the <em>PoweredOff</em> or <em>Aborted</em> state. </p>

</div>
</div>
<a class="anchor" id="a45fb6bfa8fc01e46728d3c7ee716a237"></a><!-- doxytag: member="IMachine::teleporterPort" ref="a45fb6bfa8fc01e46728d3c7ee716a237" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long <a class="el" href="interface_i_machine.html#a45fb6bfa8fc01e46728d3c7ee716a237">IMachine::teleporterPort</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The TCP port the target teleporter will listen for incoming teleportations on. </p>
<p>0 means the port is automatically selected upon power on. The actual value can be read from this property while the machine is waiting for incoming teleportations. </p>

</div>
</div>
<a class="anchor" id="a0f8a33069ddcde81ba6928f11584cb3b"></a><!-- doxytag: member="IMachine::teleporterAddress" ref="a0f8a33069ddcde81ba6928f11584cb3b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring <a class="el" href="interface_i_machine.html#a0f8a33069ddcde81ba6928f11584cb3b">IMachine::teleporterAddress</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The address the target teleporter will listen on. </p>
<p>If set to an empty string, it will listen on all addresses. </p>

</div>
</div>
<a class="anchor" id="a7df9bcd55c58f6565e20833e50643e79"></a><!-- doxytag: member="IMachine::teleporterPassword" ref="a7df9bcd55c58f6565e20833e50643e79" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring <a class="el" href="interface_i_machine.html#a7df9bcd55c58f6565e20833e50643e79">IMachine::teleporterPassword</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The password to check for on the target teleporter. </p>
<p>This is just a very basic measure to prevent simple hacks and operators accidentally beaming a virtual machine to the wrong place.</p>
<p>Note that you SET a plain text password while reading back a HASHED password. Setting a hashed password is currently not supported. </p>

</div>
</div>
<a class="anchor" id="a2ab837621c5d3770b234c8d3b695cc0c"></a><!-- doxytag: member="IMachine::faultToleranceState" ref="a2ab837621c5d3770b234c8d3b695cc0c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute <a class="el" href="_virtual_box_8idl.html#af7bf1134499ce00177105e69908fba29">FaultToleranceState</a> <a class="el" href="interface_i_machine.html#a2ab837621c5d3770b234c8d3b695cc0c">IMachine::faultToleranceState</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fault tolerance state; disabled, source or target. </p>
<p>This property can be changed at any time. If you change it for a running VM, then the fault tolerance address and port must be set beforehand. </p>

</div>
</div>
<a class="anchor" id="a97d9e6325ba7778568ce7142a7d246f7"></a><!-- doxytag: member="IMachine::faultTolerancePort" ref="a97d9e6325ba7778568ce7142a7d246f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long <a class="el" href="interface_i_machine.html#a97d9e6325ba7778568ce7142a7d246f7">IMachine::faultTolerancePort</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The TCP port the fault tolerance source or target will use for communication. </p>

</div>
</div>
<a class="anchor" id="a3cd50b855a14f679f863f0f31a9a201e"></a><!-- doxytag: member="IMachine::faultToleranceAddress" ref="a3cd50b855a14f679f863f0f31a9a201e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring <a class="el" href="interface_i_machine.html#a3cd50b855a14f679f863f0f31a9a201e">IMachine::faultToleranceAddress</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The address the fault tolerance source or target. </p>

</div>
</div>
<a class="anchor" id="a09574d93988af20a756e702429737e57"></a><!-- doxytag: member="IMachine::faultTolerancePassword" ref="a09574d93988af20a756e702429737e57" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring <a class="el" href="interface_i_machine.html#a09574d93988af20a756e702429737e57">IMachine::faultTolerancePassword</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The password to check for on the standby VM. </p>
<p>This is just a very basic measure to prevent simple hacks and operators accidentally choosing the wrong standby VM. </p>

</div>
</div>
<a class="anchor" id="acf5c1a4cdeb81e28f33b92efad526f58"></a><!-- doxytag: member="IMachine::faultToleranceSyncInterval" ref="acf5c1a4cdeb81e28f33b92efad526f58" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long <a class="el" href="interface_i_machine.html#acf5c1a4cdeb81e28f33b92efad526f58">IMachine::faultToleranceSyncInterval</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The interval in ms used for syncing the state between source and target. </p>

</div>
</div>
<a class="anchor" id="ae1ec62f64a126aa9645ba55e78089f6e"></a><!-- doxytag: member="IMachine::RTCUseUTC" ref="ae1ec62f64a126aa9645ba55e78089f6e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean <a class="el" href="interface_i_machine.html#ae1ec62f64a126aa9645ba55e78089f6e">IMachine::RTCUseUTC</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When set to <em>true</em>, the RTC device of the virtual machine will run in UTC time, otherwise in local time. </p>
<p>Especially Unix guests prefer the time in UTC. </p>

</div>
</div>
<a class="anchor" id="a9999c5c9eb8eecac98a45bde62fc3bce"></a><!-- doxytag: member="IMachine::IOCacheEnabled" ref="a9999c5c9eb8eecac98a45bde62fc3bce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean <a class="el" href="interface_i_machine.html#a9999c5c9eb8eecac98a45bde62fc3bce">IMachine::IOCacheEnabled</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When set to <em>true</em>, the builtin I/O cache of the virtual machine will be enabled. </p>

</div>
</div>
<a class="anchor" id="a596ae3cdd7eea9f92c79dddd4c738f6f"></a><!-- doxytag: member="IMachine::IOCacheSize" ref="a596ae3cdd7eea9f92c79dddd4c738f6f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long <a class="el" href="interface_i_machine.html#a596ae3cdd7eea9f92c79dddd4c738f6f">IMachine::IOCacheSize</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum size of the I/O cache in MB. </p>

</div>
</div>
<a class="anchor" id="a38a5c9476de084724b89fda4ea26ae12"></a><!-- doxytag: member="IMachine::PCIDeviceAssignments" ref="a38a5c9476de084724b89fda4ea26ae12" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_p_c_i_device_attachment.html">IPCIDeviceAttachment</a> [] <a class="el" href="interface_i_machine.html#a38a5c9476de084724b89fda4ea26ae12">IMachine::PCIDeviceAssignments</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Array of PCI devices assigned to this machine, to get list of all PCI devices attached to the machine use <a class="el" href="interface_i_console.html#a6d41c200e67a37cdbc9c270317831774">IConsole::attachedPCIDevices</a><b></b> attribute, as this attribute is intended to list only devices additional to what described in virtual hardware config. </p>
<p>Usually, this list keeps host's physical devices assigned to the particular machine. </p>

</div>
</div>
<a class="anchor" id="a15c8725d2d0bf1bc99d3fc2048dfe98a"></a><!-- doxytag: member="IMachine::bandwidthControl" ref="a15c8725d2d0bf1bc99d3fc2048dfe98a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_bandwidth_control.html">IBandwidthControl</a> <a class="el" href="interface_i_machine.html#a15c8725d2d0bf1bc99d3fc2048dfe98a">IMachine::bandwidthControl</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bandwidth control manager. </p>

</div>
</div>
<a class="anchor" id="a08618a97a181c10f9113b3844d6ae577"></a><!-- doxytag: member="IMachine::tracingEnabled" ref="a08618a97a181c10f9113b3844d6ae577" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean <a class="el" href="interface_i_machine.html#a08618a97a181c10f9113b3844d6ae577">IMachine::tracingEnabled</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables the tracing facility in the VMM (including PDM devices + drivers). </p>
<p>The VMM will consume about 0.5MB of more memory when enabled and there may be some extra overhead from tracepoints that are always enabled. </p>

</div>
</div>
<a class="anchor" id="a2f4ec9af3f5705deed580ccba5a2e142"></a><!-- doxytag: member="IMachine::tracingConfig" ref="a2f4ec9af3f5705deed580ccba5a2e142" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring <a class="el" href="interface_i_machine.html#a2f4ec9af3f5705deed580ccba5a2e142">IMachine::tracingConfig</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tracepoint configuration to apply at startup when <a class="el" href="interface_i_machine.html#a08618a97a181c10f9113b3844d6ae577">IMachine::tracingEnabled</a><b></b> is true. </p>
<p>The string specifies a space separated of tracepoint group names to enable. The special group 'all' enables all tracepoints. Check DBGFR3TracingConfig for more details on available tracepoint groups and such.</p>
<p>Note that on hosts supporting DTrace (or similar), a lot of the tracepoints may be implemented exclusivly as DTrace probes. So, the effect of the same config may differ between Solaris and Windows for example. </p>

</div>
</div>
<a class="anchor" id="acfa33f6952f420c0163dd2eefccc62ed"></a><!-- doxytag: member="IMachine::allowTracingToAccessVM" ref="acfa33f6952f420c0163dd2eefccc62ed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean <a class="el" href="interface_i_machine.html#acfa33f6952f420c0163dd2eefccc62ed">IMachine::allowTracingToAccessVM</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables tracepoints in PDM devices and drivers to use the VMCPU or VM structures when firing off trace points. </p>
<p>This is especially useful with DTrace tracepoints, as it allows you to use the VMCPU or VM pointer to obtain useful information such as guest register state.</p>
<p>This is disabled by default because devices and drivers normally has no business accessing the VMCPU or VM structures, and are therefore unable to get any pointers to these. </p>

</div>
</div>
<a class="anchor" id="aca5154cad0ba95af8d3ce358571222bc"></a><!-- doxytag: member="IMachine::autostartEnabled" ref="aca5154cad0ba95af8d3ce358571222bc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean <a class="el" href="interface_i_machine.html#aca5154cad0ba95af8d3ce358571222bc">IMachine::autostartEnabled</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables autostart of the VM during system boot. </p>

</div>
</div>
<a class="anchor" id="a9d371d975c607f0d3f81ab57459149df"></a><!-- doxytag: member="IMachine::autostartDelay" ref="a9d371d975c607f0d3f81ab57459149df" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute unsigned long <a class="el" href="interface_i_machine.html#a9d371d975c607f0d3f81ab57459149df">IMachine::autostartDelay</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of seconds to wait until the VM should be started during system boot. </p>

</div>
</div>
<a class="anchor" id="a724adf774f12d25744bbac488c7fe26e"></a><!-- doxytag: member="IMachine::autostopType" ref="a724adf774f12d25744bbac488c7fe26e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute <a class="el" href="_virtual_box_8idl.html#a03ad7f2af3ceb813a15cdc614db93c73">AutostopType</a> <a class="el" href="interface_i_machine.html#a724adf774f12d25744bbac488c7fe26e">IMachine::autostopType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Action type to do when the system is shutting down. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Sep 13 2012 07:09:48 for VirtualBox Main API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
